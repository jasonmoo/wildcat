{"id":"wc-003f","content_hash":"d8b3e456d0aea529e220b80580fd385e1ae3c488d737bce711a502069a71841b","title":"Unify --scope behavior across commands","description":"The symbol and search commands handle --scope differently:\n\n**symbol command**: Uses ParseScope() which resolves package names to full import paths.\n- Requires valid, existing package paths\n- `--scope -test` fails if no 'test' package exists\n- More strict/precise\n\n**search command**: Uses filterByScope() with substring matching.\n- `--scope -test` excludes any package containing 'test'\n- More lenient/exploratory\n\n**tree command**: Simple all/project/package, no exclusions.\n\nThis inconsistency is confusing. Options:\n1. Make all commands use ParseScope (strict)\n2. Make all commands use substring matching (lenient)\n3. Support both: exact paths AND substring patterns (e.g., `-internal/lsp` vs `-*test*`)\n\nRelated: wc-cc1e (glob patterns in scope)","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-22T16:00:12.723948514Z","updated_at":"2026-01-23T02:55:04.420569733Z","closed_at":"2026-01-23T02:55:04.420569733Z","dependencies":[{"issue_id":"wc-003f","depends_on_id":"wc-cc1e","type":"related","created_at":"2026-01-22T16:00:17.300968144Z","created_by":"jason"}]}
{"id":"wc-020a","content_hash":"f904d6d6f902ebac6873e87bd6963df7d56779f17a75581295eeb7571da99cdb","title":"CLAUDE.md: Restore Bigger Picture / AIDE context","description":"The 'Bigger Picture' section about AIDE spec was removed during refactoring. This provided valuable project context about wildcat being a reference implementation for a broader spec. Consider restoring or linking to docs/AIDE-SPEC-SEED.md.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-26T05:22:47.361325456Z","updated_at":"2026-01-26T12:37:27.910829797Z","closed_at":"2026-01-26T12:37:27.910829797Z"}
{"id":"wc-029e","content_hash":"727b0d5ccee93e3f605b2ef17a8e11ff221eb221cdeb5ac0665ab49dcd85c64e","title":"Package output: annotate all symbols with reference counts","description":"Enhance package markdown output to include reference counts for every symbol, turning it into a usage heatmap for AI consumption.\n\n## Format\nEvery symbol gets: `// N refs/M pkgs` or `// N internal` for unexported symbols\n\n## Example output\n```markdown\n# Constants (6)\nconst SymbolKindConst SymbolKind = \"const\" // search.go:21 // 3 refs/1 pkg\nconst SymbolKindFunc SymbolKind = \"func\" // search.go:17 // 45 refs/8 pkgs\n\n# Functions (36)\nfunc FormatDecl(v ast.Decl) ([]string, error) // format.go:17 // 12 refs/4 pkgs\nfunc formatFuncDecl(w io.Writer, v *ast.FuncDecl) error // format.go:61 // 3 internal\nfunc GOROOT() string // stdlib.go:18 // 0 refs\n\n# Types (20)\ntype DeadCodeResult struct {...} // deadcode.go:15 // 8 refs/2 pkgs, 3 methods\ntype Symbol struct {...} // search.go:25 // 156 refs/12 pkgs, 5 methods\n```\n\n## AI benefits\n- Instantly see which symbols are critical (high refs/pkgs)\n- Identify dead code candidates (0 refs)\n- Understand public API vs internal implementation\n- Prioritize careful review for heavily-used symbols\n\n## Implementation notes\n- Leverage existing reference-finding code from symbol command\n- Distinguish internal refs (same package) from external refs\n- For unexported symbols, only show internal ref count\n- Consider caching since this adds compute overhead\n\n## Supersedes\nCloses wc-29c3 (original simpler version)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-22T03:19:14.907081633Z","updated_at":"2026-01-22T13:35:43.027638003Z","closed_at":"2026-01-22T13:35:43.027638003Z"}
{"id":"wc-033e","content_hash":"94abc50916f9b64635fac54bb03a3af8640ae800319f2b31c0a41f94fa77216d","title":"Group deadcode output by package","description":"Update deadcode markdown output to group dead symbols by package, similar to how the package command organizes its output. Currently shows a flat list of types - should show:\n\n## package github.com/jasonmoo/wildcat/internal/lsp\n\n### Types\n...\n\n## package github.com/jasonmoo/wildcat/internal/symbols\n\n### Types\n...","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-21T13:32:01.828279693Z","updated_at":"2026-01-21T13:36:48.185394631Z","closed_at":"2026-01-21T13:36:48.185394631Z"}
{"id":"wc-05f9","content_hash":"7e94f6b3ac9630583e3f0a03f1e5e2b86f8120579cb8213426f77dc7ae0165dd","title":"Add wildcat package command - full package profile/introspection","description":"## Problem\nAI agents need to understand package structure quickly for navigation and orientation.\n\n## Solution: `wildcat package` Command\nA dense package map following godoc organization - gives AI the environment around any symbol.\n\n## Command\n```\nwildcat package \u003cimport-path-or-dir\u003e [flags]\n```\n\n## Output Design\n\n### Symbol Format\n- **signature**: Full Go signature\n- **kind**: function, method, type, struct, interface, const, var, field\n- **location**: `fullpath:start_line[:end_line]` (end_line when symbol spans multiple lines)\n\n### Organization (godoc order)\n1. **Constants** - grouped\n2. **Variables** - grouped  \n3. **Functions** - standalone (alphabetical, excluding constructors)\n4. **Types** - alphabetical, each with:\n   - Type definition (fields for structs, methods for interfaces inline)\n   - Constructor functions (NewFoo, ParseFoo - funcs returning that type)\n   - Methods on the type\n\n### Include Everything\n- Exported and unexported (export status is runtime concern, not AI concern)\n- Fields, consts, vars, methods - all symbols\n- No file boundary markers (files don't affect code behavior)\n\n### Proposed Structure\n```json\n{\n  \"query\": {\n    \"command\": \"package\",\n    \"target\": \"./internal/symbols\"\n  },\n  \"package\": {\n    \"import_path\": \"github.com/jasonmoo/wildcat/internal/symbols\",\n    \"name\": \"symbols\",\n    \"dir\": \"/path/to/internal/symbols\"\n  },\n  \"constants\": [\n    { \"signature\": \"const DefaultLimit = 20\", \"location\": \"parse.go:5\" }\n  ],\n  \"variables\": [\n    { \"signature\": \"var ErrNoMatch = errors.New(\\\"no match\\\")\", \"location\": \"errors.go:8\" }\n  ],\n  \"functions\": [\n    { \"signature\": \"func Parse(q Query) ([]Result, error)\", \"location\": \"parse.go:24:45\" }\n  ],\n  \"types\": [\n    {\n      \"signature\": \"type Query struct { Pattern string; Limit int }\",\n      \"kind\": \"struct\",\n      \"location\": \"parse.go:9:15\",\n      \"constructors\": [\n        { \"signature\": \"func NewQuery(pattern string) Query\", \"location\": \"parse.go:50:55\" }\n      ],\n      \"methods\": [\n        { \"signature\": \"func (q Query) String() string\", \"location\": \"parse.go:99:105\" },\n        { \"signature\": \"func (q Query) Validate() error\", \"location\": \"parse.go:107:120\" }\n      ]\n    }\n  ],\n  \"imports\": [\n    { \"package\": \"context\" },\n    { \"package\": \"github.com/jasonmoo/wildcat/internal/lsp\" }\n  ],\n  \"imported_by\": [\n    { \"package\": \"github.com/jasonmoo/wildcat/cmd\" }\n  ],\n  \"summary\": {\n    \"constants\": 1,\n    \"variables\": 1,\n    \"functions\": 1,\n    \"types\": 1,\n    \"imports\": 2,\n    \"imported_by\": 1\n  }\n}\n```\n\n## Flags\n- `--exclude-stdlib` - Exclude stdlib from imports\n\n## Acceptance Criteria\n- [ ] Output follows godoc organization\n- [ ] Symbols include full signatures\n- [ ] Location format: fullpath:start[:end]\n- [ ] All symbols included (exported + unexported)\n- [ ] Constructors grouped with their types\n- [ ] imports and imported_by included","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T07:34:19.580728556Z","updated_at":"2026-01-14T07:28:20.120828968Z","closed_at":"2026-01-14T07:28:20.120828968Z"}
{"id":"wc-0657","content_hash":"cf49dce8959efdfffade1403f8862c5d1e61ed6f4414b7e2fc2a8edd61170560","title":"Symbol command: distinguish interface consumers vs implementers","description":"User feedback: For interfaces, it would be helpful to distinguish between:\n\n1. **Consumers** - packages/functions that accept the interface as a parameter\n2. **Implementers** - types that satisfy the interface\n\nCurrently the symbol command shows:\n- Implementations (types that implement)\n- References (all usages)\n\nProposed enhancement:\n- Add a 'Consumers' section showing functions/methods that accept the interface type\n- This helps understand API boundaries: who depends on the contract vs who fulfills it\n\nExample use case: Understanding which packages would be affected if an interface changes vs which packages need to provide implementations.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-22T07:51:50.348036728Z","updated_at":"2026-01-22T15:42:49.833607099Z","closed_at":"2026-01-22T15:42:49.833607099Z"}
{"id":"wc-099e","content_hash":"d347e2b5c9b509a9e398145d9d6c27291a2951033ff94b2935d9b814bf03217c","title":"Orchestration layer - symbol lookup, recursion, snippets","description":"## Context\nThis is Wildcat's value-add on top of LSP. While LSP provides raw queries, Wildcat orchestrates multiple calls, handles recursion, extracts snippets, and formats output.\n\n## What Wildcat Adds\n\n| Feature | LSP Provides | Wildcat Adds |\n|---------|--------------|--------------|\n| Symbol lookup | workspace/symbol (returns list) | Parse 'pkg.Func' → filter → find exact match |\n| Transitive calls | Direct callers only | Recursive calls to build full tree |\n| Snippets | Line/column position | Read file, extract source context |\n| Call expression | Position only | Extract actual call text |\n| in_test flag | Nothing | Filename pattern matching |\n| Args extraction | Nothing | Parse snippet for arguments |\n\n## Scope\nCreate orchestration packages:\n\n### 1. Symbol Lookup (`internal/symbols`)\n```go\n// Parse user input like \"config.Load\" or \"Server.Start\"\nfunc Parse(input string) (*SymbolQuery, error)\n\n// Find symbol using workspace/symbol + filtering\nfunc Resolve(ctx context.Context, client lsp.Client, query *SymbolQuery) (*ResolvedSymbol, error)\n\n// Generate suggestions for typos\nfunc SuggestSimilar(ctx context.Context, client lsp.Client, query string) ([]string, error)\n```\n\n### 2. Recursive Traversal (`internal/traverse`)\n```go\ntype TraverseOptions struct {\n    Direction    Direction // Up (callers) or Down (callees)\n    MaxDepth     int\n    ExcludeTests bool\n    ExcludeStdlib bool\n    Visited      map[string]bool // cycle detection\n}\n\n// Recursively walk call hierarchy\nfunc WalkCallHierarchy(ctx context.Context, client lsp.Client, root CallHierarchyItem, opts TraverseOptions) (*CallTree, error)\n\n// Build flat list of callers/callees\nfunc FlattenCallers(tree *CallTree) []CallerInfo\n```\n\n### 3. Snippet Extraction (`internal/snippets`)\n```go\n// Extract source lines around a position\nfunc Extract(filePath string, line int, contextLines int) (string, error)\n\n// Extract the call expression at position\nfunc ExtractCallExpr(filePath string, line, startCol, endCol int) (string, error)\n\n// Parse arguments from call expression\nfunc ParseArgs(callExpr string) ([]string, error)\n\n// Detect if file is a test file\nfunc IsTestFile(filePath string) bool\n```\n\n## Implementation Notes\n\n### Symbol Resolution Flow\n```\nUser: \"config.Load\"\n  → Parse(\"config.Load\") → SymbolQuery{Package: \"config\", Name: \"Load\"}\n  → workspace/symbol(\"Load\")\n  → Filter results where package contains \"config\" and name == \"Load\"\n  → Return position for further LSP calls\n```\n\n### Recursive Call Hierarchy Flow\n```\nUser: \"callers --depth 3\"\n  → PrepareCallHierarchy(symbol position)\n  → IncomingCalls(item) → direct callers\n  → For each caller:\n      → If depth \u003c maxDepth \u0026\u0026 not visited:\n          → PrepareCallHierarchy(caller position)\n          → IncomingCalls(item) → recurse\n  → Return full tree\n```\n\n## Acceptance Criteria\n- [ ] Parse pkg.Func, Type.Method, full/path/pkg.Func formats\n- [ ] Resolve symbol via workspace/symbol with filtering\n- [ ] Generate fuzzy suggestions for typos\n- [ ] Recursive traversal respects depth limit\n- [ ] Cycle detection prevents infinite loops\n- [ ] Snippet extraction preserves indentation\n- [ ] Call expression extraction works\n- [ ] Test file detection works\n- [ ] Unit tests for each component\n\n## Files\n- internal/symbols/parse.go\n- internal/symbols/resolve.go\n- internal/symbols/suggest.go\n- internal/traverse/walk.go\n- internal/traverse/flatten.go\n- internal/snippets/extract.go\n- internal/snippets/callexpr.go\n- internal/snippets/testfile.go\n- internal/*_test.go\n\n## Depends On\n- wc-cb10 (LSP client infrastructure)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T04:57:45.340753104Z","updated_at":"2026-01-10T05:33:24.247366914Z","closed_at":"2026-01-10T05:33:24.247366914Z","dependencies":[{"issue_id":"wc-099e","depends_on_id":"wc-cb10","type":"blocks","created_at":"2026-01-10T04:57:54.413462978Z","created_by":"jason"}]}
{"id":"wc-0be7","content_hash":"fd22d08ea571753ef23c56197686cc75dc84dec3995b5285352fb6c9539d809c","title":"package command: spurious ambiguous symbol warnings for same-named packages","description":"**Problem:**\nWhen running `wildcat package` on a specific package, diagnostics warn about ambiguous symbols when another package has the same short name.\n\n**Example:**\n```\nwildcat package database/model\n```\n\n**Output:**\n```\n## ⚠️  Diagnostics (3)\n- [warning] ambiguous symbol \"model.Message\" matches [github.com/jasonmoo/bbb/database/model.Message\ngithub.com/jasonmoo/bbb/search/model.Message]; refs unavailable\n```\n\n**Expected:**\nNo ambiguity - the user explicitly specified `database/model`, so symbols should resolve within that package. The existence of `search/model.Message` shouldn't matter.\n\n**Likely cause:**\nReference counting or cross-package analysis using short package names (`model.Message`) instead of fully qualified paths (`database/model.Message`) when looking up symbols.\n\n**Fix:**\nWhen analyzing a specific package, use full package paths for symbol resolution, not short names that could match multiple packages.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-29T02:21:17.893210237Z","updated_at":"2026-01-29T03:26:36.265140902Z","closed_at":"2026-01-29T03:26:36.265140902Z"}
{"id":"wc-0c82","content_hash":"12e977885eb4d0b7470afd7e50db8bc2583e8cab9dd0d0b17e16230fd7a39910","title":"Migrate channels command to Command[T] pattern","description":"Create internal/commands/channels package using wildcat package loader, following the pattern established by internal/commands/package","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-20T05:48:22.691322439Z","updated_at":"2026-01-20T06:46:00.810652205Z","closed_at":"2026-01-20T06:46:00.810652205Z"}
{"id":"wc-0ca4","content_hash":"c5be68b4783f37c14380f20936dc0f5ed046f3f6643002dc6d8007e542e5af07","title":"AI-optimized output patterns: annotations, sorting, thresholds","description":"Apply user-tested patterns for AI-consumable output across all commands.\n\n## Key Insights from User Testing (2026-01-17)\n\nWhat helps AI agents consume wildcat output:\n\n### 1. Pre-computed Comparisons\nBars/histograms encode ratios visually - saves mental math for the AI.\nExample: methods vs dependents dual-bar in project command.\n\n### 2. Anomaly Markers\nExplicit ⚠ flags with interpretation are more actionable than raw data.\nExample: '⚠ High complexity: 50+ dependents' rather than just 'dependents: 52'\n\n### 3. Sorted by Actionable Metric\nPosition carries information (top = look here first).\nExample: Core packages sorted by dependent count, not alphabetically.\n\n### 4. Thresholds Called Out\n'These 3 packages have \u003e50 dependents' is directly actionable.\nExplicit threshold-based grouping helps AI prioritize.\n\n## Recommendation\nBars for gestalt understanding, but also:\n- Explicit annotations on outliers\n- Smart sorting (not just alphabetical)\n- Threshold-based flags/groupings\n\n## Commands to Apply\n- [ ] project - primary target for these patterns\n- [ ] package - could highlight complex types\n- [ ] symbol - could flag high-impact symbols\n- [ ] search - already sorted by relevance\n\n## Source\nUser testing session feedback - 2026-01-17","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-17T09:05:09.055267392Z","updated_at":"2026-01-17T09:05:09.055267392Z"}
{"id":"wc-0fd4","content_hash":"420d1595e45500377493555648ef5c00f5b95a3382202e0821a6ffcabc777803","title":"Ensure JSON output follows best practices for AI jq usage","description":"When AIs use jq to filter wildcat output, parsing errors can occur. Audit all command outputs to ensure:\n\n- Valid JSON when --json flag is used\n- Consistent field naming and structure\n- No mixed formats (markdown vs JSON in same output)\n- Proper null handling\n- Array vs object consistency\n\nThis improves reliability when AIs script with wildcat output.","status":"open","priority":4,"issue_type":"task","created_at":"2026-01-24T14:01:14.52468858Z","updated_at":"2026-01-24T14:01:14.52468858Z"}
{"id":"wc-1019","content_hash":"8529ec5cd7e64abbae79687944db1473a280d9a1dd2cfbd6a86afeac69cf6e94","title":"deadcode: interface with implementations should not be flagged as dead","description":"If an interface is implemented by types in the project, the interface should not be reported as dead. The implementations depend on the interface definition. Found during cleanup: Formatter interface was flagged dead but had JSONFormatter, YAMLFormatter, MarkdownFormatter implementing it. Deleting the interface would break those types.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-22T15:12:23.963154511Z","updated_at":"2026-01-22T15:40:18.372143127Z","closed_at":"2026-01-22T15:40:18.372143127Z"}
{"id":"wc-10a8","content_hash":"4b404f963a9a6e07d31ac58b32e263eb55f10bf5c235fc2fd42be6d117976f44","title":"Add read command with path-based addressing","description":"Create a new `read` command that takes semantic paths (like `golang.WalkRefs`, `golang.WalkRefs/body`, `golang.Symbol/fields/Name`) and optionally line ranges.\n\n**Behavior:**\n- Resolve the path to a code location\n- Render the scope byte-for-byte\n- Lines are the atomic unit - if you path into a value, render the whole line(s), not just the value\n- Optional line range support for additional filtering within the path scope\n\n**Example usage:**\n```\nwildcat read golang.WalkRefs              # whole function\nwildcat read golang.WalkRefs/body         # function body\nwildcat read golang.WalkRefs/params[0]    # first parameter (renders full line)\nwildcat read golang.Symbol                # whole type\nwildcat read golang.Symbol/fields/Name    # specific field\n```\n\n**Path syntax to design:**\n- Package-qualified symbols: `pkg.SymbolName`\n- Sub-paths: `/body`, `/params[N]`, `/returns[N]`, `/fields/Name`, `/methods/Name`\n- Consider how to handle methods: `pkg.Type.Method` or `pkg.Type/methods/Method`\n\n**Goal:** Enable Claude to read code by semantic identity rather than file paths and line numbers. This is foundational for path-based code editing.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-26T10:21:51.528137302Z","updated_at":"2026-01-27T12:24:05.292428454Z","closed_at":"2026-01-27T12:24:05.292428454Z"}
{"id":"wc-12d7","content_hash":"cc3ec044cd91f6fda9b182a69d11e880be929b52e6585b494c7482223b497711","title":"Loading and memory optimizations","description":"Current approach loads entire project into memory upfront:\n- LoadModulePackages() loads all packages with LoadAllSyntax\n- CollectSymbols() builds full index at startup\n- All analysis operates on in-memory data structures\n\nFor large codebases this could be problematic:\n- High memory usage\n- Slow startup time\n- No incremental updates\n\nPotential optimizations to explore:\n\n1. **Lazy loading**: Only load packages when needed\n   - Keep package list, load syntax on demand\n   - Cache loaded packages with LRU eviction\n\n2. **Incremental indexing**: Update index on file changes\n   - Watch for file system changes\n   - Re-index only affected packages\n   - Useful for long-running server mode\n\n3. **Streaming results**: Don't buffer entire result\n   - Stream JSON output as analysis proceeds\n   - Reduces memory for large result sets\n\n4. **Selective loading modes**:\n   - packages.LoadTypes for some operations (faster)\n   - LoadAllSyntax only when AST needed\n   - Current code uses LoadAllSyntax for everything\n\n5. **Index persistence**: Cache symbol index to disk\n   - Faster cold start\n   - Invalidate on file changes\n\nContext from discussion:\n- This work is blocked on test coverage (wc-b0eb)\n- Optimizing without tests risks introducing subtle bugs\n- Feature set should stabilize first, then tests, then optimize\n- 'Optimize safely once we have test coverage in place'\n\nNot urgent - current approach works fine for typical project sizes (~8k-50k LOC). Revisit when users report performance issues on larger codebases.","status":"open","priority":4,"issue_type":"task","created_at":"2026-01-23T06:08:36.766925819Z","updated_at":"2026-01-23T06:09:06.855497934Z","dependencies":[{"issue_id":"wc-12d7","depends_on_id":"wc-b0eb","type":"blocks","created_at":"2026-01-23T06:08:43.432522288Z","created_by":"jason"}]}
{"id":"wc-1393","content_hash":"bfbb5c11f47fe9a90213b260917534a3cd8bf988057d1106dc39690eefe16bef","title":"Document --scope exclusion syntax","description":"User feedback: --scope -test fails trying to resolve as package path.\n\nCurrent behavior:\n- `--scope -database` works (excludes database package)\n- `--scope -test` fails - tries to resolve 'test' as a package path\n\nQuestions to resolve:\n- Is -test supposed to exclude test files or a package named 'test'?\n- Should there be a separate flag for excluding test files?\n- Document the exclusion syntax more clearly in help/CLAUDE.md","status":"closed","priority":3,"issue_type":"chore","created_at":"2026-01-22T07:51:32.595079256Z","updated_at":"2026-01-22T15:58:39.179994061Z","closed_at":"2026-01-22T15:58:39.179994061Z"}
{"id":"wc-142a","content_hash":"0857d9d226e00332650130183c4114fa24cc01981a9d5a7b3c17971ab5436917","title":"Support /tag path for struct field tags","description":"Add `/tag` as a path component to address struct field tags.\n\n**Examples:**\n```\ngolang.Symbol.Name/tag                    # the full tag\nwildcat read golang.Symbol.Name/tag       # → \\`json:\"name\"\\`\nwildcat edit golang.Symbol.Name/tag '\\`json:\"full_name\" db:\"name\"\\`'\n```\n\n**Why this matters (from semantic-feedback.md):**\n\u003e Struct tags are currently annoying to edit because you have to match the exact backtick-quoted string with all its contents.\n\nThe backticks and escaping make string-matching fragile. A dedicated /tag path makes this surgical.\n\n**Possible extensions:**\n- `/tag[json]` - just the json portion of the tag\n- `/tag[db]` - just the db portion\n- Tag parsing/reconstruction for individual keys\n\n**Implementation:**\n- Extract tag from ast.Field.Tag\n- Handle nil tags (field has no tag)\n- Preserve backtick quoting in output\n\n**See:** docs/semantic-feedback.md","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-26T13:43:22.074342603Z","updated_at":"2026-01-26T13:43:22.074342603Z"}
{"id":"wc-14fe","content_hash":"62123649d4c465bb2d52fff1041e00b1152b1c46596f65d4b8e5585d46170b8a","title":"Signature/Format errors silently discarded across codebase","description":"Multiple files discard errors from Signature() and FormatXXX() calls with underscore:\n\n- search.go:218-221 - Signature() error uses Name fallback\n- symbol.go:215,243,257,668,736,944,1091 - Multiple sig, _ patterns\n- tree.go:182,446,465 - Signature/FormatFuncDecl errors\n- deadcode.go:272 - Signature error discarded\n- package.go:657-659 - FormatFuncDecl fallback to placeholder\n\nImpact: AI doesn't know why a signature couldn't be rendered. Could be invalid AST, malformed code, etc.\n\nOptions to consider:\n- Include error in output struct (signature_error field)\n- Log warning and include partial info\n- Return error to caller","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:51:34.702410815Z","updated_at":"2026-01-23T10:34:49.594685092Z","closed_at":"2026-01-23T10:34:49.594685092Z","dependencies":[{"issue_id":"wc-14fe","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:51:34.718386923Z","created_by":"jason"},{"issue_id":"wc-14fe","depends_on_id":"wc-79d6","type":"blocks","created_at":"2026-01-23T06:02:12.050586619Z","created_by":"jason"}]}
{"id":"wc-15c5","content_hash":"50c5a3beaed59dce7d6da1c61eed50879185b54b7e74492bf4745632405baf44","title":"Audit codebase for silent failures","description":"Per CLAUDE.md: 'Never silently fail. When wildcat cannot produce code intelligence, it must signal this clearly.'\n\nAudit the entire codebase for patterns that silently discard errors or skip items:\n- `if err != nil { continue }` without logging/reporting\n- `if x == nil { continue }` that hides missing data\n- Discarded errors with `_`\n- Empty catch blocks or swallowed errors\n\nFor each found, create a sub-ticket to discuss the appropriate handling:\n- Return error to caller?\n- Include in output with error field?\n- Log warning?\n- Aggregate and report at end?\n\nThe goal is that an AI using wildcat knows when information is incomplete.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:30:28.986780568Z","updated_at":"2026-01-23T05:53:39.955179908Z","closed_at":"2026-01-23T05:53:39.955179908Z"}
{"id":"wc-171c","content_hash":"f1f01b206bad56a354289e125d21ab58139016ec667f9f2e2abfe07a61b0659e","title":"read: design unified package source rendering","description":"When `read` outputs a package, it currently renders each file separately with repeated package/import blocks. This is noisy and not useful.\n\nGoal: Render package source as a unified body of code, suitable for grepping patterns.\n\nOpen questions:\n- Should we show one consolidated import block at the top, or omit imports entirely?\n- What order should declarations appear? (godoc order: const, var, func, types? or file order?)\n- Should we include file boundaries/comments as markers?\n- How to handle init() functions that appear in multiple files?\n- Should test files be included or excluded by default?\n\nCurrent behavior: concatenates full file sources with `\\n\\n` separator.\nDesired behavior: unified source body without redundant package/import noise.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T14:11:19.275472203Z","updated_at":"2026-01-27T14:11:19.275472203Z"}
{"id":"wc-1857","content_hash":"51d75ad0716abfa31c699b2aedc062f767be810ec74807d83cbb3fec5519d131","title":"Explore: type relationship tree for non-function symbols","description":"Expand tree command to support type/struct symbols, showing field relationships instead of call relationships.\n\nFor a target type:\n- Upstream: types that have fields of the target type (who contains me?)\n- Downstream: types that the target type has as fields (what do I contain?)\n\nExample for 'type Config struct { DB DatabaseConfig; Cache CacheConfig }':\n- Upstream: Server (has Config field), App (has Config field)\n- Downstream: DatabaseConfig, CacheConfig\n\nThis mirrors the call tree concept but for data relationships. Could help understand:\n- Impact of changing a type (what other types embed/contain it)\n- Dependencies of a type (what types it depends on)\n\nStatus: Exploratory - idea from feedback session, not yet validated as worth building.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-22T07:04:29.936916586Z","updated_at":"2026-01-26T05:03:01.695429368Z","closed_at":"2026-01-26T05:03:01.695429368Z"}
{"id":"wc-18ae","content_hash":"07be9b5637e51c790303602af92a63c387a411e5bf3b62baa6bec48cd3fcb76f","title":"Snippet merge failures silently return first location","description":"In snippet.go:385-387, when extractMergedSnippet fails, finalizeLocationGroup silently returns just the first location:\n\nLocation: internal/output/snippet.go:385-387\n\nCode:\n  snippet, snippetStart, snippetEnd, err := e.extractMergedSnippet(...)\n  if err != nil {\n    return locations[0]  // silently drops error and other locations\n  }\n\nImpact: AI doesn't know merge failed. Sees single location when multiple references existed.\n\nOptions:\n- Return all locations unmerged on error\n- Include error field in merged Location\n- Log merge failures","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:53:08.543960506Z","updated_at":"2026-01-26T04:35:55.315507388Z","closed_at":"2026-01-26T04:35:55.315507388Z","dependencies":[{"issue_id":"wc-18ae","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:53:08.561225065Z","created_by":"jason"}]}
{"id":"wc-1a24","content_hash":"7448ed159e19263ed794348e4fe24b2d619748c99b36992090e256fde79df879","title":"read command: add wildcard pattern support","description":"Add wildcard pattern matching to the read command, consistent with ls command.\n\n**Patterns:**\n- `*` matches within a segment (stops at `. / [ ]`)\n- `**/` matches any prefix (or nothing)  \n- `/**` matches any suffix (or nothing)\n- `**` standalone matches anything\n\n**Examples:**\n```\nwildcat read 'spath.Path/fields[*]'     # all fields of a type\nwildcat read 'spath.Path.*'             # type + all methods  \nwildcat read '**.Execute'               # all Execute methods\n```\n\n**Implementation:**\n- Reuse existing `MatchSpathGlob()` from spathglob.go\n- In `readTarget()`, detect patterns and expand to multiple reads\n- Fixed `IsSpathPattern()` to only check for `*` (not `[` which is valid spath syntax)\n\n**Closes:**\n- wc-7bb6 (category without selector - now use `fields[*]`)\n- wc-ae41 (type with all methods - now use `Type.*`)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-28T05:18:40.614697382Z","updated_at":"2026-01-28T05:18:46.990142209Z","closed_at":"2026-01-28T05:18:46.990142209Z"}
{"id":"wc-1d38","content_hash":"e1a84f25e2d3ab17b6dcae1364dc072a81e20ff491a6566c05c51370bb942691","title":"Audit all commands for markdown output support","description":"Some commands may not have markdown output implemented.\n\nAudit each command for -o markdown support:\n- search\n- symbol\n- package\n- tree\n- channels\n- readme\n\nEnsure consistent markdown formatting across all commands.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-16T11:23:06.7459124Z","updated_at":"2026-01-16T11:33:59.009485269Z","closed_at":"2026-01-16T11:33:59.009485269Z"}
{"id":"wc-1e7c","content_hash":"8c270fa1fe31187f38f41c96617f5a0dc4918fd8f700fb5d88daa3b2bb211980","title":"Investigate race condition in WaitForReady logic","description":"Intermittent issue where search returns 0 results despite gopls being ready. Symptoms: fast responses but sometimes empty results. Need to research proper LSP readiness detection and compare with go.lsp.dev/protocol implementation.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-16T14:10:22.862419489Z","updated_at":"2026-01-17T08:28:33.492655148Z","closed_at":"2026-01-17T08:28:33.492655148Z","dependencies":[{"issue_id":"wc-1e7c","depends_on_id":"wc-cadc","type":"related","created_at":"2026-01-16T14:10:32.63563038Z","created_by":"jason"}]}
{"id":"wc-1f43","content_hash":"ac64e30013dfe7fcdaf9f3eb76c023a0fc4baf8acfd552fd7bd21d79e06948dc","title":"Add implementation counts to Satisfies section","description":"When viewing a type's Satisfies section, annotate each interface with how many types implement it:\n- implementations(N pkg, M proj)\n- N pkg = implementations in the target symbol's package\n- M proj = total implementations across the project\n\nThis helps AI agents understand:\n- If target is the only implementation (removing it orphans the interface)\n- How widely used the interface abstraction is\n\nReplace refs(...) with implementations(...) for interfaces in Satisfies section.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-22T06:25:17.623773414Z","updated_at":"2026-01-22T06:31:01.790302573Z","closed_at":"2026-01-22T06:31:01.790302573Z"}
{"id":"wc-22c3","content_hash":"6a2708974bbf9f45da716ba60e7d20d816e356beb933c11e3c345e25abb55c9a","title":"Regression: type aliases to error show all error implementers","description":"**Problem:**\nTypes defined as `type NotFoundError error` incorrectly list all types implementing `error` in their \"implemented by\" list.\n\n**Example:**\n```go\ntype NotFoundError error\n```\n\n**Output:**\n```\ntype NotFoundError error // implemented by: genericSafeError, APIError, APIRateLimitError, ... (dozens of unrelated error types)\n```\n\n**Expected:**\nOnly types that specifically implement `NotFoundError` should be listed, not every type that implements the underlying `error` interface.\n\n**Root cause:**\nInterface satisfaction checking is treating `NotFoundError` as equivalent to `error` for implementer detection. These type aliases/definitions should be treated as distinct interfaces even if structurally identical to stdlib interfaces.\n\n**Note:**\nThere was previous work on `StdlibEquivalent` in the Symbol type - this may be related. The fix should prevent the \"implemented by\" list from being populated with stdlib interface implementers when the type is just an alias.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-29T04:07:43.855088305Z","updated_at":"2026-01-29T04:19:52.841408823Z","closed_at":"2026-01-29T04:19:52.841408823Z"}
{"id":"wc-22ca","content_hash":"94a992c83c313528b2bd45fc658897e65bb929921dc3305b499fc817e895b334","title":"Add PackageSymbol abstraction for Scope-based symbol discovery","description":"Created a new abstraction layer that uses types.Scope as the source of truth for package-level symbol discovery, mapping to AST nodes for formatting.\n\nKey changes:\n- New internal/golang/symbol.go with PackageSymbol struct and LoadPackageSymbols function\n- PackageSymbol contains: Name, Object, Package, File, Node, Methods, Constructors\n- Methods collected via types.Named.Methods() (since methods aren't in Scope)\n- Constructors detected via return type matching\n- Uses position matching (obj.Pos()) to map Scope objects to AST nodes\n\n- New FileImports and PackageImport types in pkgpath.go\n- PackageImport includes pointer to resolved golang.Package (nil for external)\n- Two-pass loading in LoadModulePackages: create packages, then resolve imports\n\n- Added symbol_test.go with tests for both symbols and imports\n\nBenefits:\n- Cleaner discovery: Scope contains only valid, compiled symbols\n- No nil guards needed for type checking (if it's in Scope, types are available)\n- Isolates failure modes from business logic\n- Foundation for simplifying package command and other symbol-based operations","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-24T13:58:33.152387594Z","updated_at":"2026-01-24T13:58:37.421415406Z","closed_at":"2026-01-24T13:58:37.421415406Z"}
{"id":"wc-258b","content_hash":"b7ee4c21732015a2039c2a66835a361cb52059f7f8fb2819fa37915a1fcff811","title":"Migrate from ResolvePackagePath to Project.ResolvePackageName","description":"Replace usages of ResolvePackagePath with the Project method ResolvePackageName for consistency","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-21T14:02:18.339163129Z","updated_at":"2026-01-21T14:12:52.834981391Z","closed_at":"2026-01-21T14:12:52.834981391Z"}
{"id":"wc-2847","content_hash":"f5fd768cd45f440a031347d597ffa3e870d9c4ca775e19ab5417284670bef55e","title":"Audit: deadcode command - Package facility usage","description":"Audit the deadcode command for appropriate use of Package facilities:\n\n**Facilities to consider:**\n- `Types.Scope()` - package-level declarations, already type-resolved\n- `TypesInfo.Defs/Uses` - AST ident → object mappings\n- `Syntax` (AST) - needed for formatting, file association\n\n**Questions to answer:**\n1. Where do we iterate AST when Scope() would be cleaner?\n2. Where do we lookup in TypesInfo with nil checks that could be avoided?\n3. Is AST formatting needed, or could types.TypeString suffice?\n4. Are we using the right facility for each task?\n\nPart of broader Package facility audit. Supersedes wc-389a.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-24T11:14:48.957941846Z","updated_at":"2026-01-24T11:24:14.430069807Z","closed_at":"2026-01-24T11:24:14.430069807Z"}
{"id":"wc-29c3","content_hash":"8a18d8cc98b96a94c3df8076b376ad3bb83403b12e47e5d7a354e701edb30e74","title":"Package files block: show imports count alongside LOC","description":"Enhance the files section in package markdown output to show both lines of code and number of imports per file.\n\nGoal: Help identify files containing heavily used types by contrasting file size with import count.\n\nCurrent output:\n## Files\nformatter.go // 1056 lines\ntypes.go // 235 lines\n\nProposed output (example):\n## Files\nformatter.go // 1056 lines, 12 imports\ntypes.go // 235 lines, 0 imports\n\nThis contrast helps identify:\n- Large files with few imports (self-contained)\n- Small files with many imports (integration points)\n- Files with heavily used types (high import count relative to size)","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-18T08:16:00.916517724Z","updated_at":"2026-01-22T03:19:18.928913909Z","closed_at":"2026-01-22T03:19:18.928913909Z"}
{"id":"wc-2a73","content_hash":"eba29a39497c88ed5d443fe0a8a27b7c0f638805c63d7edd3b19b706549dd454","title":"Add WalkCalls and WalkChannelOps visitor APIs to golang package","description":"Extend the visitor pattern from WalkReferences to cover call graph and channel operation traversals.\n\n## Motivation\nThe tree and channels commands have inline AST traversal logic that could be extracted into reusable visitor APIs, matching the pattern established with WalkReferences.\n\n## Proposed APIs\n\n### WalkCalls (for tree command)\n```go\ntype Call struct {\n    Package    *Package\n    Caller     *ast.FuncDecl  // containing function\n    CallerFile string\n    CallExpr   *ast.CallExpr\n    Called     *types.Func    // resolved callee (via ResolveCallExpr)\n    Line       int\n}\n\ntype CallVisitor func(call Call) bool\n\nfunc WalkCalls(project *Project, visitor CallVisitor)\nfunc WalkCallsInFunc(pkg *Package, fn *ast.FuncDecl, visitor CallVisitor)\n```\n\n### WalkChannelOps (for channels command)\n```go\ntype ChannelOpKind string // send, receive, close, make, select_send, select_receive\n\ntype ChannelOp struct {\n    Package  *Package\n    File     string\n    Line     int\n    Kind     ChannelOpKind\n    ElemType string\n    Node     ast.Node\n}\n\ntype ChannelOpVisitor func(op ChannelOp) bool\n\nfunc WalkChannelOps(project *Project, visitor ChannelOpVisitor)\n```\n\n## Implementation notes\n- WalkCalls: Straightforward extraction from tree command\n- WalkChannelOps: Needs to handle two-pass logic for select statements (identify select cases first, then walk standalone ops)\n- Both should follow the WalkReferences pattern (visitor returns false to stop)\n\n## Benefits\n- Reusable traversal logic\n- Consistent API patterns across golang package\n- Commands become simpler (just visitor callbacks with command-specific logic)\n- Easier to test traversal logic in isolation","status":"closed","priority":3,"issue_type":"chore","created_at":"2026-01-22T03:45:07.093027084Z","updated_at":"2026-01-22T04:00:06.788660364Z","closed_at":"2026-01-22T04:00:06.788660364Z","dependencies":[{"issue_id":"wc-2a73","depends_on_id":"wc-029e","type":"related","created_at":"2026-01-22T03:45:12.82404353Z","created_by":"jason"}]}
{"id":"wc-2ad5","content_hash":"16be3beac0c3197ef3f1e2581bc1a3d116b018a8272c18cb80e545e08a1aa33e","title":"Surface packages.Load errors in command results","description":"Currently LoadModulePackages (internal/golang/pkgpath.go:173) loads all packages with LoadAllSyntax but never checks pkg.Errors or pkg.TypeErrors on the returned packages. These errors are silently discarded.\n\nEach packages.Package has:\n- Errors []packages.Error - errors from loading/parsing\n- TypeErrors []types.Error - errors from type-checking\n\nWe should:\n1. Collect these errors during loading\n2. Store them on the Project struct (or a new LoadResult type)\n3. Make them available to commands so they can include them in their structured output\n\nThis ties into wc-f06a (diagnostics channel) - these load errors are a prime example of non-fatal diagnostics that commands should surface. An AI needs to know 'I analyzed 47 packages but 3 had type errors' rather than silently getting incomplete results.\n\nAffected locations:\n- LoadModulePackages: line 173 packages.Load call ignores per-package errors\n- LoadStdlibPackages: line 134 doesn't check errors on returned packages\n- ResolvePackageName: line 72 only partially checks errors (looks for specific message)\n\nRelated: wc-f06a, wc-eef3","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T07:11:28.20464704Z","updated_at":"2026-01-23T08:26:01.207929283Z","closed_at":"2026-01-23T08:26:01.207929283Z","dependencies":[{"issue_id":"wc-2ad5","depends_on_id":"wc-f06a","type":"blocks","created_at":"2026-01-23T07:11:32.094058177Z","created_by":"jason"}]}
{"id":"wc-2b6e","content_hash":"ea2d8ccaca89d8a6e5a0fbe55071e318b5d57a13ec2abdc765b0712a221918b2","title":"Add project command for project-level analysis","description":"Add a 'project' command that provides project-level information, similar to the package command but scoped to the entire project.\n\n## Features\n- List all packages in the project\n- Show external dependencies imported into the project\n- Package size metrics (LOC, file count, etc.)\n- Import heatmap showing package usage patterns:\n  - Which internal packages are imported by many other packages (high connectivity)\n  - Which packages are only imported by one or few packages (low connectivity)\n  - Identify potential 'hub' packages vs leaf packages\n\n## Future considerations\n- Additional metrics TBD as needs arise","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-15T02:22:42.184259151Z","updated_at":"2026-01-26T07:14:02.420720908Z","closed_at":"2026-01-26T07:14:02.420720908Z","dependencies":[{"issue_id":"wc-2b6e","depends_on_id":"wc-0ca4","type":"related","created_at":"2026-01-17T09:05:13.990915741Z","created_by":"jason"}]}
{"id":"wc-2bbd","content_hash":"8eab9e70c9c0b71a0f668aff02a631393dd4913868703f6008c121437162aca5","title":"GOROOT() returns empty string on failure","description":"In stdlib.go:17-25, if 'go env GOROOT' command fails, GOROOT() returns empty string with no indication of failure.\n\nLocation: internal/golang/stdlib.go:17-25\n\nPattern:\n  out, err := exec.Command('go', 'env', 'GOROOT').Output()\n  if err == nil {\n    goroot = strings.TrimSpace(string(out))\n  }\n  // err is silently discarded\n\nImpact: Downstream code using GOROOT() doesn't know if Go isn't installed vs GOROOT is actually empty. LoadStdlibPackages (line 133-138) will fail mysteriously.\n\nOptions:\n- Return (string, error)\n- Panic on failure (critical dependency)\n- Cache the error and return on subsequent calls","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:52:14.549155832Z","updated_at":"2026-01-23T13:28:19.99853356Z","closed_at":"2026-01-23T13:28:19.99853356Z","dependencies":[{"issue_id":"wc-2bbd","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:52:14.566581439Z","created_by":"jason"}]}
{"id":"wc-2bdd","content_hash":"558e4eeca8b511a6d4a0ed206e957c355b87e0d5f3ee124e5195303d85b6cb09","title":"Filter or flag external interfaces in satisfies/implements output","description":"External interfaces from imported packages (e.g., from go/pkg/mod/) are appearing in satisfies and possibly implements command results.\n\n## Example\nInterfaces like `json.Marshaler` and `json.Unmarshaler` from external modules show up:\n```\n{\n  \"symbol\": \"Marshaler\",\n  \"file\": \"/home/jason/go/pkg/mod/github.com/go-json-experiment/json@v0.0.0.../arshal_methods.go\",\n  ...\n}\n```\n\n## Options to consider\n1. Filter out external interfaces entirely (only show project-local interfaces)\n2. Add a flag to include/exclude external interfaces (default exclude?)\n3. Group results by local vs external\n4. Keep current behavior but mark external interfaces differently\n\nNeed to decide on the right UX here.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-15T02:31:09.741128269Z","updated_at":"2026-01-15T13:47:33.301974355Z","closed_at":"2026-01-15T13:47:33.301974355Z"}
{"id":"wc-2cc9","content_hash":"8fd5d77478f2b1378fd89b92b0fd4f37dd4ec1d098ca300ad96aa72da90ab3ca","title":"WalkReferences silently returns when GetTypesObject fails","description":"In refs.go, WalkReferences() and WalkNonCallReferences() silently return early if GetTypesObject(sym) returns nil:\n\nLocations:\n- refs.go:29-32 (WalkReferences)\n- refs.go:262-265 (WalkNonCallReferences)\n\nImpact: Analysis silently doesn't happen. Callers (like CountReferences) return 0 which looks like 'no references' rather than 'couldn't analyze'.\n\nOptions:\n- Change Walk functions to return error\n- Add second return value indicating if analysis ran\n- Log/report when analysis couldn't proceed","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:51:53.947642896Z","updated_at":"2026-01-23T08:51:46.027634134Z","closed_at":"2026-01-23T08:51:46.027634134Z","dependencies":[{"issue_id":"wc-2cc9","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:51:53.964633503Z","created_by":"jason"}]}
{"id":"wc-2d0a","content_hash":"36a64837d2216e3c54068f23d278aecdedd97a5b80d308310a67f4bb31b5a6df","title":"Fix help text: default output is markdown not json","description":"User feedback: Help says (default \"json\") but actual default output is markdown.\n\nThe markdown output is excellent for AI consumption, so the behavior is correct.\nJust need to update help text to say (default \"markdown\") or similar.\n\nCheck all commands for consistent default output documentation.","status":"closed","priority":3,"issue_type":"bug","created_at":"2026-01-22T07:51:37.929716463Z","updated_at":"2026-01-22T08:16:24.806208513Z","closed_at":"2026-01-22T08:16:24.806208513Z"}
{"id":"wc-2d19","content_hash":"e39811ac0d8712876428551a075bdb530f6c93bd0c8a036b5e26700cf96f8c9f","title":"Elevate project to pre-production status","description":"Wildcat started as a hackathon project but is evolving into an important tool for AI-assisted development. Update project posture to reflect pre-production readiness.\n\n## Cleanup Tasks\n- [ ] Remove DEMO.md, DEMO-COMMANDS.md, MESSAGE.md from root\n- [ ] Remove eval/ folder (hackathon artifact)\n- [ ] Audit all command descriptions (--help text)\n- [ ] Audit readme command output\n- [ ] Audit README.md for accuracy\n- [ ] Audit CLAUDE.md for accuracy\n\n## Future Areas (separate tickets)\n\n### Documentation\n- Comprehensive README with installation, usage, examples\n- Architecture documentation\n- Contributing guidelines\n\n### Quality\n- Increase test coverage across packages\n- Add integration tests for all commands\n- CI/CD pipeline (GitHub Actions)\n- Linting and formatting enforcement\n\n### Reliability\n- Error handling audit\n- Timeout and cancellation handling\n- Graceful degradation for LSP failures\n\n### Distribution\n- Release automation\n- Binary releases for major platforms\n- Homebrew formula or similar","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-15T14:38:46.564895826Z","updated_at":"2026-01-15T15:10:30.510199155Z","closed_at":"2026-01-15T15:10:30.510199155Z"}
{"id":"wc-2d1a","content_hash":"9021567806acd14b8ce2986409716fa507cb575dff1f1332794493d6375a3961","title":"RenderSource should include trailing newline","description":"**Problem:**\n`golang.RenderSource` stops before the final newline, so rendered source doesn't end with a newline.\n\n**Impact:**\n- Concatenated source sections can run together\n- Output may look malformed when printed directly\n- Inconsistent with typical file/source conventions (files end with newline)\n\n**Fix:**\nEnsure rendered output includes the trailing newline of the last line.\n\n**Location:**\n`internal/golang/format.go:RenderSource`","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-28T13:52:14.967856253Z","updated_at":"2026-01-29T04:24:48.449658646Z","closed_at":"2026-01-29T04:24:48.449658646Z"}
{"id":"wc-2e2e","content_hash":"fe88d182f55f47dd7843c09a3d864b4855cb03629a35da9fbbccd97540e1c01c","title":"Rework refs.go to use golang.Symbol instead of raw AST","description":"The refs.go file builds symbol names directly from AST nodes:\n\n```go\n// refs.go:66, 259\ncontaining = pkg.Identifier.Name + \".\" + s.Name.Name\n\n// refs.go:72, 265  \ncontaining = pkg.Identifier.Name + \".\" + s.Names[0].Name\n\n// refs.go:79, 272\ncontaining = pkg.Identifier.Name + \".\" + name.Name\n\n// refs.go:420, 424\nsymbolName := pkg.Identifier.Name + \".\" + s.Name.Name\n```\n\n## Context\n\nThese patterns appear in:\n- `WalkReferences` - finding the \"containing\" symbol for a reference\n- `ComputeDescendants` - building symbol names for scope checking\n\n## Proposal\n\nLook up or reference golang.Symbol objects instead of building names from raw AST. This would:\n\n1. Enable use of Symbol helpers (PkgSymbol, etc.)\n2. Ensure consistent naming\n3. Provide access to Symbol metadata\n\n## Considerations\n\n- The \"containing\" logic walks up the AST to find enclosing declarations\n- May need a map from ast.Node to Symbol for efficient lookup\n- Performance impact of lookups during reference walking","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T02:25:05.815835681Z","updated_at":"2026-01-26T02:57:31.952254662Z","closed_at":"2026-01-26T02:57:31.952254662Z"}
{"id":"wc-2ed7","content_hash":"30afe824cde59eb5dfd2eb69755f0aa521ecced0d63011975715d4e06b0646b4","title":"Deadcode IsReachable assumes reachable on analysis failures","description":"In deadcode.go, IsReachable() returns true (reachable = not dead) when analysis data is missing or positions are invalid:\n\nLocations:\n- deadcode.go:139-141: 'if r == nil || r.Program == nil { return true }'\n- deadcode.go:145-147: 'if \\!pos.IsValid() { return true }'\n\nImpact: Analysis failures silently result in symbols being marked as 'not dead code'. AI thinks code is used when actually analysis couldn't determine.\n\nAlso related: lines 78-85 return empty result (not error) when no entry points found, which could mean 'library with no main' vs 'something went wrong'.\n\nOptions:\n- Return (reachable bool, analyzed bool)\n- Include analysis_incomplete flag in response\n- Error when analysis couldn't run vs empty results","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:52:08.038462341Z","updated_at":"2026-01-23T10:12:55.463257407Z","closed_at":"2026-01-23T10:12:55.463257407Z","dependencies":[{"issue_id":"wc-2ed7","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:52:08.055137725Z","created_by":"jason"}]}
{"id":"wc-2eea","content_hash":"f7099ed82f4bc583ed8d5fba112789cb06d614b6d6b894c593d5f5949bc83a48","title":"Support struct fields in symbol resolution","description":"Update symbol resolution to support `Type.Field` notation for struct fields, matching gopls behavior.\n\n**Current state:**\n- `golang.Symbol.String` works (method)\n- `golang.Symbol.Name` does not work (field)\n\n**gopls supports this:**\n```\n$ gopls workspace_symbol \"Symbol.Name\"\n/internal/golang/symbol.go:15:2-6 Symbol.Name Field\n```\n\n**Goal:**\nEnable `wildcat symbol golang.Symbol.Name` to resolve to the Name field of the Symbol struct.\n\n**Implementation considerations:**\n1. When resolving `pkg.Type.Member`, check if Member is a method first (current behavior)\n2. If not a method, check if Member is a field on the struct\n3. Return the field with appropriate metadata (type, position, etc.)\n\n**Impact on path syntax:**\nThis enables dot notation for all type members (fields and methods), simplifying the path syntax:\n- `golang.Symbol.Name` - field (dot notation)\n- `golang.Symbol[0]` - first field (positional)\n- `golang.Symbol/fields` category becomes optional\n\n**Related:** docs/path-syntax.md describes the path addressing system this enables.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-26T10:57:05.936236735Z","updated_at":"2026-01-27T04:04:11.217787485Z","closed_at":"2026-01-27T04:04:11.217787485Z"}
{"id":"wc-2f31","content_hash":"810b36892f06b588a51aa1ef6e4d16e1d1cc42f88f98e8c1afed7ce881f1cf61","title":"Audit and rationalize symbol naming patterns","description":"The codebase has inconsistent patterns for constructing symbol names from various fields:\n- `PackageIdentifier.Name + \".\" + sym.Name`\n- `PackageIdentifier.PkgPath + \".\" + sym.Name`\n- Various other combinations\n\nThe problem: `.Name` means different things in different contexts, `Filename` can mean full path, etc. It's hard to understand what a given expression will actually output.\n\n## Goals\n1. Audit all places where names are constructed from identifier/name combinations\n2. Document what each pattern actually produces (with examples)\n3. Identify helper methods that could standardize this\n4. Understand the semantic intent of each usage (display name vs lookup key vs unique ID)\n\n## Deliverable\nA summary of findings that maps patterns to their outputs and intended use cases.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T14:38:19.759478892Z","updated_at":"2026-01-26T03:24:55.705764058Z","closed_at":"2026-01-26T03:24:55.705764058Z"}
{"id":"wc-2f4f","content_hash":"8d616dde174e2131f2fc0affa6e050f627e708180b38eeb85c89195791ca9f69","title":"Deduplicate identical call paths in tree output","description":"Multiple calls from the same function to the same target produce identical paths (same package.Name sequence). Need to either dedupe paths or include distinguishing info (call site location). Currently paths array may contain duplicates that look identical but represent different actual call sites.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-15T03:12:42.142245269Z","updated_at":"2026-01-15T04:51:39.194200075Z","closed_at":"2026-01-15T04:51:39.194200075Z","dependencies":[{"issue_id":"wc-2f4f","depends_on_id":"wc-f890","type":"blocks","created_at":"2026-01-15T03:12:42.158870145Z","created_by":"jason"}]}
{"id":"wc-2fca","content_hash":"1774ac0f4edfb3c07c62aecab58903d56778545497f3f41009145b7d98898256","title":"Migrate tree command to Command[T] pattern","description":"Migrate tree command from gopls LSP to native implementation using Command[T] pattern.\n\n## Status: COMPLETE\n\nThe native tree command is implemented at `internal/commands/tree/` and registered as `new-tree` for parallel testing with the old LSP-based `tree` command.\n\n### Completed\n- [x] TreeCommand implements Command[T] interface\n- [x] No gopls/LSP dependency - uses native AST walking\n- [x] Functional options: WithSymbol(), WithUpDepth(), WithDownDepth(), WithScope()\n- [x] buildCalleesTree - walks function AST to find outgoing calls\n- [x] buildCallersTree - searches all packages for incoming calls  \n- [x] Callers tree inversion (shows call paths top-down)\n- [x] MarshalJSON and MarshalMarkdown output\n- [x] Definitions section grouping by package\n- [x] Summary with truncation indicators\n- [x] --scope all/project/package working (ScopePackage fixed)\n\n### Deferred\n- --include-tests flag: tracked in wc-8227, will be addressed after all commands migrated\n- README(): will be done in batch after all commands migrated\n\n### Next Steps\n- Test `new-tree` against `tree` to verify parity\n- Replace `tree` with `new-tree` when ready","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-20T13:09:37.458954698Z","updated_at":"2026-01-21T05:54:30.758366418Z","closed_at":"2026-01-21T05:54:30.758366418Z","dependencies":[{"issue_id":"wc-2fca","depends_on_id":"wc-fbec","type":"blocks","created_at":"2026-01-21T05:34:34.589601147Z","created_by":"jason"}]}
{"id":"wc-34fa","content_hash":"ac2058e5131c8a628dd23ddd7d2fd19edfc3283261d68bded27a14a2f8c2d15e","title":"Migrate command outputs from file paths to semantic paths","description":"Migrate all wildcat command outputs to use semantic paths (spaths) as the primary identifier instead of file:line locations.\n\n**Vision:**\nEvery piece of output that references code should be a copyable spath that can be fed directly into `read`, `ls`, or other commands. The filesystem becomes an implementation detail, not part of the workflow.\n\n**Commands affected:**\n- `symbol` - definition locations, caller/callee references\n- `tree` - call graph nodes\n- `package` - symbol listings\n- `search` - search results\n- `deadcode` - unreachable code references\n\n**Current state (file-centric):**\n```\nspath.parser.parse (/home/jason/go/src/.../parse.go:31)\n├── spath.parser.findPackageSymbolBoundary (/home/jason/go/src/.../parse.go:49)\n```\n\n**Target state (spath-centric):**\nSpaths as primary identifiers, file locations as optional context (format TBD).\n\n**Design considerations:**\n- Output format: inline, columns, JSON fields - needs UX iteration\n- Verbosity: always show vs. flag-controlled\n- Subpaths: when to show `Symbol/params[ctx]` vs just `Symbol`\n- Backward compatibility for scripts consuming current output\n\n**Goal:**\nOptimize for AI agent workflow - copy from output, paste into next command, never think about the filesystem.\n\n**Related:**\n- wc-8c03: doublestar path expansion (query power)\n- wc-7bb6, wc-ae41, wc-402c, wc-c687: read command enhancements","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-26T13:43:46.756896173Z","updated_at":"2026-01-27T14:32:03.976413394Z"}
{"id":"wc-389a","content_hash":"3d0c2b9b7aa5353eb7ea894c6d9396b3cda8fcdc01fba59fc10cea45f174038e","title":"Audit: use TypesInfo iteration instead of AST syntax where beneficial","description":"Pattern identified in findImplementations refactor: iterating `pkg.Package.TypesInfo.Defs` directly is cleaner than iterating AST syntax and looking up each node in TypesInfo.\n\nBenefits:\n- Flatter loop structure (no nested file → decl → spec loops)\n- No nil checks needed - we only see what has type info\n- Avoids silent skips on missing type info (the skip is implicit in the data)\n\nCandidates to audit:\n- symbol.go findConsumers - iterates AST looking for funcs with interface params\n- symbol.go findSatisfies - iterates AST looking for interfaces a type implements  \n- interfaces.go - multiple functions iterate AST for interface/type analysis\n- Other places iterating Syntax with TypesInfo lookups\n\nFor each candidate, evaluate:\n1. Does it iterate AST and lookup in TypesInfo?\n2. Would TypesInfo iteration be cleaner?\n3. What info would we lose (e.g., AST-based formatting)?\n\nRelated: findImplementations was refactored as proof of concept - cleaner code, same results (except signature format uses types.TypeString instead of AST formatting).","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-24T10:30:53.555413829Z","updated_at":"2026-01-24T11:15:03.98286067Z","closed_at":"2026-01-24T11:15:03.98286067Z"}
{"id":"wc-3c75","content_hash":"239e3fe36b9e6dd4fce34a9a492e6838fcf4c5dfab2e1f793b96491cafac9d07","title":"TypesInfo nil lookups silently skip symbols","description":"Multiple places check TypesInfo lookups for nil and silently skip/continue:\n\nLocations in symbol.go:\n- lines 520-527: targetObj nil check silently returns\n- lines 651-654: typeObj nil check continues\n- lines 783-785: paramType nil continues\n- lines 1071-1072: ifaceObj nil continues\n\nLocations in interfaces.go:\n- lines 48-49, 73-74: obj == nil continues\n- lines 123-124: tobj == nil continues\n\nImpact: Symbols that can't be resolved are silently omitted from results. AI doesn't know analysis was incomplete.\n\nOptions:\n- Track 'unresolvable' symbols in response\n- Log warnings for nil type info\n- Include count of skipped items in summary","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:53:02.16262465Z","updated_at":"2026-01-23T15:10:41.944634767Z","closed_at":"2026-01-23T15:10:41.944634767Z","dependencies":[{"issue_id":"wc-3c75","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:53:02.178945109Z","created_by":"jason"}]}
{"id":"wc-3cb0","content_hash":"d5f1d6912d2dcb711508070470f77800bee81eb7ef82030d6c5ffea9df0c8a77","title":"Bidirectional tree: --up and --down flags","description":"Replace --direction/--depth with --up N and --down N flags.\n\n**Current:**\n```\nwildcat tree Foo --direction up --depth 3\n```\n\n**Proposed:**\n```\nwildcat tree Foo --up 2 --down 2   # default: both directions\nwildcat tree Foo --up 0 --down 3   # callees only\nwildcat tree Foo --up 3 --down 0   # callers only\n```\n\n**Output structure:**\n- Target symbol is the central point\n- Callers flow DOWN into target (inverted tree)\n- Callees flow DOWN from target (normal tree)\n- Single continuous visualization\n\n**JSON:**\n```json\n{\n  \"tree\": {\n    \"symbol\": \"Foo\",\n    \"callers\": [{\"symbol\": \"Bar\", \"location\": \"...\", \"callers\": [...]}],\n    \"calls\": [{\"symbol\": \"Baz\", \"location\": \"...\", \"calls\": [...]}]\n  }\n}\n```\n\n**Markdown:**\n```\ncmd.runTree ────┐\ncmd.runSymbol ──┼─▶ cmd.GetWriter\ncmd.runSearch ──┘    └─▶ output.NewWriter\n                         └── ...\n```","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-17T16:28:16.627365349Z","updated_at":"2026-01-18T06:36:53.900582475Z","closed_at":"2026-01-18T06:36:53.900582475Z"}
{"id":"wc-3d05","content_hash":"ccf210aab8ef56e88fc8842d93824d26311b6f5d7cadb4fb2b9f19f29566cbb0","title":"Fix method symbol resolution - gopls returns Type.Method format","description":"User query `(*DB).GetTask` fails because:\n\n1. Parser extracts: Type='DB', Pointer=true, Name='GetTask'\n2. Resolver calls WorkspaceSymbol(ctx, 'GetTask')\n3. gopls returns Name='DB.GetTask' (not just 'GetTask')\n4. matchesQuery compares 'DB.GetTask' != 'GetTask' → FAIL\n\nKey finding: gopls workspace/symbol returns methods as 'Type.Method', not '(*Type).Method' (despite gopls symbols CLI using pointer syntax).","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-11T13:32:09.973076894Z","updated_at":"2026-01-11T14:03:14.192081198Z","closed_at":"2026-01-11T14:03:14.192081198Z","dependencies":[{"issue_id":"wc-3d05","depends_on_id":"wc-9808","type":"discovered-from","created_at":"2026-01-11T13:32:09.98889372Z","created_by":"jason"}]}
{"id":"wc-3f86","content_hash":"f33db18dfdd656d14c4f098ee901f8eb3eb23a4f49de193d54b4acb0d57bffa4","title":"Add wildcat rename command - atomic symbol renaming","description":"Atomic symbol renaming across the codebase.\n\n## Use Case\nThe symbol graph already exists - this command would handle all references in one operation.\n\n## CLI Design\n```\nwildcat rename \u003cold\u003e \u003cnew\u003e\n```\n\n## Implementation Notes\n- Leverage gopls rename capability (textDocument/rename)\n- Could also use go/packages + AST rewriting for native implementation\n- Must handle: function names, type names, method names, field names, variable names\n- Consider: --dry-run flag to preview changes\n- Consider: --scope flag to limit rename to package/project\n\n## Output\n- List of files modified\n- Count of references updated\n- Preview of changes (for dry-run)\n\n## Source\nUser testing session feedback - 2026-01-17","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-17T09:04:11.650514146Z","updated_at":"2026-01-27T03:27:32.477706615Z","closed_at":"2026-01-27T03:27:32.477706615Z"}
{"id":"wc-3fbc","content_hash":"c8c30e7c02ded8f7ccc35545679d79671d9a47804f5fe3347802d00d41156d7e","title":"Reimagine wildcat symbols command for AI use cases","description":"## Problem\nThe current symbols command passes queries directly to gopls fuzzy matching, but:\n- AIs typically want **substring matching** not fuzzy matching\n- AIs want to filter by **symbol kind** (functions, types, methods, etc.)\n- The documented ^prefix/$suffix/'exact syntax was never implemented by gopls\n\n## Proposed Changes\n\n### Query Model\nInstead of fuzzy matching, support:\n- Substring matching by default (case-insensitive)\n- Kind filtering: `--kind func` or `--kind type`\n- Combined: `wildcat symbols Task --kind func` → all functions containing 'Task'\n\n### Implementation Options\n1. **Client-side filtering**: Query gopls broadly, filter results ourselves\n2. **AST-based**: Use go/parser directly instead of gopls for more control\n3. **Hybrid**: Use gopls for discovery, filter client-side\n\n### Example Usage\n```bash\nwildcat symbols Task              # all symbols containing 'Task'\nwildcat symbols Task --kind func  # functions containing 'Task'\nwildcat symbols New --kind func   # constructors (NewFoo, NewBar...)\nwildcat symbols Error --kind type # error types\n```\n\n### Output\nKeep current output format but ensure results match the query semantics exactly.\n\n## Acceptance Criteria\n- [ ] Substring matching works reliably\n- [ ] --kind flag filters by symbol type\n- [ ] Documentation matches actual behavior\n- [ ] Remove misleading ^/$/' syntax from docs","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-14T06:45:01.265827169Z","updated_at":"2026-01-22T15:37:00.922973178Z","closed_at":"2026-01-22T15:37:00.922973178Z"}
{"id":"wc-402c","content_hash":"2876228de31acdc96170f931990dcff2e32f740bea2abe94812aa0fa167cdb7e","title":"read command: include navigable paths in response","description":"When reading source code, include semantic paths for symbols referenced in the code.\n\nExample: reading `spath.parser.parse` shows:\n```go\nfunc (p *parser) parse() (*Path, error) {\n    pkgEnd, symbolStart, err := p.findPackageSymbolBoundary()\n    ...\n    if err := p.parseSymbol(path); err != nil {\n    ...\n```\n\nThe response could include a \"references\" section:\n```\n# References\nspath.parser.findPackageSymbolBoundary\nspath.parser.parseSymbol\nspath.parser.parseSubpath\nspath.Path\n```\n\nThis enables easy follow-the-call-chain navigation without manually identifying what to read next.\n\nImplementation notes:\n- Walk the AST of the returned source\n- Resolve identifiers to their symbols\n- Generate semantic paths for each\n- Could be opt-in via flag if output gets noisy","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-27T14:25:00.088640474Z","updated_at":"2026-01-27T14:25:00.088640474Z"}
{"id":"wc-42df","content_hash":"b680ecc3f56e2cdca3a1e6fe32394badb9be3bc5f233516fac640f3ccf211272","title":"Merge channels command into package command","description":"Move channel operations analysis into the package command.\n\nCurrently channels is a separate command that analyzes channel operations in packages. This should be merged into the package command since it's fundamentally 'tell me about this package' like embeds, imports, etc.\n\nImplementation:\n- Add channel operations section to package output\n- Always show the section header with count (e.g., '# Channels (0)' or '# Channels (12 ops)')\n- Remove the standalone channels command\n- Move channel analysis code to be called from package command\n\nRelated: Also update Embeds section to always show header with count, not omit when empty.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-23T03:33:16.54912698Z","updated_at":"2026-01-23T03:59:28.854088962Z","closed_at":"2026-01-23T03:59:28.854088962Z"}
{"id":"wc-431c","content_hash":"f4ec6bb1cf037833685591faa7600ad6a3da5f24c9977c95e040ca618cc1ba58","title":"Generic interface implementation detection","description":"FindImplementors doesn't detect implementations of generic interfaces.\n\nExample: Command[T any] interface is implemented by SearchCommand, SymbolCommand, etc. via:\n  var _ commands.Command[*SearchCommand] = (*SearchCommand)(nil)\n\nBut wildcat symbol Command shows Implementations (0).\n\nRoot cause: types.Implements(T, iface) checks against the generic interface definition (Command[T any]) not instantiations. SearchCommand implements Command[*SearchCommand], not the generic form.\n\nFix approach:\n1. Detect if interface has type parameters (named.TypeParams().Len() \u003e 0)\n2. For generic interfaces, try instantiating with each candidate type\n3. Check if candidate implements the instantiated interface\n\nRelated Go issue: This is a known complexity with generics in go/types.\n\nLocation: internal/golang/interfaces.go:FindImplementors","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-23T08:17:35.954219775Z","updated_at":"2026-01-26T04:43:15.898187273Z","closed_at":"2026-01-26T04:43:15.898187273Z"}
{"id":"wc-4552","content_hash":"5aaa95febab85baefc8acb9cf44a8e260e9cab76df1570958c7ed3f23bac8ad6","title":"Add negation to package filtering (--scope)","description":"Allow excluding packages from scope filter using negation syntax.\n\nExamples:\n  --scope 'project,-internal/test'    # project packages except internal/test\n  --scope 'project,-*_test'           # project packages except test packages\n  --scope '-vendor'                   # all except vendor\n\nSyntax options to consider:\n  - Prefix: -pkg or !pkg\n  - Separate flag: --exclude pkg\n\nApplies to: search, symbol commands","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-16T11:38:20.262544147Z","updated_at":"2026-01-16T13:48:34.021646364Z","closed_at":"2026-01-16T13:48:34.021646364Z"}
{"id":"wc-46ba","content_hash":"c680343661e6d924eb2ef646b499d909c33070317cfe2e5df9a540002c3b239e","title":"Implement transitive dead code detection using RTA","description":"## Overview\n\nReplace the current `unused` command's simple reference counting with proper transitive dead code detection using Rapid Type Analysis (RTA). This will catch code that is only referenced by other dead code.\n\n## Problem\n\nThe current `unused` command counts direct references to symbols. This misses transitively dead code:\n\n```\nmain() -\u003e ... (doesn't use lsp.Client)\n\nlsp.Client (appears \"used\" because Resolver references it)\n  └── Resolver.client field references lsp.Client\n      └── But Resolver itself is never used from main!\n```\n\nResult: `lsp.Client` and all its methods appear as \"used\" even though nothing reachable from `main` uses them.\n\n## Solution\n\nUse SSA (Static Single Assignment) and RTA (Rapid Type Analysis) from `golang.org/x/tools`:\n\n1. **SSA Conversion**: Convert loaded packages to SSA form\n2. **Root Discovery**: Find entry points (main, init, Test*, Benchmark*)\n3. **RTA Analysis**: Compute all functions reachable from roots\n4. **Dead Code**: Anything not reachable is dead\n\n## Implementation Plan\n\n### 1. Add SSA/RTA to golang package\n\n```go\n// internal/golang/deadcode.go\n\ntype DeadCodeAnalysis struct {\n    Program     *ssa.Program\n    Reachable   map[*ssa.Function]bool\n    DeadFuncs   []*ssa.Function\n    DeadTypes   []*types.Named  // types with no reachable methods\n}\n\nfunc AnalyzeDeadCode(project *Project, includeTests bool) (*DeadCodeAnalysis, error) {\n    // 1. Convert packages to SSA\n    var pkgs []*packages.Package\n    for _, p := range project.Packages {\n        pkgs = append(pkgs, p.Package)\n    }\n    prog, ssaPkgs := ssautil.AllPackages(pkgs, ssa.InstantiateGenerics)\n    prog.Build()\n\n    // 2. Find roots\n    var roots []*ssa.Function\n    for _, pkg := range ssaPkgs {\n        if pkg == nil {\n            continue\n        }\n        // main and init\n        if fn := pkg.Func(\"main\"); fn != nil {\n            roots = append(roots, fn)\n        }\n        if fn := pkg.Func(\"init\"); fn != nil {\n            roots = append(roots, fn)\n        }\n        // Test functions if includeTests\n        if includeTests {\n            for _, mem := range pkg.Members {\n                if fn, ok := mem.(*ssa.Function); ok {\n                    if strings.HasPrefix(fn.Name(), \"Test\") ||\n                       strings.HasPrefix(fn.Name(), \"Benchmark\") ||\n                       strings.HasPrefix(fn.Name(), \"Example\") {\n                        roots = append(roots, fn)\n                    }\n                }\n            }\n        }\n    }\n\n    // 3. Run RTA\n    result := rta.Analyze(roots, false)\n\n    // 4. Find dead functions\n    // ...\n}\n```\n\n### 2. Rename command: unused -\u003e deadcode\n\n- Rename `internal/commands/unused/` to `internal/commands/deadcode/`\n- Update command name and help text\n- Keep existing output format (types, methods, functions grouped)\n\n### 3. Map SSA back to Symbols\n\nSSA functions need to be mapped back to our Symbol types for consistent output:\n\n```go\nfunc (a *DeadCodeAnalysis) IsReachable(sym *Symbol) bool {\n    // Map symbol to SSA function\n    // Check if in reachable set\n}\n```\n\n### 4. Handle edge cases\n\n- **Exported API**: Flag to include/exclude exported symbols (may have external callers)\n- **Reflection**: Exported methods may be called via reflect\n- **CGo**: Functions called from C code\n- **Build tags**: Different code may be active\n\n## Dependencies\n\nAlready available in go.mod:\n- `golang.org/x/tools/go/ssa`\n- `golang.org/x/tools/go/ssa/ssautil`\n- `golang.org/x/tools/go/callgraph/rta`\n\n## Testing\n\n1. Create test fixture with transitively dead code\n2. Verify lsp.Client is detected as dead\n3. Verify main/init/Test* are never marked dead\n4. Compare output with `golang.org/x/tools/cmd/deadcode`\n\n## Output Format\n\nKeep current markdown/JSON format but add reachability info:\n\n```markdown\n## Dead Code\n\n### Types (3)\n\n#### lsp.Client\n`type Client struct {...}`\n/path/to/client.go:13:21\n\n**Constructors (1):**\n- NewClient `func NewClient(...) (*Client, error)`\n\n**Methods (14):**\n- Shutdown `func (c *Client) Shutdown(...) error`\n- Close `func (c *Client) Close() error`\n...\n```\n\n## References\n\n- golang.org/x/tools/cmd/deadcode source\n- RTA paper: \"Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis\"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-21T12:54:36.304440532Z","updated_at":"2026-01-21T13:23:18.212427479Z","closed_at":"2026-01-21T13:23:18.212427479Z"}
{"id":"wc-475e","content_hash":"b63fcdf60b5481b706e9a454c1ab8de85118c77fab2587ee2a7eb57bfe02b1b7","title":"Feature: Search for symbol usage patterns","description":"When exploring code, we often need to find where symbols are used. Currently using grep, but Wildcat could provide: 1) Find all usages of a pattern (like grep but symbol-aware) 2) Search for method calls matching a pattern 3) Find all implementations of methods with certain signatures. Discovered while using grep to find OpenWorkspaceFiles calls in cmd/*.go","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-11T03:19:23.921384361Z","updated_at":"2026-01-14T07:33:41.335998908Z","closed_at":"2026-01-14T07:33:41.335998908Z"}
{"id":"wc-4773","content_hash":"de6eda4fe09e9aab87e8d6468d110bdea9de5eef0ce625ef6fd5e9482eddac19","title":"ExtractSmart snippet errors silently discarded","description":"In symbol.go, ExtractSmart errors are discarded when extracting snippets:\n\nLocations:\n- symbol.go:323: 'snippet, start, end, _ := extractor.ExtractSmart(...)'\n- symbol.go:341: same pattern for reference snippets\n\nImpact: If snippet extraction fails (file not found, read error, etc.), AI sees empty snippet without knowing why.\n\nOptions:\n- Include error in Snippet struct\n- Return Snippet with error field populated\n- Skip location entirely but track in summary","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:53:14.56114403Z","updated_at":"2026-01-26T04:39:57.104407981Z","closed_at":"2026-01-26T04:39:57.104407981Z","dependencies":[{"issue_id":"wc-4773","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:53:14.576901804Z","created_by":"jason"}]}
{"id":"wc-48e9","content_hash":"af8b4b1501a54d3bece7f1b602069dddcfa7fa1ff5a0876e5f66407f2f4cb85f","title":"Restructure symbol output around package organization","description":"## Summary\n\nReorganize symbol command output to be package-centric rather than flat lists.\n\n## Current Structure\n\n```json\n{\n  \"usage\": {\n    \"callers\": [\n      {\"file\": \"/full/path/to/pkg/a.go\", \"line\": 10, ...},\n      {\"file\": \"/full/path/to/other/b.go\", \"line\": 20, ...}\n    ],\n    \"references\": [...]\n  }\n}\n```\n\n## Proposed Structure\n\n```json\n{\n  \"query\": {\n    \"command\": \"symbol\",\n    \"target\": \"lsp.Client\",\n    \"scope\": \"package\"\n  },\n  \"target\": {...},\n  \"imported_by\": [\"cmd\", \"internal/traverse\", \"internal/symbols\"],\n  \"packages\": {\n    \"github.com/foo/internal/lsp\": {\n      \"callers\": [{\"file\": \"client.go\", \"line\": 10, ...}],\n      \"references\": [...]\n    },\n    \"github.com/foo/cmd\": {\n      \"callers\": [{\"file\": \"symbol.go\", \"line\": 42, ...}],\n      \"references\": [...]\n    }\n  },\n  \"query_summary\": {...},\n  \"package_summary\": {...},\n  \"project_summary\": {...}\n}\n```\n\n## Benefits\n\n1. **Package path stated once** - not repeated in every reference\n2. **Shorter file paths** - just filename within package context\n3. **Natural grouping** - understand usage by package\n4. **Progressive discovery** - `imported_by` shows breadcrumbs for further exploration\n5. **Context efficiency** - scope controls which packages appear in results\n\n## imported_by\n\nLists packages that import the symbol's package. Enables progressive discovery:\n- Query at package scope → see focused results\n- See `imported_by` list → know what else is out there\n- Query again with specific packages to explore further\n- AI controls context spend\n\nLike `other_fuzzy_matches` - breadcrumbs without committing context.\n\n## Summaries\n\nAlways present:\n- `query_summary` - stats for the requested scope\n- `package_summary` - symbol's defining package (fixed anchor)\n- `project_summary` - full project (fixed anchor)\n","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-16T07:53:10.717182526Z","updated_at":"2026-01-16T08:09:50.181271328Z","closed_at":"2026-01-16T08:09:50.181271328Z"}
{"id":"wc-4967","content_hash":"e93f77888a34a79d8b9dcf7e4860c671d46195af26e682087ebcb50f0830d70a","title":"deadcode: false positives for cobra patterns and interface types","description":"The deadcode command reports false positives for several patterns:\n\n1. Package-level vars used in cobra setup (readmeCmd, versionCmd, usageTemplate)\n2. Flag-bound variables read later (readmeCompact)\n3. Interface types (Command[T], Result) \n4. Types used only through JSON marshaling (output.QueryInfo, etc.)\n\nRoot cause: SSA analysis doesn't trace usage through:\n- cobra.AddCommand() calls\n- flag.StringVarP() bindings\n- Interface satisfaction\n- reflect-based JSON marshaling\n\nImpact: AI users will waste time investigating false positives, reducing trust in the tool.\n\nSuggested fixes:\n- Whitelist cobra patterns (vars passed to AddCommand, flag bindings)\n- Track interface implementations as 'used' when interface is used\n- Consider exported types in exported packages as potentially used","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-22T13:44:40.0877616Z","updated_at":"2026-01-22T15:13:55.310877024Z","closed_at":"2026-01-22T15:13:55.310877024Z","dependencies":[{"issue_id":"wc-4967","depends_on_id":"wc-632d","type":"related","created_at":"2026-01-22T14:01:11.972598775Z","created_by":"jason"}]}
{"id":"wc-4b81","content_hash":"8d47be8e1f36ed6a5a7f4e4c2819ab7f04f0d3bbd705df6ab61eabab1e48c797","title":"Add --location flag to annotate symbols with file paths and line numbers","description":"**Goal:**\nAdd a consistent `--location` (or `-l`) flag across all commands to opt-in to file path + line number annotations on symbols.\n\n**Current state:**\nSeveral commands include full definition locations by default:\n```\nfunc WalkReferences(...) // refs.go:28:38\n```\n\n**Desired state:**\n- Default: no location annotations (cleaner output)\n- With `--location`: include `file.go:start:end` or `file.go:line` for single-line definitions\n\n**Format:**\n```\n# Without --location (default)\nfunc WalkReferences(pkgs []*Package, sym *Symbol, visitor RefVisitor)\n\n# With --location\nfunc WalkReferences(pkgs []*Package, sym *Symbol, visitor RefVisitor) // /full/path/refs.go:28:38\n```\n\n**Commands affected:**\n- package\n- symbol\n- search\n- tree\n- ls\n- (any others showing definition locations)\n\n**Implementation:**\n- Add flag to root command or each subcommand\n- Pass through to response formatting\n- Update markdown rendering to conditionally include locations","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-28T13:48:47.692859181Z","updated_at":"2026-01-28T13:48:47.692859181Z"}
{"id":"wc-4bd0","content_hash":"8fd7570b9d558558dea0350e453cf578c4af789abdbfa9c455edc98a999b6278","title":"Evaluate replacing doublestar with custom regex pattern matching","description":"We implemented custom regex-based pattern matching for spath globbing in spathglob.go. This approach:\n- Converts `*` and `**` wildcards to regex patterns\n- Uses stdlib regexp (no external deps)\n- Handles spath-specific segment boundaries\n\nCurrently doublestar is still used in scope.go for package filtering (ScopeFilter).\n\n**Evaluate:**\n1. Should we replace doublestar usage in scope.go with our approach?\n2. Are there semantic differences that matter?\n   - doublestar: `*` matches within path segments (between `/`)\n   - our approach: `*` matches within spath segments (between `. / [ ]`)\n3. Would unifying on one pattern matching approach reduce complexity?\n\n**Current doublestar usage:**\n- `internal/commands/scope.go`: `matchPattern()` for package path filtering\n\n**Consideration:**\nPackage paths only use `/` as separators, so doublestar's semantics may be more appropriate there. But having two pattern matching systems adds cognitive load.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-28T05:19:44.470741261Z","updated_at":"2026-01-28T05:19:44.470741261Z"}
{"id":"wc-4d61","content_hash":"cb78b8ade3448c0ddf91765081aeb745df19c1d97a82b6bfca621187328f3d8d","title":"Research optimal CLI output formats for call trees and code graphs - AI-consumable","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:16:43.957523257Z","updated_at":"2026-01-10T03:35:12.719590076Z","closed_at":"2026-01-10T03:35:12.719590076Z"}
{"id":"wc-4fe1","content_hash":"28a4740f866bc7dc350780ff152c2112707ffc2090196f88eba0f5f51969d24c","title":"Replace LSP init sleep with readiness polling","description":"## Problem\nThe 200ms sleep after LSP initialization is a hack. On slower machines or larger projects, this may not be enough. On fast machines, it's wasted time.\n\n## Current Code\n```go\ntime.Sleep(200 * time.Millisecond)\n```\nPresent in: callers.go, callees.go, refs.go, tree.go, impact.go\n\n## Proposed Solution\n1. Poll for LSP readiness instead of sleeping\n2. Options:\n   - Send a lightweight request (like `initialized` notification)\n   - Wait for `window/workDoneProgress` completion\n   - Use exponential backoff with a test query\n3. Add configurable timeout (default 30s)\n\n## Acceptance Criteria\n- [ ] Remove hardcoded 200ms sleep\n- [ ] LSP readiness detected reliably\n- [ ] Works on slow and fast machines\n- [ ] Graceful timeout with clear error message","status":"closed","priority":3,"issue_type":"bug","created_at":"2026-01-10T05:58:58.671490419Z","updated_at":"2026-01-15T14:41:13.025755111Z","closed_at":"2026-01-15T14:41:13.025755111Z"}
{"id":"wc-5182","content_hash":"0ee51bb27dbe7e70c5501b53ad126dd5514c883e9d4a0cc38b176a5f478a0bb3","title":"Audit: package command - Package facility usage","description":"Audit the package command for appropriate use of Package facilities:\n\n**Facilities to consider:**\n- `Types.Scope()` - package-level declarations, already type-resolved\n- `TypesInfo.Defs/Uses` - AST ident → object mappings\n- `Syntax` (AST) - needed for formatting, file association\n\n**Questions to answer:**\n1. Where do we iterate AST when Scope() would be cleaner?\n2. Where do we lookup in TypesInfo with nil checks that could be avoided?\n3. Is AST formatting needed, or could types.TypeString suffice?\n4. Are we using the right facility for each task?\n\n**Current state:** package command iterates AST for symbol collection. This may be appropriate since it needs file association and AST formatting. Verify this is the right choice.\n\nPart of broader Package facility audit. Supersedes wc-389a.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-24T11:14:34.674272519Z","updated_at":"2026-01-25T07:26:41.329591967Z","closed_at":"2026-01-25T07:26:41.329591967Z"}
{"id":"wc-52b5","content_hash":"e023d46c057fe89600ab33f101a7094c350f148cfb9c7eb3bb340e87924ebf89","title":"findCallers silently returns when targetObj is nil","description":"In symbol.go:504-507, findCallers silently returns when TypesInfo.Defs lookup fails:\n\n```go\ntargetObj := target.Package.Package.TypesInfo.Defs[funcDecl.Name]\nif targetObj == nil {\n    return\n}\n```\n\nImpact: AI sees no callers but doesn't know if there truly are none or if analysis couldn't proceed.\n\nFix: Add diagnostic to wc.Diagnostics explaining callers analysis couldn't proceed due to missing type info.\n\nSplit from wc-3c75.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T15:09:52.962541501Z","updated_at":"2026-01-24T01:27:24.773373516Z","closed_at":"2026-01-24T01:27:24.773373516Z"}
{"id":"wc-53f5","content_hash":"0340b0d35249b2982fb9d3a47da91c3d0032f2ee6af1ddeb65d7752defa7cd8e","title":"Impact: add descendants (outgoing type dependencies)","description":"## Problem\nWhen removing a symbol, some of its dependencies may become dead code - they existed only to serve the removed symbol.\n\n## Example\n```go\ntype Task struct { ID TaskID }  // Task uses TaskID\ntype TaskID string              // TaskID only used by Task\n```\n\nIf you remove `Task`, then `TaskID` is now orphaned - it has zero references.\n\n## Proposed Behavior\n`wildcat impact model.Task` would include:\n\n```json\n{\n  \"impact\": { ... },\n  \"orphaned_if_removed\": [\n    {\n      \"symbol\": \"TaskID\",\n      \"kind\": \"type\",\n      \"location\": \"model/task_id.go:5\",\n      \"reason\": \"only referenced by model.Task\"\n    }\n  ]\n}\n```\n\n## Algorithm\n1. Get all symbols referenced BY the target (outgoing deps)\n2. For each, count total references in codebase\n3. If reference count == 1 (only the target), it's orphaned\n\n## Implementation Notes\n- Need outgoing dependencies (what the target uses) - requires go/types or AST\n- Need reference counting per symbol - gopls references\n- May want to show \"would become orphaned\" vs \"already orphaned\"\n\n## Acceptance Criteria\n- [ ] Impact output includes `orphaned_if_removed` list\n- [ ] Each orphan shows symbol, kind, location, reason\n- [ ] Only shows symbols that would have zero refs after removal","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-14T01:42:25.469224612Z","updated_at":"2026-01-21T16:00:41.348493992Z","closed_at":"2026-01-21T16:00:41.348493992Z"}
{"id":"wc-55a6","content_hash":"938619b27a7551e3c97da26238601a595bef682c97b4ed3f34a9862a080c55c2","title":"ls output has inconsistent path formats for fields vs methods","description":"When listing a type's children, fields use short package form but methods use full import path:\n\n```\ncommands.Wildcat/fields[Project]  // field (short form)\ngithub.com/jasonmoo/wildcat/internal/commands.Wildcat.ParseScope  // method (full path)\n```\n\nThis inconsistency makes it harder to copy-paste paths. All paths should use the same format - preferably the short form for readability, with full paths available via a flag or in JSON output.\n\nThe issue is that field paths are built with basePath.WithSegment() which preserves the input format, while method paths come from spath.Generate() which always uses full import path.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-27T07:37:54.720625994Z","updated_at":"2026-01-27T07:39:27.155800016Z","closed_at":"2026-01-27T07:39:27.155800016Z"}
{"id":"wc-5796","content_hash":"44727f698d6bb77550874e0b73898ae056ae417d58f329d0f8280a30f8563aeb","title":"Unify --scope help text across commands","description":"The --scope flag should have consistent documentation across all commands that use it.\n\nCore narrative:\n- Scope filters OUTPUT, not analysis\n- Full project is always analyzed/searched\n- Scope controls which packages appear in results\n\nCommands to update:\n- search: already correct semantics, verify help text\n- symbol: needs semantic fix (wc-ba2f) + help text\n- deadcode: just updated, verify help text\n- tree: future (wc-e896)\n\nHelp text template:\n  --scope  Filter results to packages matching pattern (default: project)\n  \n  Patterns:\n    project         - All project packages (default)\n    internal/...    - Package and subpackages\n    pkg1,pkg2       - Multiple packages\n    -pkg            - Exclude package\n\nEnsure examples show filtering behavior, not analysis boundary behavior.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-23T04:29:44.331146694Z","updated_at":"2026-01-23T04:59:54.877012736Z","closed_at":"2026-01-23T04:59:54.877012736Z","dependencies":[{"issue_id":"wc-5796","depends_on_id":"wc-ba2f","type":"related","created_at":"2026-01-23T04:29:57.673484192Z","created_by":"jason"},{"issue_id":"wc-5796","depends_on_id":"wc-e896","type":"related","created_at":"2026-01-23T04:29:57.728901771Z","created_by":"jason"}]}
{"id":"wc-5a85","content_hash":"8f7107501527486b2ed9a7704c7e1c8586c08c09ed6f54d80e931c35f994ea7c","title":"ls: floating struct comments incorrectly reported as type /doc","description":"**Problem:**\nFree-floating comments inside structs (section dividers like `// crud`, `// s3 crud`) are being reported as type-level `/doc` entries and appearing in wrong positions in ls output.\n\n**Example source:**\n```go\ntype DB struct {\n    db *sql.DB\n    \n    // crud\n    Users orm.CrudOperator[model.ExportedUser]\n    ...\n    \n    // s3 crud\n    Content orm.S3CrudOperator[model.ExportedContent]\n    ...\n}\n```\n\n**Current ls output:**\n```\ndatabase.DB/fields[Users]  // ...\ndatabase.DB/doc  // 1 line    \u003c-- appears AFTER Users, should be before or not at all\n```\n\n**Issues:**\n1. These aren't proper godoc comments (not attached to type or fields)\n2. They appear after the fields they precede in source\n3. They're reported as type-level `/doc` rather than field-level\n\n**Expected behavior:**\nEither:\n- Don't report free-floating struct comments at all (they're not addressable godoc)\n- Or report them with correct ordering and clear classification\n\n**Root cause:**\nLikely in spath enumeration - need to distinguish between:\n- `ast.Field.Doc` (proper field doc)\n- `ast.Field.Comment` (trailing comment)\n- Unattached comments in struct body (section dividers)","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-28T13:42:52.40313432Z","updated_at":"2026-01-28T13:42:52.40313432Z"}
{"id":"wc-5cc2","content_hash":"089559310a91ed55ed8c0123700dd7f9844125c74915f2eb068f50228ca0b3dc","title":"Feature: Find files containing specific code patterns","description":"When modifying code across multiple files, we need to find which files contain certain patterns. Current approach uses grep, but Wildcat could provide: 1) Find files containing calls to a specific function 2) Find files that reference a type 3) Find files that need the same change (like adding OpenWorkspaceIfNeeded). Discovered while grepping for 'time.Sleep(200' across cmd/*.go to find files needing updates.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-11T03:21:50.06082755Z","updated_at":"2026-01-14T07:33:41.333115504Z","closed_at":"2026-01-14T07:33:41.333115504Z"}
{"id":"wc-5cdf","content_hash":"b780b74809213bc695a695d51f36b80e3b6ce6f671bf7e75db6c3a30953cab09","title":"Reference finding AST visitors skip unresolvable identifiers","description":"In refs.go, AST visitors for finding references check TypesInfo.Uses[ident] == nil and skip.\n\nLocations (refs.go):\n- Line 119-121: walkNodeRefs\n- Line 335-337: walkPackageNonCallRefs  \n- Line 526-528: collectTypeReferences\n- Line 560-562: collectTypeReferrers\n\nAnalysis: obj == nil isn't necessarily a failure - the ident could be:\n1. A definition (in Defs, not Uses) - expected\n2. A builtin (true, nil, error) - expected\n3. Truly unresolved - actual issue\n\nOnly case 3 is a real problem. Could distinguish by checking both Defs and Uses.\n\nLow priority - the nil case is mostly expected behavior, not silent failures.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T15:10:05.427699849Z","updated_at":"2026-01-26T04:53:10.710529433Z","closed_at":"2026-01-26T04:53:10.710529433Z","dependencies":[{"issue_id":"wc-5cdf","depends_on_id":"wc-e649","type":"blocks","created_at":"2026-01-24T11:16:15.759612439Z","created_by":"jason"}]}
{"id":"wc-5d99","content_hash":"8a52d1bcdb676b9588d75b9deb5e6eb7080a977e0f8f030d97b8e23465bab7ed","title":"Audit code for Symbol improvements","description":"Now that golang.Symbol has rich precomputed data, audit the codebase for patterns that can be simplified or improved.\n\n## Precomputed fields on Symbol\n- Kind (SymbolKind) - eliminates need for type switches on Object\n- Methods, Constructors - precomputed, no need to walk AST\n- Satisfies, ImplementedBy - interface relationships precomputed\n- Consumers - functions that accept interface as param\n- Descendants - struct embedding hierarchy\n- PackageIdentifier - package metadata readily available\n\n## Audit targets\n\n### 1. Type switches → Kind field\nReplace patterns like:\n```go\nif _, ok := sym.Object.(*types.TypeName); ok { ... }\n```\nWith:\n```go\nif sym.Kind == SymbolKindType { ... }\n```\n\nFiles to check (from original plan):\n- interfaces.go\n- refs.go\n- calls.go\n- symbol.go\n\n### 2. Redundant calculations\nLook for code that recalculates what's already precomputed:\n- Finding implementors when ImplementedBy exists\n- Finding satisfied interfaces when Satisfies exists\n- Walking for methods when Methods exists\n- Walking for constructors when Constructors exists\n- Computing consumers when Consumers exists\n\n### 3. General patterns\n- Direct Object access vs helper functions\n- Simplify position/location lookups using Symbol fields\n- Remove any stale helpers that are no longer needed\n\n## Approach\nGrep for patterns, review each occurrence, simplify where appropriate.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T14:19:46.121550748Z","updated_at":"2026-01-25T14:27:34.986542933Z","closed_at":"2026-01-25T14:27:34.986542933Z"}
{"id":"wc-5e14","content_hash":"309476f76e46341d232dff1445996f770b664c4bbc2bca85bd7179d20cd58c60","title":"ls/read: add fuzzy match suggestions on path not found","description":"When ls or read commands can't resolve a path, provide fuzzy match suggestions like other wildcat commands do.\n\nCurrently `wildcat ls nonexistent` returns an error without suggestions. Other commands use `commands.Wildcat.Suggestions()` to provide helpful alternatives.\n\nImplementation:\n- ls command already has `notFoundError` that adds suggestions - verify it's working\n- read command needs similar treatment\n- Suggestions should include both symbols and package paths","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-27T12:42:19.721672642Z","updated_at":"2026-01-27T14:13:18.892091191Z","closed_at":"2026-01-27T14:13:18.892091191Z"}
{"id":"wc-60c4","content_hash":"953b238093e6d9ec384982d9fc51568e8cf174001c63259e7197e55e9cce7176","title":"Add definition block to symbol command output","description":"Add a top-level 'definition' field to symbol command output that contains the full source code of the symbol being queried. Makes it easy to jq select just the definition without extra calls.\n\nExample:\n```json\n{\n  \"query\": {...},\n  \"target\": {...},\n  \"definition\": {\n    \"location\": \"/path/to/file.go:10:25\",\n    \"source\": \"func Foo() error {\\n  ...\\n}\"\n  },\n  \"packages\": [...]\n}\n```\n\nUse case: `wildcat symbol Foo | jq -r '.definition.source'`","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-17T14:32:33.81409384Z","updated_at":"2026-01-18T07:27:58.975368254Z","closed_at":"2026-01-18T07:27:58.975368254Z"}
{"id":"wc-60f0","content_hash":"3c3a4957828ceff1950b60fddcc6cb894ee0b842d57c60a390894f0d9396a4fb","title":"Design import representation and editing in spath system","description":"**Goal:**\nEnsure imports are properly represented in the spath system and can be read/edited.\n\n**Questions to resolve:**\n\n1. **Path syntax for imports:**\n   - `pkg/imports` - list all imports?\n   - `pkg/imports[\"fmt\"]` - specific import by path?\n   - `pkg/imports[0]` - positional access?\n   - How to handle aliased imports: `import foo \"github.com/bar/foo\"`?\n\n2. **Per-file vs per-package:**\n   - Go imports are per-file, not per-package\n   - Should paths be `pkg/file.go/imports` or `pkg/imports`?\n   - How to handle the same import in multiple files?\n\n3. **Editing use cases:**\n   - Add an import: `wildcat edit pkg/imports --add \"fmt\"`\n   - Remove an import: `wildcat edit pkg/imports --remove \"fmt\"`\n   - Rename alias: change `import foo \"pkg\"` to `import bar \"pkg\"`\n   - goimports-style auto-management?\n\n4. **Read use cases:**\n   - `wildcat read pkg/imports` - show all imports for orientation\n   - `wildcat ls pkg/imports` - list import paths\n\n**Current state:**\n- `package` command shows imports in output\n- `golang.Package.Imports` tracks imports per file\n- No spath support for addressing imports\n\n**Related:**\n- wc-b416 (/doc path)\n- wc-142a (/tag path)\n- docs/path-syntax-draft-v1.md","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-29T04:06:56.450137794Z","updated_at":"2026-01-29T04:06:56.450137794Z"}
{"id":"wc-60f7","content_hash":"ef80fec3771657f7bbb06c769c78b2717467772ee2c5a76a3de2be347fe397c0","title":"ParseKinds silently ignores invalid kind strings","description":"In search.go:51, ParseKinds() explicitly documents 'Unknown kinds are silently ignored.' When user passes --kind 'func,typo,var', they get ['func','var'] back without knowing 'typo' was invalid.\n\nLocation: internal/golang/search.go:51-62\n\nImpact: AI passes invalid filter and doesn't know results are incomplete.\n\nOptions:\n- Return ([]SymbolKind, []string) with unrecognized kinds\n- Return error on invalid kinds\n- Include warnings in command response","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:51:41.643107052Z","updated_at":"2026-01-23T10:59:53.622437168Z","closed_at":"2026-01-23T10:59:53.622437168Z","dependencies":[{"issue_id":"wc-60f7","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:51:41.659614738Z","created_by":"jason"}]}
{"id":"wc-61be","content_hash":"30ed9188d3275d4ff9f2d173f7003a68b4acad82852f0e6ad1bc48c63f20b8cc","title":"Impact command: delete safety assessment","description":"Enhance impact command to answer: 'What breaks if I delete this?'\n\n## Current State\nwc-af7d.10 implemented basic impact analysis with callers, references, implementations, dependents.\n\n## Enhancement\nStructured assessment specifically for deletion safety:\n\n```json\n{\n  \"delete_assessment\": {\n    \"safe_to_delete\": false,\n    \"blocking_references\": [\n      {\"type\": \"direct_caller\", \"count\": 5, \"locations\": [...]},\n      {\"type\": \"exported_reference\", \"count\": 2, \"locations\": [...]}\n    ],\n    \"non_blocking\": [\n      {\"type\": \"test_only\", \"count\": 3, \"locations\": [...]}\n    ]\n  }\n}\n```\n\n## Categories to Assess\n- **Direct callers** vs **transitive callers** - immediate vs downstream impact\n- **Exported references** vs **unexported** - public API impact\n- **Test-only references** - these don't block deletion\n- Clear verdict: safe to delete / these things break\n\n## CLI Design\n```\nwildcat impact \u003csymbol\u003e --assess-delete\n```\nOr potentially a separate subcommand/flag.\n\n## Source\nUser testing session feedback - 2026-01-17","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-17T09:04:11.789925019Z","updated_at":"2026-01-22T02:22:15.045082299Z","closed_at":"2026-01-22T02:22:15.045082299Z"}
{"id":"wc-62b1","content_hash":"da172ebcdc973e211ad0e4fc9a3c4271abcf241ac6f8bf1d0a962d04bac7515b","title":"Support multiple symbol queries","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T08:46:58.529505527Z","updated_at":"2026-01-14T07:50:13.838166889Z","closed_at":"2026-01-14T07:50:13.838166889Z"}
{"id":"wc-62df","content_hash":"7da8ffd3cc89589b007f649b2ef6fce735ba01339906525f2a8125a5f7b0fb95","title":"Remove unused types: Result, Summary, MergeOverlappingResults","description":"Dead code identified during output/types.go audit:\n- Result type (lines 23-36)\n- Summary type (lines 38-44)  \n- MergeOverlappingResults and related helpers in snippet.go","status":"closed","priority":3,"issue_type":"chore","created_at":"2026-01-16T08:39:29.56584299Z","updated_at":"2026-01-17T08:16:51.392316752Z","closed_at":"2026-01-17T08:16:51.392316752Z","dependencies":[{"issue_id":"wc-62df","depends_on_id":"wc-8842","type":"related","created_at":"2026-01-16T08:42:27.55693045Z","created_by":"jason"}]}
{"id":"wc-62e9","content_hash":"471e544ee3df6977cb83d3c6b9f273c5cf080367f3bed7ba24f602475a262f37","title":"Add --scope flag to deadcode command","description":"Replace positional package arguments with --scope flag for consistency with symbol/search commands.\n\nCurrent: wildcat deadcode internal/lsp internal/errors\nNew: wildcat deadcode --scope 'internal/...'\n\nBenefits:\n- Supports patterns: internal/..., internal/*, **/util\n- Supports exclusions: project,-internal/testdata/...\n- Consistent with symbol and search commands\n- Default to 'project' scope\n\nImplementation:\n- Remove positional args handling\n- Add --scope flag with ParseScope\n- Update help text with pattern syntax documentation","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-23T03:33:23.757024548Z","updated_at":"2026-01-23T04:28:48.325330509Z","closed_at":"2026-01-23T04:28:48.325330509Z"}
{"id":"wc-632d","content_hash":"d92a47fa42546651b97a28e25976f829455a56bc914fe0b083365ad044f0de31","title":"deadcode: add non-call reference counting to reduce false positives","description":"## Problem\n\nThe deadcode command uses SSA reachability which misses functions that are used but called externally (e.g., cobra command handlers). We have reference counting but it counts ALL refs including calls, which breaks transitive dead code detection.\n\n## Solution\n\nAdd a `CountNonCallReferences` helper that counts references where the function value 'escapes' - is used but not directly called. These indicate the function could be invoked outside our analysis scope.\n\n## Non-call reference cases to detect\n\n1. **Passed as argument**: `http.HandleFunc(\"/\", handler)`\n2. **Assigned to variable**: `fn := myFunc`  \n3. **Assigned to struct field**: `cmd.Run = handler`\n4. **Struct literal field**: `\u0026Command{Run: handler}`\n5. **Stored in map**: `handlers[\"x\"] = myFunc`\n6. **Stored in slice/array**: `[]func(){a, b, c}`\n7. **Returned from function**: `return myFunc`\n8. **Channel send**: `ch \u003c- myFunc`\n9. **Type conversion**: `http.HandlerFunc(myHandler)`\n\n## What IS a call (exclude from count)\n\n- Direct call: `foo()`\n- Method call: `x.Method()`\n- Qualified call: `pkg.Func()`\n\n## Implementation\n\nIn AST terms: if identifier is the `Fun` field of `*ast.CallExpr`, it's a call. All other uses are non-call references.\n\n```go\nfunc CountNonCallReferences(pkgs []*Package, sym *Symbol) int\n```\n\n## Updated deadcode logic\n\n```\nSymbol is DEAD if:\n  - NOT SSA reachable (handles transitive calls)\n  - AND has zero non-call references (handles escaping function values)\n```\n\n## Expected impact\n\nFixes false positives for:\n- cobra command handlers (Run: handler)\n- http handlers (HandleFunc patterns)  \n- callback-based APIs\n- Any function passed by reference to external code\n\nDepends on: wc-4967 (related false positive tracking)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-22T14:01:03.479678742Z","updated_at":"2026-01-22T14:04:40.77025085Z","closed_at":"2026-01-22T14:04:40.77025085Z"}
{"id":"wc-6336","content_hash":"7ad28c700da0a629479ebc05a3e2994ae5b34777c5ae3c9db6f694241ed9644b","title":"Use file:start:end comment format in deadcode output","description":"Update deadcode output to use the same location format as the package command:\n\nCurrent:\n```\n/home/jason/.../client.go:13:21\n```\n\nDesired:\n```\ntype Client struct { ... } // client.go:13:21\n```\n\nUse relative filename and append as comment after the definition, matching the package command style.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-21T13:32:07.205380184Z","updated_at":"2026-01-21T13:36:48.227468567Z","closed_at":"2026-01-21T13:36:48.227468567Z"}
{"id":"wc-63e2","content_hash":"9de89fc1b3baf060e3eb87657c747c1fc70ee70026ec2effc429d4ad7aa5f2e7","title":"Add Project.ResolveSymbol() for query normalization","description":"Add a method on Project that normalizes a symbol query by resolving short package names to full paths.\n\n## Current pattern (symbol.go:180)\n\n```go\nif i := strings.IndexByte(symbol, '.'); i \u003e -1 {\n    path, name := symbol[:i], symbol[i+1:]\n    pi, err := wc.Project.ResolvePackageName(ctx, path)\n    if err == nil {\n        symbol = pi.PkgPath + \".\" + name\n    }\n}\n```\n\n## Proposed API\n\n```go\n// ResolveSymbol normalizes a symbol query by resolving short package names.\n// \"model.Task\" -\u003e \"github.com/user/repo/model.Task\"\n// \"Task\" -\u003e \"Task\" (unchanged, no package prefix)\n// \"github.com/foo/bar.Baz\" -\u003e \"github.com/foo/bar.Baz\" (already full path)\nfunc (p *Project) ResolveSymbol(ctx context.Context, query string) string\n```\n\n## Benefits\n\n- Encapsulates query normalization logic in one place\n- Can be reused by any command that accepts symbol queries\n- Hides the string parsing and package resolution details","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T02:26:14.017313402Z","updated_at":"2026-01-26T03:34:36.3073916Z","closed_at":"2026-01-26T03:34:36.3073916Z"}
{"id":"wc-64bf","content_hash":"74c5ce103013a59c1ebf907933ba59b53d8336a20f2936c0cc2f609811574da8","title":"Scope pattern matching silently ignores doublestar.Match errors","description":"In scope.go:105, doublestar.Match errors are silently discarded:\n\nLocation: internal/commands/scope.go:105\n\nCode:\n  matched, _ := doublestar.Match(pattern, pkgPath)\n  return matched\n\nImpact: If user provides a malformed glob pattern, it silently returns 'no match' instead of reporting the pattern is invalid.\n\nOptions:\n- Return error from matchPattern and propagate\n- Validate patterns at parse time in ParseScope\n- Include pattern_errors field in response","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:52:33.615669368Z","updated_at":"2026-01-23T11:12:02.975214954Z","closed_at":"2026-01-23T11:12:02.975214954Z","dependencies":[{"issue_id":"wc-64bf","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:52:33.632648324Z","created_by":"jason"}]}
{"id":"wc-65fe","content_hash":"88aef6e0890cd39353a899d4ff62a9b002e28f684b73ccca48d987d7a6447940","title":"Add wildcat satisfies command - interface compliance check","description":"Check if a type implements an interface, with diff of what's missing.\n\n## Use Case\nWhen modifying types that should satisfy interfaces, quickly check compliance and see exactly what's missing.\n\n## Distinction from 'implements'\n- `implements \u003cinterface\u003e` - finds all types implementing an interface\n- `satisfies \u003ctype\u003e \u003cinterface\u003e` - checks if specific type satisfies interface\n\n## CLI Design\n```\nwildcat satisfies \u003ctype\u003e \u003cinterface\u003e\n```\n\n## Output Example\n```json\n{\n  \"type\": \"MyHandler\",\n  \"interface\": \"http.Handler\",\n  \"satisfies\": false,\n  \"implemented\": [\n    {\"method\": \"ServeHTTP\", \"signature\": \"func(w ResponseWriter, r *Request)\"}\n  ],\n  \"missing\": [\n    {\"method\": \"Close\", \"signature\": \"func() error\", \"hint\": \"add to *MyHandler\"}\n  ]\n}\n```\n\n## Implementation Notes\n- Use go/types to check method sets\n- Compare type's method set against interface's method set\n- Show signature of missing methods for easy implementation\n- Consider pointer vs value receiver requirements\n\n## Source\nUser testing session feedback - 2026-01-17","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-17T09:04:11.913809343Z","updated_at":"2026-01-22T02:22:14.961433798Z","closed_at":"2026-01-22T02:22:14.961433798Z"}
{"id":"wc-66a1","content_hash":"17d43943d21a65ff46e925ce702bd716147c1d83054b25f6e738cfcdd93d314c","title":"refactor: migrate readme command to internal/commands/readme","description":"Move readme command to follow the same pattern as other commands (package, symbol, tree, deadcode, channels). Create internal/commands/readme/ with readme.go and readme_response.go. Mark MarshalJSON and MarshalMarkdown output as TODO for now.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-22T15:14:32.199137499Z","updated_at":"2026-01-22T15:19:20.794482155Z","closed_at":"2026-01-22T15:19:20.794482155Z"}
{"id":"wc-67b8","content_hash":"a3ccb0731365f8810ad8b61469819c217432dba0d661fa5d38e837ab0f3ec07e","title":"Symbol lookup fails for pkg.Type.Method format","description":"When querying 'database.DB.DeleteTask', lookup fails but the exact symbol appears in suggestions.\n\nExample:\n```\nwildcat symbol database.DB.DeleteTask -o json\n{\n  \"code\": \"symbol_not_found\",\n  \"error\": \"github.com/jasonmoo/bbb/database.DB.DeleteTask not found\",\n  \"suggestions\": [\"database.DB.DeleteTask\"]\n}\n```\n\nThe symbol exists (it's in suggestions) but the Lookup function isn't finding it. Likely an issue with how pkg.Type.Method queries are resolved.","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-22T07:26:26.883447657Z","updated_at":"2026-01-22T07:28:35.725486867Z","closed_at":"2026-01-22T07:28:35.725486867Z"}
{"id":"wc-68c4","content_hash":"7eaa366d4d8ead7ccf83bb183831e388c75c8db6ff96a7a37932afb4593b6f3b","title":"Migrate search command to Command[T] pattern","description":"Research migrating search command away from gopls. Evaluate if we can build better symbol search using packages.Load","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-20T06:50:29.620360332Z","updated_at":"2026-01-20T12:59:23.241467238Z","closed_at":"2026-01-20T12:59:23.241467238Z"}
{"id":"wc-68f8","content_hash":"c71b23770e3c1cd248d0503680845e7eea9bdaf1a77c7f257edf126224b22296","title":"Update package command to use golang interface helpers","description":"Replace inline interface logic in internal/commands/package/package.go with helpers from internal/golang/interfaces.go:\n\n- CollectInterfaces (lines 223-269)\n- FindImplementors (lines 271-306) \n- FindSatisfiedInterfaces (lines 308-367)\n\nThe package command has more complete logic (generics, error interface, Types.Scope) that was used as the source for the helpers. Verify the helpers match and swap in.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-21T08:17:46.369314452Z","updated_at":"2026-01-21T14:23:47.117736843Z","closed_at":"2026-01-21T14:23:47.117736843Z"}
{"id":"wc-6a7f","content_hash":"2f5dbb859d3a9da39abd863d8264c34a31ef024964ccd43123779c5d5f82adad","title":"Unified scoping model: project → package → symbol hierarchy","description":"Make the project → package → symbol hierarchy a first-class concept across all commands.\n\n## Current State\nThe --scope flag exists on several commands but isn't consistently applied.\n\n## User Feedback\nCommands naturally scope to: project → package → symbol\n\nMaking this hierarchy explicit across all commands:\n- `wildcat channels` at project vs package level\n- `wildcat dead` at project vs package level\n- etc.\n\n## Proposed Behavior\n- Default scope makes sense per command (e.g., search defaults to project, symbol defaults to package)\n- `--scope project` / `--scope package` / `--scope \u003cpath\u003e` works consistently\n- Output clearly indicates what scope was used\n\n## Commands to Audit\n- [ ] search - has --scope\n- [ ] symbol - has --scope\n- [ ] tree - no scope yet\n- [ ] channels - no scope yet\n- [ ] dead (when implemented)\n- [ ] project (always project scope)\n- [ ] package (always package scope)\n\n## Source\nUser testing session feedback - 2026-01-17","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-17T09:04:48.888815942Z","updated_at":"2026-01-17T09:29:19.79809955Z","closed_at":"2026-01-17T09:29:19.79809955Z"}
{"id":"wc-6bbd","content_hash":"84275225579090649677351da8575bfd94053949f9ef7591582e8c2328a4349c","title":"Improve tree command output structure","description":"Changed tree output from paths array to nested tree structure:\n\n**JSON format:**\n- `tree` field contains recursive TreeNode: {symbol, line, calls[]}\n- `calls` is an array of child TreeNodes\n- `line` shows the call site (where this function is called)\n- Root node has no line (it's the starting point)\n\n**Markdown format:**\n- ASCII art tree with box-drawing characters (├── └── │)  \n- Line numbers in parentheses (:15)\n- Proper indentation for all depth levels\n\n**jq navigation:**\n- `.tree.symbol` - root symbol\n- `.tree.calls[0].symbol` - first callee\n- `.tree.calls[] | select(.calls) | .symbol` - nodes with children\n\n**Summary changed:**\n- `total_calls` instead of `path_count`\n- Represents total call edges in tree","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-17T13:47:55.184484024Z","updated_at":"2026-01-17T14:21:38.185279112Z","closed_at":"2026-01-17T14:21:38.185279112Z"}
{"id":"wc-6c54","content_hash":"e625fee29a020c2ecf337f137cc398a8fb7aad1be96118420f51bb0df269a325","title":"Add wildcat symbols command - fuzzy symbol search for AI agents","description":"## Problem\nAI agents rely heavily on grep for code navigation, which returns raw text matches without semantic understanding. This leads to:\n- Noise from comments, strings, variable names all treated equally\n- No symbol type information (function vs variable vs type)\n- Requires post-processing to understand context\n- Many irrelevant matches\n\n## Solution: `wildcat symbols` Command\nExpose gopls workspace/symbol fuzzy search as a first-class wildcat command, optimized for AI agent consumption.\n\n## gopls workspace/symbol Capabilities\n\n### Fuzzy Matching\n- Uses `fastFuzzy` algorithm (FZF-inspired)\n- Smart-casing: case-sensitive if query contains uppercase, otherwise case-insensitive\n- Ranked results with scoring based on match quality\n\n### Query Syntax (expose fully)\n- Basic fuzzy: `DocSym` matches `DocumentSymbol`\n- `^prefix` - exact prefix match (smart-cased)\n- `$suffix` - exact suffix match (smart-cased)  \n- `'exact` - exact substring match (smart-cased)\n- Multiple terms combined with AND logic\n\n### Symbol Kinds Returned\nFunction, Method, Struct, Interface, Constant, Variable, Field, Package, etc.\n\n### Ranking/Scoring\n- Workspace symbols prioritized over non-workspace\n- Unexported symbols outside workspace: 0.5x penalty\n- Max 100 results, sorted by: score desc → name length asc → lexical\n\n---\n\n## Output Design: Beyond gopls Flat List\n\n### Raw gopls Response\n```go\ntype SymbolInformation struct {\n    Name          string     // \"Resolver.Resolve\" \n    Kind          SymbolKind // 6 (Method)\n    Location      Location   // URI + Range\n    ContainerName string     // \"github.com/.../symbols\"\n}\n```\n\n### Decorations to Add\n\n| Field | Source | Value for AI |\n|-------|--------|--------------|\n| `kind` | Map SymbolKind int → string | \"method\" not 6 |\n| `file` | Parse URI | Absolute path |\n| `line` / `line_end` | Range + 1 | 1-indexed |\n| `exported` | Name[0] uppercase | Quick filter |\n| `package` | Full ContainerName | Import path |\n| `package_short` | Last segment | \"symbols\" |\n| `snippet` | Read file at location | Inline context |\n| `signature` | textDocument/hover call | Function/method signature |\n\n### Signature via Hover (High Value)\ngopls `textDocument/hover` returns rich info including signatures:\n```\nfunc (r *Resolver) Resolve(ctx context.Context, query *Query) (*ResolvedSymbol, error)\n```\n\nThis is extremely valuable for AI to understand what a symbol does without reading the file. Trade-off is one LSP call per result - consider:\n- Only fetch for top N results (e.g., top 10)\n- Flag to enable/disable: `--signatures` \n- Lazy fetch only for high-confidence matches\n\n### Grouping Options\n\n**Flat list (default)** - matches gopls, good for small result sets:\n```json\n{ \"results\": [ {symbol}, {symbol}, ... ] }\n```\n\n**Group by file** - useful when AI wants to read one file with multiple matches:\n```json\n{\n  \"by_file\": {\n    \"/path/to/resolve.go\": {\n      \"symbols\": [ {symbol}, {symbol} ],\n      \"count\": 2\n    }\n  }\n}\n```\n\n**Group by package** - useful for understanding code organization:\n```json\n{\n  \"by_package\": {\n    \"internal/symbols\": {\n      \"files\": {\n        \"resolve.go\": [ {symbol} ],\n        \"parse.go\": [ {symbol} ]\n      },\n      \"count\": 5\n    }\n  }\n}\n```\n\n**Flag**: `--group \u003cnone|file|package\u003e` (default: none)\n\n---\n\n## Command Design\n\n```\nwildcat symbols \u003cquery\u003e [flags]\n```\n\n### Flags\n- `--kind \u003ckind\u003e` - Filter by symbol kind (function, method, type, interface, const, var, field, struct)\n- `--limit \u003cn\u003e` - Max results (default: 50)\n- `--exported` - Only exported symbols\n- `--package \u003cpattern\u003e` - Filter to package path pattern\n- `--context \u003cn\u003e` - Lines of snippet context (default: 3)\n- `--compact` - Omit snippets\n- `--signatures` - Include function/method signatures (adds latency)\n- `--group \u003cnone|file|package\u003e` - Result grouping (default: none)\n\n### Example Output (flat with signatures)\n```json\n{\n  \"query\": {\n    \"command\": \"symbols\",\n    \"pattern\": \"Resolve\",\n    \"flags\": { \"kind\": null, \"limit\": 50, \"exported\": false }\n  },\n  \"results\": [\n    {\n      \"symbol\": \"Resolver.Resolve\",\n      \"kind\": \"method\",\n      \"exported\": true,\n      \"file\": \"/home/user/wildcat/internal/symbols/resolve.go\",\n      \"line\": 32,\n      \"line_end\": 77,\n      \"package\": \"github.com/jasonmoo/wildcat/internal/symbols\",\n      \"package_short\": \"symbols\",\n      \"signature\": \"func (r *Resolver) Resolve(ctx context.Context, query *Query) (*ResolvedSymbol, error)\",\n      \"snippet\": \"// Resolve finds a symbol matching the query.\\nfunc (r *Resolver) Resolve(...\"\n    }\n  ],\n  \"summary\": {\n    \"count\": 15,\n    \"by_kind\": { \"method\": 5, \"function\": 8, \"type\": 2 },\n    \"packages\": [\"internal/symbols\", \"internal/lsp\"],\n    \"truncated\": false\n  }\n}\n```\n\n### Example Output (grouped by package)\n```json\n{\n  \"query\": { \"command\": \"symbols\", \"pattern\": \"Parse\", \"flags\": { \"group\": \"package\" } },\n  \"by_package\": {\n    \"internal/symbols\": {\n      \"path\": \"github.com/jasonmoo/wildcat/internal/symbols\",\n      \"files\": {\n        \"parse.go\": [\n          { \"symbol\": \"Parse\", \"kind\": \"function\", \"line\": 24, \"signature\": \"func Parse(input string) (*Query, error)\" },\n          { \"symbol\": \"ParseError\", \"kind\": \"struct\", \"line\": 118 }\n        ]\n      },\n      \"count\": 2\n    },\n    \"internal/config\": {\n      \"path\": \"github.com/jasonmoo/wildcat/internal/config\",\n      \"files\": {\n        \"config.go\": [\n          { \"symbol\": \"ParseFile\", \"kind\": \"function\", \"line\": 45 }\n        ]\n      },\n      \"count\": 1\n    }\n  },\n  \"summary\": { \"count\": 3, \"packages\": 2, \"truncated\": false }\n}\n```\n\n---\n\n## Files to Create/Modify\n- `cmd/symbols.go` - New command\n- `internal/output/types.go` - Add SymbolsResponse, SymbolResult, ByPackage types\n- `internal/symbols/search.go` - New file for search logic + hover decoration\n\n## Acceptance Criteria\n- [ ] `wildcat symbols Resolve` returns ranked fuzzy matches\n- [ ] `wildcat symbols ^Parse` returns prefix matches\n- [ ] `wildcat symbols '$Error'` returns exact substring matches\n- [ ] `--kind function` filters to functions only\n- [ ] `--exported` filters to exported symbols\n- [ ] `--signatures` fetches hover info for each result\n- [ ] `--group package` groups results by package\n- [ ] `--group file` groups results by file\n- [ ] Output includes file, line, kind, package, snippet\n- [ ] Ranking preserved from gopls ordering","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T05:58:47.309544434Z","updated_at":"2026-01-13T08:16:18.923674158Z","closed_at":"2026-01-13T08:16:18.923674158Z"}
{"id":"wc-6c5f","content_hash":"af7a2b0fc026aa9af12d66a114f5c372263d6bd6c3d70de3aa6bf01c8e2b7f25","title":"Implement --package filter flags","description":"## Problem\nThe --package filter flags are stubbed out with TODO comments in the code.\n\n## Current Code (callers.go:170-172)\n```go\nif callersPackage != \"\" {\n    // TODO: implement package filtering\n}\n```\n\n## Scope\nImplement package filtering for:\n- `callers --package \u003cpattern\u003e`\n- `refs --package \u003cpattern\u003e`\n\n## Behavior\n- Pattern matching: glob style (`internal/*`, `github.com/user/*`)\n- Filter results to only show matches from specified packages\n- Should work with both full paths and relative patterns\n\n## Files\n- cmd/callers.go\n- cmd/refs.go\n- internal/output/filter.go (new, shared logic)\n\n## Acceptance Criteria\n- [ ] `--package internal/*` filters to internal packages\n- [ ] `--package .` filters to current module only\n- [ ] Pattern supports glob wildcards\n- [ ] Works for both callers and refs commands","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-10T05:59:25.14989845Z","updated_at":"2026-01-15T03:19:00.369071214Z","closed_at":"2026-01-15T03:19:00.369071214Z"}
{"id":"wc-6ef0","content_hash":"992615a713ea2637f9f02b7b6b592c0a893abf96ea46aa18d5fcb4dba343994d","title":"Location format varies by context","description":"Location format is inconsistent across commands:\n\n| Context | Format |\n|---------|--------|\n| symbol.target | \"file\": \"...\", \"line\": 10 (separate fields) |\n| symbol.references[].location | \"content.go:51\" (inlined) |\n| symbol.references[].snippet.location | \"content.go:51:51\" (with end line) |\n| package.types[].location | \"id.go:15:17\" (inlined with range) |\n| tree.target.definition | Full path /home/.../file.go:10:16 |\n| tree.callers[].callsite | Full path /home/.../file.go:124 |\n\nTarget being different from everything else stands out. May be intentional but worth reviewing.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-18T05:47:12.123537276Z","updated_at":"2026-01-18T05:57:37.643739517Z","closed_at":"2026-01-18T05:57:37.643739517Z"}
{"id":"wc-6f06","content_hash":"ea43f324966179e6dddeed93614fdf1a6cdf94c45e32f9e206b05da591bd1109","title":"ls command should accept multiple symbols","description":"The ls command should accept multiple path arguments and list all of them in the output, sorted by the order they were provided.\n\nExample:\n```\n./wildcat ls golang.Symbol golang.Package golang.Project\n```\n\nShould list paths for all three symbols in the order specified.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-27T07:39:27.546170655Z","updated_at":"2026-01-27T07:41:30.848651344Z","closed_at":"2026-01-27T07:41:30.848651344Z"}
{"id":"wc-6f75","content_hash":"9b990c8b8120dce3e8cb95d66e0ab6243d5b0314b5f6bcf41f6b048a7b60ae64","title":"Descendants section shows empty signature/definition","description":"Bug report: Symbol command shows descendants with empty signature and definition.\n\nExample output:\n```\n## Descendants (1)\n\n // \n  only referenced by CrudOperator\n```\n\nExpected: Either show valid type info or don't include the descendant.\n\nAlso seen with commands.Command interface showing:\n```\n## Descendants (1)\n\n // \n  only referenced by Command\n```\n\nLikely cause: findDescendants is returning a type that couldn't be resolved or formatted properly.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-22T07:59:56.070405655Z","updated_at":"2026-01-22T08:04:01.944412283Z","closed_at":"2026-01-22T08:04:01.944412283Z"}
{"id":"wc-6f9c","content_hash":"3d3b3dfd96955dc5b879d0996d7fd5a11e88a74cc7057c768348687085d2d653","title":"Add Symbol.Id() helper for unique symbol identification","description":"Add a new helper method `Id()` on Symbol that returns the canonical unique identifier for any symbol.\n\n## Motivation\n\nWe have multiple helpers (`PkgPathSymbol`, `PkgPathTypeSymbol`) but no single method that says \"this is THE unique identifier for this symbol\". The name `Id()` makes the intent clear.\n\n## Specification\n\n```go\n// Id returns the unique identifier for this symbol.\n// Format: \"pkgPath.Name\" for top-level symbols, \"pkgPath.Type.Method\" for methods.\nfunc (ps *Symbol) Id() string\n```\n\nThis is essentially an alias for `PkgPathTypeSymbol()` but with a clearer name indicating its purpose as the canonical identifier.\n\n## Usage\n\nReplace patterns like:\n- `sym.PackageIdentifier.PkgPath + \".\" + sym.Name` (for non-methods)\n- `sym.PackageIdentifier.PkgPath + \".\" + recv + \".\" + sym.Name` (for methods)\n- Deduplication keys in search results\n- Map keys for symbol lookups\n\n## Consideration\n\nShould `PkgPathTypeSymbol()` be deprecated in favor of `Id()`, or should `Id()` simply call `PkgPathTypeSymbol()`?","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T02:17:52.396650349Z","updated_at":"2026-01-26T02:37:08.122987079Z","closed_at":"2026-01-26T02:37:08.122987079Z"}
{"id":"wc-6fb8","content_hash":"eb2944a7b8b2708aa99ae74c7f83de45aa192ac159678383d771db118daf3f67","title":"Plugin author documentation","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-10T08:26:35.369479889Z","updated_at":"2026-01-22T02:22:15.268576594Z","closed_at":"2026-01-22T02:22:15.268576594Z"}
{"id":"wc-70e7","content_hash":"9324c158bdcc932cf80634467f50e438dd35d5c2e740669d2c801916a8556c65","title":"Ensure markdown and JSON parity for symbol command","description":"Audit the symbol command to ensure markdown and JSON outputs contain the same information.\n\nRecent changes added:\n- Implementation counts (impls) for Satisfies section\n- Grouped PackageTypes for Implementations/Satisfies\n- RefCount for merged references\n- callers() vs refs() semantic distinction\n\nNeed to verify:\n1. JSON struct fields match what's rendered in markdown\n2. New fields (Impls, RefCount) are properly serialized\n3. Grouped structures (PackageTypes) serialize correctly\n4. No data is present in one format but missing from the other\n\nThis is a quality gate before adding more features.","status":"closed","priority":1,"issue_type":"chore","created_at":"2026-01-22T07:16:22.999765654Z","updated_at":"2026-01-22T07:20:25.915859726Z","closed_at":"2026-01-22T07:20:25.915859726Z"}
{"id":"wc-7267","content_hash":"ba82dceba1cb6e921ae849c189760eb0d8c12b26efca13dc236ea242b3250126","title":"Iterate on target block format for tree/symbol commands","description":"Review and improve the target block structure. Currently has symbol, kind, file, line. Consider: line_end, signature, or other useful fields.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-18T03:08:38.069408744Z","updated_at":"2026-01-18T06:38:04.683678865Z","closed_at":"2026-01-18T06:38:04.683678865Z"}
{"id":"wc-728f","content_hash":"5156dc87cfe35258f506c1bf6f7b867f74511185c62be3e2e9f85b2c9399a08c","title":"Audit commands for snippet output support","description":"Review all commands to identify opportunities for adding code snippets to their outputs, similar to the impact command enhancement","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T12:42:11.184161371Z","updated_at":"2026-01-14T07:33:41.425663214Z","closed_at":"2026-01-14T07:33:41.425663214Z"}
{"id":"wc-779c","content_hash":"e852c104ea3ed8450857c028bb3760e5910e0d623fdd4b3cf9f084dc438c650d","title":"Implement path resolution library","description":"Build the core library for parsing, resolving, and generating semantic paths.\n\n**Location:** `internal/golang/path/` (new package)\n\n**Core Types:**\n```go\n// Path represents a parsed semantic path\ntype Path struct {\n    Package  string     // Full import path (canonical)\n    Symbol   string     // Top-level symbol name\n    Method   string     // Method name (empty for non-methods)\n    Subpaths []Segment  // Structural navigation\n}\n\n// Segment represents one /category[selector] component\ntype Segment struct {\n    Category string  // fields, params, returns, etc.\n    Selector string  // Name or position (as string)\n    IsIndex  bool    // true if selector is positional\n}\n```\n\n**Core Functions:**\n\n1. **Parse(input string) (*Path, error)**\n   - Parse path string into structured Path\n   - Accept all input forms (package name, relative, full path)\n   - Validate syntax per grammar\n\n2. **Resolve(ctx, project, path) (ast.Node, error)**\n   - Resolve Path to AST node\n   - Use existing ResolvePackageName for package resolution\n   - Navigate through symbol → method → subpaths\n   - Return specific AST node (Field, FuncDecl, etc.)\n\n3. **Generate(node ast.Node, pkg *Package) string**\n   - Generate canonical path from AST node\n   - Always output full import path\n   - Used for annotating wildcat output\n\n4. **Canonical(path *Path) string**\n   - Format Path as canonical string\n   - Full import path, named selectors where available\n\n**Grammar Reference:** docs/path-syntax-grammar.ebnf\n\n**Implementation Notes:**\n- Use go/ast and go/types for navigation\n- Leverage existing Symbol resolution in golang package\n- Handle grouped params/fields (flatten for positional access)\n- Subpath navigation per path-to-ast-mapping.md\n\n**Acceptance Criteria:**\n- [ ] Parse accepts all three package path forms\n- [ ] Parse rejects invalid syntax with clear errors\n- [ ] Resolve maps paths to correct AST nodes\n- [ ] Generate produces canonical paths\n- [ ] Round-trip: Generate(Resolve(Parse(s))) returns canonical form\n- [ ] Unit tests for each path pattern in grammar\n\n**See Also:**\n- docs/path-syntax-grammar.ebnf (formal grammar)\n- docs/reference/path-to-ast-mapping.md (AST navigation)\n- docs/reference/go-constructs-analysis.md (design decisions)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-27T05:26:55.087319357Z","updated_at":"2026-01-27T05:36:45.270732248Z","closed_at":"2026-01-27T05:36:45.270732248Z"}
{"id":"wc-77a0","content_hash":"2e626de5f720269ad4bc0e1e1bbb7ca1887d41edb4b4c0c105d23b604683c807","title":"Regression: multiline string constants expand instead of truncating","description":"**Problem:**\nMultiline string constants/variables are being rendered with their full content instead of truncating to a single line.\n\n**Current output:**\n```\n# Constants (1)\nconst isAuthorizedGroupQuery = \\`\nWITH email_group AS (\n    SELECT DISTINCT email\n```\n\n**Expected output:**\n```\n# Constants (1)\nconst isAuthorizedGroupQuery = \\`...\n```\n\n**Impact:**\nLarge SQL queries, templates, or other multiline strings bloat output and reduce readability. The point of the summary view is to show what exists, not dump full content.\n\n**Fix:**\nWhen rendering const/var values that are multiline backtick strings, truncate after the opening backtick with `...`","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-28T13:47:25.722539541Z","updated_at":"2026-01-29T04:17:55.589299734Z","closed_at":"2026-01-29T04:17:55.589299734Z"}
{"id":"wc-782c","content_hash":"e47c36297211bba10c9f3e408e38714c06ed6dff77f37b0739a3d7f5f81d6a37","title":"Document Python/pyright LSP integration findings","description":"## Summary\nWhile setting up evals with Python code, discovered that pyright requires different LSP initialization than gopls.\n\n## Key Findings\n\n### 1. workspaceFolders Required\nPyright needs `workspaceFolders` in InitializeParams, not just `rootUri`. Without this, workspace/symbol returns empty results.\n\n**Fix**: Added WorkspaceFolder type and populate workspaceFolders array in Initialize().\n\n### 2. Explicit didOpen for Files  \nPer GitHub issue microsoft/pyright#10086, pyright only indexes files that have been explicitly opened via textDocument/didOpen. Unlike gopls which indexes the entire workspace automatically.\n\n**Fix**: Added `OpenWorkspaceFiles()` method that walks the workspace and sends didOpen for each source file. Called via `OpenWorkspaceIfNeeded()` helper for Python language.\n\n### 3. Language-Specific Behavior\nDifferent LSP servers have different initialization requirements:\n- **gopls**: Auto-indexes workspace, workspace/symbol works immediately\n- **pyright**: Needs workspaceFolders + explicit didOpen for each file\n\nThis pattern may apply to other servers (typescript-language-server, rust-analyzer, etc.)\n\n## Files Changed\n- internal/lsp/protocol.go - Added WorkspaceFolder type\n- internal/lsp/client.go - Added workspaceFolders to init, added OpenWorkspaceFiles()\n- cmd/server.go - Added OpenWorkspaceIfNeeded() helper\n- cmd/*.go - All commands call OpenWorkspaceIfNeeded()\n\n## Future Considerations\n- May need similar handling for other language servers\n- Could optimize by only opening files matching the symbol query\n- Performance impact on large codebases needs testing\n\n## References\n- https://github.com/microsoft/pyright/issues/10086","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T03:24:32.148096572Z","updated_at":"2026-01-15T14:47:02.943964956Z","closed_at":"2026-01-15T14:47:02.943964956Z"}
{"id":"wc-7863","content_hash":"63cce36666a67657db4377c60fc958d184f6d39a21f4edd9766928f99173797b","title":"Flexible package path resolution across all commands","description":"gopls requires full paths (github.com/jasonmoo/wildcat/internal/lsp) or relative ./ paths (./internal/lsp), but bare paths like 'internal/lsp' fail. Need to explore normalizing user input to acceptable formats - auto-prepending ./ for relative paths, resolving partial paths to full import paths, etc. Affects: package, tree, callers, callees, refs, impact, implements, satisfies commands.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-15T04:57:45.209022047Z","updated_at":"2026-01-15T13:30:44.237141214Z","closed_at":"2026-01-15T13:30:44.237141214Z"}
{"id":"wc-79d6","content_hash":"e6ee3121af79ebcb3daf922258935ef6df9e5fc42b9b23378d29ec5dc746a672","title":"Format functions should return best-effort signature with inline errors","description":"When FormatFuncDecl, FormatTypeSpec, FormatValueSpec, FormatNode, or Signature() fail, instead of:\n- Returning error (breaks analysis flow)\n- Discarding error with _ (silent failure)\n- Falling back to just the name (loses context)\n\nWe should return a best-effort signature with the error inlined:\n- Normal: 'func NewClient(addr string) *Client'\n- Error: 'func NewClient(...) \u003cformat error: nil receiver type\u003e'\n\nImplementation approach:\n1. Change Format* functions to never return error\n2. On failure, include error message in angle brackets at point of failure\n3. Try to render as much as possible before the error\n4. Signature() method should use same pattern\n\nExamples:\n  'type Config \u003cparse error: unexpected EOF\u003e'\n  'func (r \u003cnil receiver\u003e) Method() error'\n  'var ErrFoo \u003ctype unavailable\u003e'\n\nBenefits:\n- Analysis never breaks due to format errors\n- Errors are visible inline where they occur\n- AI sees exactly what couldn't be rendered\n- No need for separate error fields in every struct\n- Simpler calling code (no error handling needed)\n\nThis supersedes the approach in wc-14fe - rather than tracking signature errors separately, embed them in the output.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T06:02:05.543850096Z","updated_at":"2026-01-23T10:33:07.141265491Z","closed_at":"2026-01-23T10:33:07.141265491Z"}
{"id":"wc-79e8","content_hash":"f9373d37e64eceda1972bd061ee140859a686038cff1ffbd78c4e059a381573d","title":"Switch negation syntax from \\! to -","description":"The \\! prefix for excluding packages in --scope causes shell escaping issues. Change to - prefix instead (e.g., --scope '-internal/lsp' instead of --scope '\\!internal/lsp').","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-17T03:22:34.626464182Z","updated_at":"2026-01-17T07:59:26.191821032Z","closed_at":"2026-01-17T07:59:26.191821032Z","dependencies":[{"issue_id":"wc-79e8","depends_on_id":"wc-4552","type":"discovered-from","created_at":"2026-01-17T03:22:34.643406672Z","created_by":"jason"}]}
{"id":"wc-7bb6","content_hash":"64c351e6431fd1309ef9e4a8431e3f939fb8b70e0b1ffe98cc5484cf6e689c9e","title":"read command: support category without selector","description":"Support syntax like `spath.Path/fields` to show all fields, not just `spath.Path/fields[Name]` for a specific one.\n\nCurrently this returns an error:\n```\nwildcat read 'spath.Path/fields'\nError: (path_not_found) \"spath.Path/fields\" not found\n```\n\nShould enumerate and display all children in that category.\n\nThis is a natural expectation - if `ls` shows `/fields[X]` paths exist, then `/fields` should work as a read target.\n\nRelated: wc-8c03 (doublestar expansion)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-27T14:24:59.69558426Z","updated_at":"2026-01-28T05:18:53.124045936Z","closed_at":"2026-01-28T05:18:53.124045936Z"}
{"id":"wc-7cf1","content_hash":"43ee682efa6c14b88192625c41871d13b21e3c4690bdd84df4ab476c96ceaba7","title":"Package markdown example doesn't match reality","description":"Docs show:\n```\ntype DB struct {\n    ...\n} // db.go:22:47, satisfies: database.ReadOnly\n```\n\nActual output uses tables without satisfies info. The satisfies field only appears in package JSON output under types[].satisfies, not in markdown.","status":"closed","priority":3,"issue_type":"chore","created_at":"2026-01-18T05:47:12.463439063Z","updated_at":"2026-01-18T06:06:13.450873024Z","closed_at":"2026-01-18T06:06:13.450873024Z"}
{"id":"wc-7ed8","content_hash":"3e56909c84b29f50a04542e3fb0c160b486589340a510aecb4b3ab4cd7fecde4","title":"AIDE Spec: AI Development Environment Specification","description":"Research codifying the wildcat interface into a formal specification.\n\nGoals:\n- Define a spec so other tool authors can implement for their language\n- Enable AI companies to train models to understand the spec natively\n- Similar to LSP but designed specifically for AI consumption\n\nThis would be the interface contract that any AIDE-compliant tool would implement.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-15T08:36:39.081620578Z","updated_at":"2026-01-15T08:36:39.081620578Z"}
{"id":"wc-7f0f","content_hash":"1b58db29deb93e35ef266555a47b8e7074f85f268afeba9dc98d3bdf873755b5","title":"ls command: subpath queries show incorrect path and type info","description":"When querying a subpath like `ls_cmd.PathEntry/fields[Path]`, the output shows incorrect information:\n\n```\n$ ./wildcat ls ls_cmd.PathEntry/fields[Path]\n# query github.com/jasonmoo/wildcat/internal/commands/ls.PathEntry\nls_cmd.PathEntry  // struct\nls_cmd.PathEntry/tag\n```\n\nIssues:\n1. Query header shows `ls.PathEntry` not `ls.PathEntry/fields[Path]`\n2. First result shows `ls_cmd.PathEntry // struct` instead of `ls_cmd.PathEntry/fields[Path] // string`\n3. The type shown is for the parent symbol, not the resolved field\n\nExpected output should show the actual queried path with its type info.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-27T09:23:08.636468453Z","updated_at":"2026-01-27T11:35:53.203892606Z","closed_at":"2026-01-27T11:35:53.203892606Z"}
{"id":"wc-7f2c","content_hash":"77a447c0176e12e85db8687a0d274c484703d4385413afd5ab905699c133df48","title":"Package command: always show section headers with counts","description":"Package command should always show section headers with counts, not omit empty sections.\n\nCurrent behavior: Embeds section is omitted when no //go:embed directives exist\nDesired behavior: Show '# Embeds (0)' to clearly signal 'no embeds here'\n\nThis is important for AI consumers - explicit zeros are clearer than missing sections.\n\nSections affected:\n- Embeds (current)\n- Channels (after wc-42df merge)\n\nImplementation:\n- Update MarshalMarkdown to always emit section headers\n- Format as '# Section (N)' or '# Section (0)' consistently","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-23T03:33:39.86778123Z","updated_at":"2026-01-23T03:39:21.671469198Z","closed_at":"2026-01-23T03:39:21.671469198Z","dependencies":[{"issue_id":"wc-7f2c","depends_on_id":"wc-42df","type":"related","created_at":"2026-01-23T03:33:45.536872503Z","created_by":"jason"}]}
{"id":"wc-8113","content_hash":"e7fb14d77c8bed50d22bc5863ecb5022e094718c8ad7a6da5f42ea3634b2ea88","title":"Native go/packages implementation (no gopls)","description":"Replace gopls/LSP backend with native go/packages + go/types implementation for reliable, synchronous code analysis. Keep both implementations available via flag during transition.","status":"closed","priority":4,"issue_type":"epic","created_at":"2026-01-17T07:55:34.474151924Z","updated_at":"2026-01-22T02:50:29.282953389Z","closed_at":"2026-01-22T02:50:29.282953389Z"}
{"id":"wc-8113.1","content_hash":"8bdcf590c7ff8c2beb99085d60c492684a5e17ab59b6221170083bdd08ed10df","title":"Package loader with caching infrastructure","description":"Create internal/native/loader package that wraps go/packages with:\n- Merkle tree hash for cache invalidation\n- Cached type info storage (probably gob-encoded)\n- API that returns fully loaded packages with types\n- Cache warming on first load, fast path on subsequent\n\nThis is the foundation all native commands will use.","status":"closed","priority":4,"issue_type":"feature","created_at":"2026-01-17T07:55:42.987761648Z","updated_at":"2026-01-22T02:50:29.298819804Z","closed_at":"2026-01-22T02:50:29.298819804Z"}
{"id":"wc-8113.2","content_hash":"3e69bbb393de6c12f11e6b93f47e562f12bea1f8fe2e97d518160635202ae650","title":"Native 'package' command","description":"Replace gopls-based package command with native go/packages implementation.\n\nComplexity: LOW - Just enumerate symbols from parsed AST, no cross-package analysis needed.\n\nImplementation:\n- Use loader to get package\n- Walk AST to extract symbols (funcs, types, vars, consts)\n- Format in godoc order\n\nAdd --native flag to switch implementations.","status":"closed","priority":4,"issue_type":"feature","created_at":"2026-01-17T07:55:48.886171638Z","updated_at":"2026-01-22T02:50:29.302376686Z","closed_at":"2026-01-22T02:50:29.302376686Z","dependencies":[{"issue_id":"wc-8113.2","depends_on_id":"wc-8113.1","type":"blocks","created_at":"2026-01-17T07:56:49.440221686Z","created_by":"jason"},{"issue_id":"wc-8113.2","depends_on_id":"wc-8113.7","type":"blocks","created_at":"2026-01-17T07:56:49.628832244Z","created_by":"jason"}]}
{"id":"wc-8113.3","content_hash":"d17ac0b175bfefecbf3eb3271e0437c6619eb71a674b8c0496e0e6d62cf3a617","title":"Native 'search' command","description":"Replace gopls-based search command with native go/packages implementation.\n\nComplexity: LOW-MEDIUM - Enumerate symbols from all project packages, apply fuzzy matching.\n\nImplementation:\n- Use loader to get all project packages\n- Extract symbols from each package's AST\n- Apply fuzzy matcher (can reuse gopls's fuzzy package or similar)\n- Score and rank results\n\nAdd --native flag to switch implementations.","status":"closed","priority":4,"issue_type":"feature","created_at":"2026-01-17T07:55:54.11839423Z","updated_at":"2026-01-22T02:50:29.305259399Z","closed_at":"2026-01-22T02:50:29.305259399Z","dependencies":[{"issue_id":"wc-8113.3","depends_on_id":"wc-8113.1","type":"blocks","created_at":"2026-01-17T07:56:49.486514521Z","created_by":"jason"},{"issue_id":"wc-8113.3","depends_on_id":"wc-8113.7","type":"blocks","created_at":"2026-01-17T07:56:49.671364405Z","created_by":"jason"}]}
{"id":"wc-8113.4","content_hash":"1bc3b3e3f368fb3de8012b0dce7af384965dc52df0f069cb5c285451eb7a6e8b","title":"Native 'tree' command (call hierarchy)","description":"Replace gopls-based tree command with native go/packages implementation.\n\nComplexity: MEDIUM\n- Outgoing calls (--down): LOW - just walk function AST, find CallExprs\n- Incoming calls (--up): MEDIUM - need cross-package reference search\n\nImplementation:\n- Use loader to get packages\n- For outgoing: walk function body AST, extract call targets\n- For incoming: search all packages for calls to target function\n- Build tree structure recursively\n\nAdd --native flag to switch implementations.","status":"closed","priority":4,"issue_type":"feature","created_at":"2026-01-17T07:56:00.396569126Z","updated_at":"2026-01-22T02:50:29.308655734Z","closed_at":"2026-01-22T02:50:29.308655734Z","dependencies":[{"issue_id":"wc-8113.4","depends_on_id":"wc-8113.1","type":"blocks","created_at":"2026-01-17T07:56:49.525442872Z","created_by":"jason"},{"issue_id":"wc-8113.4","depends_on_id":"wc-8113.7","type":"blocks","created_at":"2026-01-17T07:56:49.711362217Z","created_by":"jason"},{"issue_id":"wc-8113.4","depends_on_id":"wc-2fca","type":"related","created_at":"2026-01-20T13:09:46.656260222Z","created_by":"jason"}]}
{"id":"wc-8113.5","content_hash":"6a9c58b3380079e3beded8aec9643af956baea119e185df943ba6ef29c9cd144","title":"Native 'channels' command","description":"Replace gopls-based channels command with native go/packages implementation.\n\nComplexity: LOW-MEDIUM - Pattern matching for channel operations in AST.\n\nImplementation:\n- Use loader to get packages\n- Walk AST looking for channel operations (send, receive, close, range)\n- Track channel types and their usage patterns\n- No cross-package analysis needed (channels are typically package-local)\n\nAdd --native flag to switch implementations.","status":"closed","priority":4,"issue_type":"feature","created_at":"2026-01-17T07:56:05.153997273Z","updated_at":"2026-01-22T02:50:29.311459438Z","closed_at":"2026-01-22T02:50:29.311459438Z","dependencies":[{"issue_id":"wc-8113.5","depends_on_id":"wc-8113.1","type":"blocks","created_at":"2026-01-17T07:56:49.558950493Z","created_by":"jason"},{"issue_id":"wc-8113.5","depends_on_id":"wc-8113.7","type":"blocks","created_at":"2026-01-17T07:56:49.746864167Z","created_by":"jason"}]}
{"id":"wc-8113.6","content_hash":"b0107506c4f022194a632a5cbfa1a2ce4ae19cf2f71f3cc4dc1b75ca0278012a","title":"Native 'symbol' command","description":"Replace gopls-based symbol command with native go/packages implementation.\n\nComplexity: HIGH - This is the core command requiring cross-package analysis.\n\nSub-features needed:\n1. Definition lookup - LOW (just resolve identifier to its declaration)\n2. References (--refs) - MEDIUM-HIGH (cross-package identifier search)\n3. Callers (--callers) - MEDIUM (cross-package call site search)  \n4. Interfaces (--interfaces) - MEDIUM (method set computation)\n5. Implementations (--implementations) - MEDIUM (reverse interface matching)\n\nImplementation:\n- Use loader to get all packages\n- Build index of all identifiers and their uses across packages\n- For refs: search Uses map across all packages\n- For callers: filter refs to call expressions only\n- For interfaces: compute method set, find matching interfaces\n- For impls: find types whose method sets satisfy the interface\n\nThis is the hardest command but also the most valuable.\n\nAdd --native flag to switch implementations.","status":"closed","priority":4,"issue_type":"feature","created_at":"2026-01-17T07:56:14.61160674Z","updated_at":"2026-01-22T02:50:29.314959215Z","closed_at":"2026-01-22T02:50:29.314959215Z","dependencies":[{"issue_id":"wc-8113.6","depends_on_id":"wc-8113.1","type":"blocks","created_at":"2026-01-17T07:56:49.590127254Z","created_by":"jason"},{"issue_id":"wc-8113.6","depends_on_id":"wc-8113.7","type":"blocks","created_at":"2026-01-17T07:56:49.778924149Z","created_by":"jason"}]}
{"id":"wc-8113.7","content_hash":"d2c7bcf30277f26e655194e5e660d3d81fdcf964c0214660bc67e3a48d9951b3","title":"Add --native flag for backend selection","description":"Add global --native flag to root command that switches between gopls and native implementations.\n\n- Default to gopls (current behavior) during transition\n- When --native is set, use go/packages-based implementations\n- Eventually flip default and deprecate gopls backend","status":"closed","priority":4,"issue_type":"chore","created_at":"2026-01-17T07:56:19.893185644Z","updated_at":"2026-01-22T02:50:29.317858456Z","closed_at":"2026-01-22T02:50:29.317858456Z"}
{"id":"wc-81dd","content_hash":"8739e0c5456ef1af1c974917d97054aecb60512c5edeeb39c0f6c75faa317eb1","title":"Git History Eval - Wildcat Effectiveness Benchmark","description":"End-to-end eval system that uses real git history (e.g., Kubernetes) to benchmark AI coding effectiveness with and without Wildcat. Uses Claude Code in non-interactive mode as the eval runtime.","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-11T06:10:18.910533787Z","updated_at":"2026-01-14T07:28:20.225667798Z","closed_at":"2026-01-14T07:28:20.225667798Z"}
{"id":"wc-81dd.1","content_hash":"ac65b7185ab57f63493c2dd34299c0e1914d27964de718da8f176451765fd0fa","title":"Eval product design document","description":"Document the eval methodology: what we're measuring, how we compare AI output to committed code, scoring rubrics, success criteria. Define the A/B test structure (with/without Wildcat).","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:10:33.817897456Z","updated_at":"2026-01-14T07:28:20.232957821Z","closed_at":"2026-01-14T07:28:20.232957821Z"}
{"id":"wc-81dd.2","content_hash":"fc172fb765cdd396b14f6c3a2bce37649cf0e3ffab99341b965ae9ab7ee532a2","title":"Claude Code configuration for non-interactive eval","description":"Determine optimal Claude Code flags for eval runs: --allowedTools, --system-prompt, --output-format, --max-budget-usd, permission handling. Document the configuration for reproducibility.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:10:33.910498621Z","updated_at":"2026-01-14T07:28:20.235932918Z","closed_at":"2026-01-14T07:28:20.235932918Z"}
{"id":"wc-81dd.3","content_hash":"b78d693671262de90a0652782603dad048bfcefbd301df07cf2bdbf3be6af493","title":"Commit candidate selection from git history","description":"Build tooling to scan git history and identify good eval candidates. Filter criteria: has linked issue, not a merge/version bump, reasonable scope (not too big/small), touches code files. Output a curated list of (commit, issue) pairs.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:10:33.994198553Z","updated_at":"2026-01-14T07:28:20.239757523Z","closed_at":"2026-01-14T07:28:20.239757523Z"}
{"id":"wc-81dd.4","content_hash":"a4ec28481bf7717661472551b115b472ad38d71719f1b095a0766155b32d444b","title":"Eval orchestration harness","description":"Build the orchestration code (Go) that: resets repo to commit^, extracts issue description, invokes Claude Code with task, captures resulting diff, stores results. Handle parallelization and failure recovery.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T06:10:34.075886823Z","updated_at":"2026-01-14T07:28:20.242916685Z","closed_at":"2026-01-14T07:28:20.242916685Z","dependencies":[{"issue_id":"wc-81dd.4","depends_on_id":"wc-81dd.1","type":"blocks","created_at":"2026-01-11T06:10:40.933600853Z","created_by":"jason"},{"issue_id":"wc-81dd.4","depends_on_id":"wc-81dd.2","type":"blocks","created_at":"2026-01-11T06:10:40.979386928Z","created_by":"jason"},{"issue_id":"wc-81dd.4","depends_on_id":"wc-81dd.3","type":"blocks","created_at":"2026-01-11T06:10:41.015367764Z","created_by":"jason"},{"issue_id":"wc-81dd.4","depends_on_id":"wc-81dd.7","type":"blocks","created_at":"2026-01-11T06:11:46.994111797Z","created_by":"jason"}]}
{"id":"wc-81dd.5","content_hash":"0d1acd4f82e7da808e5aa2fda0a278bfe555d90239ae7bbcc585f1541e84fd47","title":"Result evaluation and comparison logic","description":"Build comparison tooling: structural diff analysis (same files touched?), AI-as-judge for solution quality, metrics collection (cost, tokens, turns). Generate reports comparing Wildcat vs baseline runs.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T06:10:34.164908282Z","updated_at":"2026-01-14T07:28:20.246829865Z","closed_at":"2026-01-14T07:28:20.246829865Z","dependencies":[{"issue_id":"wc-81dd.5","depends_on_id":"wc-81dd.4","type":"blocks","created_at":"2026-01-11T06:10:41.108028097Z","created_by":"jason"}]}
{"id":"wc-81dd.6","content_hash":"b4c0350c891e3675c2372d3b28b8bd6d0cf35119706706beae70978eb2273d97","title":"Docker container isolation for eval runs","description":"Create Docker setup to isolate each eval run: clean repo state, controlled environment, no cross-contamination between runs. Include necessary tooling (Go, Claude Code, git, Wildcat).","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T06:10:34.272756853Z","updated_at":"2026-01-14T07:28:20.25030906Z","closed_at":"2026-01-14T07:28:20.25030906Z","dependencies":[{"issue_id":"wc-81dd.6","depends_on_id":"wc-81dd.2","type":"blocks","created_at":"2026-01-11T06:10:41.191439211Z","created_by":"jason"}]}
{"id":"wc-81dd.7","content_hash":"ce71ef94065b62bd9e504b32b19ce12d3af5e30e8cbf8c1a8f10277530143943","title":"Repo configuration schema for eval targets","description":"Define the configuration schema for target repos. Fields: repo URL, clone settings, issue extraction method (github_issue|pr_body|commit_message|jira), issue URL pattern, commit filtering rules, language/toolchain, build/test commands, CLAUDE.md template. Create example configs for 2-3 target repos (e.g., Kubernetes, Prometheus).","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T06:11:43.048972962Z","updated_at":"2026-01-14T07:28:20.25412784Z","closed_at":"2026-01-14T07:28:20.25412784Z"}
{"id":"wc-81ed","content_hash":"f9432b1eba0387fee5d76af0e0cd262aa88468244bd055b996883049e88ed4a7","title":"Package command: support multiple package arguments","description":"Currently package command takes a single positional argument. Update to accept multiple packages:\n\n  wildcat package internal/golang internal/commands\n\nOptions:\n1. Multiple positional args - simple, matches other tools\n2. --scope flag - consistent with search/symbol/deadcode\n\nLeaning toward option 1 since package is about 'show me these packages' not 'filter results'. Each package gets its own section in output.\n\nAlso consider: should it accept patterns like 'internal/...'?","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-23T04:43:37.140807616Z","updated_at":"2026-01-23T05:03:06.606129651Z","closed_at":"2026-01-23T05:03:06.606129651Z"}
{"id":"wc-8227","content_hash":"fcd3597ad521705b577f608d2bfb46b15094b4da5ac432d28722f809e6bc803c","title":"Research: --include-tests flag behavior with commands.Wildcat","description":"Research how --include-tests should work with commands.Wildcat package loading.\n\n## Context\nThe package loader (packages.Config) has a Tests boolean that changes what gets loaded:\n- Tests=false: Just the regular packages\n- Tests=true: Loads additional test variants per package\n\nFrom go/packages docs, with Tests=true, loading \"fmt\" returns four packages:\n- \"fmt\" (standard package)\n- \"fmt [fmt.test]\" (package as compiled for the test)\n- \"fmt_test\" (test functions from package fmt_test)\n- \"fmt.test\" (the test binary)\n\n## Research Questions\n1. How does Tests=true affect commands.Wildcat and the loaded Project.Packages?\n2. What package variants appear and how are they identified?\n3. Should --include-tests be a load-time flag (affects what's in Wildcat) or filter-time (post-load)?\n4. How do the different test package types affect symbol indexing?\n5. What's the UX expectation - do users want to see test functions in tree output?\n\n## Deliverable\nDocument findings and propose implementation approach for consistent --include-tests across all commands.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-21T05:29:24.371206286Z","updated_at":"2026-01-26T04:51:00.984642408Z"}
{"id":"wc-82c4","content_hash":"b10b76d97539a4e8590b73b3aa1887204f9a4287bb243d6778a88cb5f00f39fb","title":"Deadcode command panics on some projects (SSA build panic)","description":"The deadcode command panics when analyzing some projects due to a bug in golang.org/x/tools/go/ssa when building SSA form. The panic occurs in the SSA builder with variadic/generic type handling. Need to add panic recovery to handle this gracefully.","status":"blocked","priority":1,"issue_type":"bug","created_at":"2026-01-21T14:26:19.406155547Z","updated_at":"2026-01-21T15:52:47.561297429Z"}
{"id":"wc-8404","content_hash":"56d28a1a9a15d9c52a3ddcee106bbdf6cc48179c807d2a2857ca83ec67ebf7b0","title":"deadcode: exclude interface method implementations from dead code","description":"## Problem\n\nMethods that implement interfaces are reported as dead even though removing them would break compilation.\n\nExample: `PackageCommand.README()` implements `Command[T].README()` but is reported dead because it's never called directly in our code.\n\n## Solution\n\nWhen checking if a method is dead, check if it implements an interface method. If the implementing type is used, interface methods are required and should not be reported as dead.\n\n## Implementation\n\nFor each method `T.Method()`:\n1. Check if type T implements any interface with method `Method()`\n2. If T is used (reachable or has refs), the interface method impl is live\n\nUse `types.Implements()` to check interface satisfaction.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-22T14:05:54.311344635Z","updated_at":"2026-01-22T14:15:34.873495504Z","closed_at":"2026-01-22T14:15:34.873495504Z"}
{"id":"wc-869c","content_hash":"303964cb69ff635d0f93c21397343f127b42548d1639decfce28729461c41b55","title":"Add wildcat bugreport command","description":"Command that opens a GitHub issue on the wildcat repo pre-seeded with:\n- System info (OS, Go version, wildcat version)\n- Relevant environment (GOEXPERIMENT, etc.)\n- Template with sections for: description, steps to reproduce, expected behavior, actual behavior\n- Optional: attach relevant command output or error messages\n\nCould use 'gh issue create' under the hood with --body flag.","status":"open","priority":4,"issue_type":"feature","created_at":"2026-01-21T14:40:37.64654147Z","updated_at":"2026-01-22T02:22:15.356594138Z"}
{"id":"wc-878e","content_hash":"f1d1a6ba7748aaa75654f50db520eac81ef5a9128c036222e3a4ebc3fed921e5","title":"Partition select cases from regular channel operations","description":"## Goal\nSeparate select statement channel operations from regular operations in the channels command output.\n\n## Completed Work\n1. Added SelectSends and SelectReceives fields to ChannelGroup struct (lines 50-51)\n2. Updated opInfo.kind comment to include select_send, select_receive (line 180)\n3. Rewrote processFile() with two-pass approach:\n   - First pass: detect select statements, extract channel ops from CommClause, mark as select_send/select_receive\n   - Second pass: collect non-select operations, skip nodes already handled\n   - Uses selectNodes map to track which AST nodes are part of select cases\n\n## Remaining Work\n1. Update buildPackages() switch statement to handle select_send and select_receive kinds (around line 418-420)\n   - Add: case \"select_send\": group.SelectSends = append(...)\n   - Add: case \"select_receive\": group.SelectReceives = append(...)\n2. Update summary counting in runChannels() to include select operations in TotalOps and ByKind\n3. Update renderChannelsMarkdown() to render SelectSends and SelectReceives sections\n\n## Note\nEdit tool was failing to match the switch statement text in buildPackages(). May need to rewrite that section fresh or debug the whitespace issue.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-16T05:36:39.854571954Z","updated_at":"2026-01-16T05:39:20.036283034Z","closed_at":"2026-01-16T05:39:20.036283034Z"}
{"id":"wc-879a","content_hash":"7ab1b5fcba7907ff3a3da6dffe1fab6ccae5a0300c3b36a4e7c6b7449baf4e83","title":"LSP daemon mode for persistent connections","description":"## Problem\nEach command spawns a fresh gopls instance. This is slow (~500ms+ startup) and wasteful. Running multiple commands in sequence pays this cost repeatedly.\n\n## Current Behavior\n- NewClient() starts gopls\n- Command runs\n- Client closes, gopls exits\n- Next command starts fresh\n\n## Proposed Solution\nImplement a daemon mode:\n\n1. **Daemon process**\n   - `wildcat daemon start` - starts background daemon\n   - `wildcat daemon stop` - stops daemon\n   - Daemon manages LSP connections per workspace\n\n2. **Connection pooling**\n   - Keep LSP connections alive between commands\n   - Reuse existing connection if same workspace\n   - Timeout idle connections after N minutes\n\n3. **Transparent fallback**\n   - If daemon not running, fall back to current behavior\n   - Commands work the same either way\n\n## Implementation Options\n- Unix socket for daemon communication\n- HTTP server on localhost\n- Simple PID file + named pipe\n\n## Files\n- cmd/daemon.go (new)\n- internal/daemon/daemon.go (new)\n- internal/daemon/client.go (new)\n\n## Acceptance Criteria\n- [ ] Daemon starts and manages LSP connections\n- [ ] Commands use daemon when available\n- [ ] Fallback works when daemon not running\n- [ ] Idle connection cleanup\n- [ ] `wildcat daemon status` shows state","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-10T05:59:13.535876204Z","updated_at":"2026-01-14T07:33:41.104930298Z","closed_at":"2026-01-14T07:33:41.104930298Z"}
{"id":"wc-87e7","content_hash":"d5faef20c146ddd407a4ec9eb0fb588ae82cf006d694a52bfaf20e2f16bf252c","title":"Language server configurations","description":"## Context\nWildcat needs to know how to start and configure different LSP servers for each language.\n\n## Scope\nCreate `internal/servers` package that:\n\n### 1. Server Detection\n- Detect language from file extension or explicit flag\n- Find server binary in PATH\n- Check server availability\n\n### 2. Per-Language Configurations\nSupport these servers initially:\n\n| Language | Server | Command | Notes |\n|----------|--------|---------|-------|\n| Go | gopls | `gopls serve` | Most tested |\n| Python | pyright | `pyright-langserver --stdio` | Fast, Microsoft |\n| TypeScript/JS | typescript-language-server | `typescript-language-server --stdio` | Requires tsserver |\n| Rust | rust-analyzer | `rust-analyzer` | Default stdio |\n| C/C++ | clangd | `clangd` | LLVM project |\n| Java | jdtls | complex setup | Eclipse-based |\n\n### 3. Configuration Options\n```go\ntype ServerSpec struct {\n    Language    string   // e.g., \"go\", \"python\"\n    Command     string   // binary name\n    Args        []string // startup args\n    InitOptions map[string]any // LSP initializationOptions\n    Capabilities []string // required capabilities we need\n}\n\n// Detect which server to use\nfunc DetectServer(filePath string) (*ServerSpec, error)\n\n// Check if server is available\nfunc (s *ServerSpec) Available() bool\n\n// Get server for language\nfunc GetServer(language string) (*ServerSpec, error)\n```\n\n### 4. Capability Verification\n- Check that server supports callHierarchy\n- Check for typeHierarchy support\n- Warn if features unavailable\n\n## Acceptance Criteria\n- [ ] gopls configuration works\n- [ ] At least 2 other language servers configured\n- [ ] Server detection by file extension\n- [ ] Availability check (binary exists)\n- [ ] Capability requirements documented\n- [ ] Easy to add new languages\n\n## Files\n- internal/servers/servers.go\n- internal/servers/detect.go\n- internal/servers/configs.go (per-language)\n- internal/servers/*_test.go\n\n## Depends On\n- wc-cb10 (LSP client infrastructure)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T04:57:14.995746828Z","updated_at":"2026-01-10T05:46:52.972235078Z","closed_at":"2026-01-10T05:46:52.972235078Z","dependencies":[{"issue_id":"wc-87e7","depends_on_id":"wc-cb10","type":"blocks","created_at":"2026-01-10T04:57:19.882078779Z","created_by":"jason"}]}
{"id":"wc-882a","content_hash":"3ae82c0dd49268497fbb64e870bd15b99da023cc7d8ef1dbc70c7f2cb2c44b81","title":"Use callers() instead of refs() for methods and functions","description":"For methods and functions in the symbol report, change from refs(N pkg, M proj, imported K) to callers(N pkg, M proj, imported K).\n\n'callers' is more semantically accurate for callable symbols - we're counting call sites, not just references.\n\nAffects:\n- Methods section\n- Constructors section\n- Any function symbols\n\nKeep refs() for types where it makes sense (type references vs calls).","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-22T06:42:37.88082624Z","updated_at":"2026-01-22T06:45:47.568995249Z","closed_at":"2026-01-22T06:45:47.568995249Z"}
{"id":"wc-8842","content_hash":"26c77c77f9eec8121a7add2577fbd1adaa2ccfa3e03370979ba7492fe088c6bb","title":"Reimplement MergeOverlappingResults for new Location/Snippet types","description":"MergeOverlappingResults was orphaned during command consolidation. It operated on old Result type but symbol command now uses Location/Snippet types.\n\nConcept is still valuable - merging adjacent snippets within same declaration scope. Needs rewrite for new types.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-16T08:42:20.903319424Z","updated_at":"2026-01-16T09:21:02.722888337Z","closed_at":"2026-01-16T09:21:02.722888337Z"}
{"id":"wc-8b81","content_hash":"d498934a9bb01def8bf8f46198f4f7732e460d4dc2fe11c1c4917273bc36712c","title":"Refactor ls helpers to golang package, precompute type kind","description":"Move reusable helpers from ls command to appropriate packages and precompute underlying type kind on Symbol.\n\n## Tasks\n\n1. Add `UnderlyingKind` field to `golang.Symbol` - precompute during symbol loading\n2. Add `Symbol.TypeKind()` method - returns precomputed kind\n3. Move `resolvePackage` to `Wildcat.ResolvePackage()`\n4. Update ls command to use new helpers\n\nValues for UnderlyingKind: struct, interface, map, slice, array, chan, pointer, func, alias, basic","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T08:59:18.726730401Z","updated_at":"2026-01-27T09:12:38.290845037Z","closed_at":"2026-01-27T09:12:38.290845037Z"}
{"id":"wc-8c03","content_hash":"20e7c53b6a0948eb5c164853460a9ff564bfe5cceda408d04936588873eff4e5","title":"ls command: support doublestar path expansion","description":"Add glob-like pattern matching to ls command paths.\n\nExample:\n```\n./wildcat ls 'commands/**/fields[Diagnostic]'\n```\n\nShould expand to all types in the commands package (and subpackages) that have a field named Diagnostic.\n\nPattern semantics:\n- `*` matches any single path segment (e.g., any symbol name)\n- `**` matches zero or more path segments\n- Can be used in package, symbol, or subpath positions\n\nUse cases:\n- Find all types with a specific field: `pkg/**/fields[Name]`\n- Find all methods with a specific param: `pkg/**/params[ctx]`\n- Find all symbols in subpackages: `internal/**/Symbol`\n\n## Implementation Approach (agreed)\n\n**Strategy:** Precompute all possible spaths and feed into doublestar.\n\n1. Add `EnumerateAllPaths()` to Wildcat that returns all paths in glob-friendly format\n   - Enumerate every package, symbol, and subpath recursively\n   - Use `/` as universal separator for globbing (normalize `pkg.Symbol` to `pkg/Symbol`)\n\n2. In ls command, detect if target contains wildcards (`*`, `**`, `?`, `[`)\n   - If so, enumerate all paths and filter with `doublestar.Match()`\n   - Convert matched paths back to canonical spath format for display\n\n3. Output formatting:\n   - Group results by package\n   - Show match counts per package and total\n   - Cap results (e.g., 100) but show total count\n\n**Path normalization:**\n- Current: `internal/golang.Symbol/fields[Name]` (mixed `.` and `/`)\n- For globbing: `internal/golang/Symbol/fields[Name]` (all `/`)\n- Display uses canonical form\n\n**Scale estimates:**\n- Wildcat: ~5,000-15,000 total paths\n- Large project (1000 pkgs, 50K symbols): ~500K-2M paths\n- Doublestar matching is fast enough for this","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-27T08:00:30.553154967Z","updated_at":"2026-01-28T04:46:22.187937947Z","closed_at":"2026-01-28T04:46:22.187937947Z"}
{"id":"wc-8d17","content_hash":"3fdb14c6ac980b63f6a266375206ccc96d98eb75976d186840297889f0a8d2d0","title":"Fix nil pointer panic in symbol markdown output","description":"MarshalMarkdown in symbol_response.go panicked when accessing Refs or Impls fields that could be nil.\n\nFixed by adding nil checks before accessing:\n- m.Refs for methods\n- c.Refs for constructors  \n- d.Refs for descendants\n- impl.Refs for implementations\n- sat.Impls for satisfies\n\nDiscovered when running: wildcat symbol orm.CrudOperator","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-22T07:51:12.535208971Z","updated_at":"2026-01-22T07:51:16.706216424Z","closed_at":"2026-01-22T07:51:16.706216424Z"}
{"id":"wc-8e5b","content_hash":"07dee70f59c9462925504f2e6bb84448dd8f78b0295e1798041541a3b77baf4e","title":"Investigate: fuzzy suggestions missing parent type","description":"When searching for 'model.Taska', suggestions show methods like 'model.Task.Tags' but not the type 'model.Task' itself. The type should rank higher than its methods for a query that closely matches the type name. May be a scoring issue in the fuzzy matcher or the base name search logic.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-22T05:17:55.172947247Z","updated_at":"2026-01-23T01:41:08.965400453Z","closed_at":"2026-01-23T01:41:08.965400453Z"}
{"id":"wc-8f59","content_hash":"d6d617a8e54f724edb38623b578af355c3fc0ce51744f5f5600a6e849b6a8b65","title":"ReceiverTypeName returns empty string for unrecognized expressions","description":"In format.go:100-126, ReceiverTypeName returns empty string when encountering unrecognized AST expression types:\n\nLocation: internal/golang/format.go:125\n\nPattern: default case returns '' without any indication\n\nImpact: Methods with unusual receiver syntax might have empty receiver type, causing incorrect symbol names or missed associations.\n\nOptions:\n- Return (string, error) indicating parse failure\n- Return special value like '\u003cunknown\u003e' that's visible in output\n- Log unrecognized receiver types\n- Accept as edge case (document which patterns are supported)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:53:21.404528612Z","updated_at":"2026-01-23T14:46:26.388731801Z","closed_at":"2026-01-23T14:46:26.388731801Z","dependencies":[{"issue_id":"wc-8f59","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:53:21.421470779Z","created_by":"jason"}]}
{"id":"wc-8fb9","content_hash":"b4197a9161979e28f9681d090e704b955f9a4fa2f4681557c5ad4bf9623fc338","title":"CLAUDE.md: Code patterns section is empty","description":"The '### Code patterns to follow' header at line 155 has no content under it. Either add the content back or remove the header.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-26T05:22:47.170908324Z","updated_at":"2026-01-26T12:37:27.024836392Z","closed_at":"2026-01-26T12:37:27.024836392Z"}
{"id":"wc-90a1","content_hash":"a65407551a9137a7a7a01da39c796b96b49d31deb2bf97fa0c4e031e03f4bb9b","title":"Migrate symbol command to Command[T] pattern","description":"Migrate cmd/symbol.go to internal/commands/symbol/ following the established pattern from tree, search, channels, and package commands.\n\n## Current State\n- symbol command still uses LSP client for all operations\n- Uses old output writer pattern (GetWriter)\n- Has global flags (symbolExcludeTests, symbolScope)\n- Relies on internal/traverse for caller analysis\n- Relies on internal/symbols for resolution\n\n## Migration Tasks\n1. Create internal/commands/symbol/symbol.go with SymbolCommand struct\n2. Create internal/commands/symbol/symbol_response.go with SymbolCommandResponse\n3. Implement functional options: WithSymbol, WithScope, WithExcludeTests\n4. Replace LSP operations with native implementations:\n   - Symbol resolution: use wc.Index.Lookup() instead of symbols.Resolver\n   - Callers: use golang.FindCallers() or similar (like tree command does)\n   - References: use golang type info for reference finding\n   - Implementations: use golang types.Implements checking\n   - Satisfies (supertypes): use golang types for interface checking\n5. Wire up in cmd/root.go\n6. Delete cmd/symbol.go after migration complete\n\n## Dependencies to Consider\n- May need to extend internal/golang/ with reference-finding utilities\n- Could leverage existing golang.FindFuncInfo() pattern from tree command\n- Similar scope filtering as search command\n\n## Output Format\nKeep existing output.SymbolResponse structure but move to symbol_response.go with Result interface implementation","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T06:32:05.979662249Z","updated_at":"2026-01-21T08:28:08.995045171Z","closed_at":"2026-01-21T08:28:08.995045171Z"}
{"id":"wc-90a1.1","content_hash":"2aed67e1f0e59244d1def03c89b2b239ddb6b8853a35f803a56b1513216b0faf","title":"Symbol: resolve scope package paths properly","description":"The scope filtering in symbol command uses strings.Contains for pattern matching. Need to resolve package paths using golang.ResolvePackagePath like the old cmd/symbol.go does, then compare against resolved paths.\n\nCurrent (wrong):\n```go\nif strings.Contains(pkg.Identifier.PkgPath, pattern) {\n    filter.includes[pkg.Identifier.PkgPath] = true\n}\n```\n\nShould resolve user input like 'lsp' to 'github.com/jasonmoo/wildcat/internal/lsp' first.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-21T06:51:49.212689229Z","updated_at":"2026-01-21T07:03:37.400943374Z","closed_at":"2026-01-21T07:03:37.400943374Z"}
{"id":"wc-90a1.2","content_hash":"d13cba80a2b6ee567c370300bbdaa22ea8422cd1db48ff2a1f6e36ac21ebc435","title":"Symbol: remove exclude-tests flag and logic","description":"There's a separate ticket (wc-8227) to address --include-tests behavior universally across commands. Don't implement exclude-tests in symbol command - remove the flag and all related logic.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-21T06:51:49.314067763Z","updated_at":"2026-01-21T07:00:39.760043179Z","closed_at":"2026-01-21T07:00:39.760043179Z"}
{"id":"wc-90a1.3","content_hash":"bc0ae1da657278a266999107df5d076ab047a061c0a4c81cb1295ca10b376972","title":"Symbol: remove InTests from summary counts","description":"Related to the universal --include-tests ticket. Remove InTests field from SymbolSummary and all logic that counts tests. This will be addressed separately.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-21T06:51:49.406153296Z","updated_at":"2026-01-21T07:01:39.291588643Z","closed_at":"2026-01-21T07:01:39.291588643Z"}
{"id":"wc-90a1.4","content_hash":"aa9d32cf94b58c8629778380cf0de671299d27b4bd55972d6cc2aa98389946b9","title":"Symbol: set default scope in constructor","description":"Instead of testing for empty scope throughout the code, set a sensible default in NewSymbolCommand() and trust it. Current code has checks like:\n\n```go\nif c.scope == \"package\" || c.scope == \"\" {\n```\n\nShould just set scope to \"project\" in constructor and remove empty checks.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-21T06:51:49.514193475Z","updated_at":"2026-01-21T06:57:46.900117006Z","closed_at":"2026-01-21T06:57:46.900117006Z"}
{"id":"wc-90a1.5","content_hash":"9cc62d5c0964ffb54107b4b028e8c7ac0ca7d5f9cab8764ba49666a5e0931a78","title":"Symbol: use SnippetExtractor for snippets","description":"Don't manually extract snippets from source. Use output.SnippetExtractor and its ExtractSmart() method which provides AST-aware snippet extraction with proper context.\n\nCurrent (wrong):\n```go\nfunc (c *SymbolCommand) extractSnippet(filename string, line int) output.Snippet {\n    content, err := os.ReadFile(filename)\n    // manual line slicing...\n}\n```\n\nShould:\n```go\nextractor := output.NewSnippetExtractor()\nsnippet, start, end, _ := extractor.ExtractSmart(file, line)\n```","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-21T06:51:49.625837819Z","updated_at":"2026-01-21T07:22:12.986841747Z","closed_at":"2026-01-21T07:22:12.986841747Z"}
{"id":"wc-90a1.6","content_hash":"0796943feea943c0bc352ade4922f5c06fee163cc378a78433990677a965fe68","title":"Symbol: reuse satisfies/implements logic from package command","description":"The package command (internal/commands/package/package.go:223-360) has well-tested logic for finding:\n- ImplementedBy: types that implement an interface\n- Satisfies: interfaces that a type implements\n\nThis includes:\n- Collecting interfaces from project packages + stdlib\n- Handling generic interfaces with type instantiation\n- Checking both T and *T\n- Handling builtin error interface\n\nReview if this logic can be:\n1. Extracted to internal/golang/ as reusable helpers\n2. Or inlined into symbol command following the same patterns\n\nKey patterns to preserve:\n- Use types.Implements(T, iface) and types.Implements(types.NewPointer(T), iface)\n- Skip empty interfaces\n- Handle generic interface instantiation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T06:51:49.728566727Z","updated_at":"2026-01-21T07:22:13.083185076Z","closed_at":"2026-01-21T07:22:13.083185076Z"}
{"id":"wc-9232","content_hash":"9e3487aeaa4063d8bd3918f60bfe099c3dee16b015543c9d4f186053e58de247","title":"Add wildcat comments command - search code comments","description":"Add a command to search code comments specifically. Features:\n- Search comment text with regex/substring matching\n- Package-scoped (limit to specific packages)\n- Could distinguish // vs /* */ vs doc comments\n- Useful for finding TODOs, FIXMEs, explanations\n- Returns file:line with matching comment text","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-15T08:45:53.232203702Z","updated_at":"2026-01-22T02:22:15.158179809Z","closed_at":"2026-01-22T02:22:15.158179809Z"}
{"id":"wc-9298","content_hash":"115789b52351368123262cb2b9eb50df1eadf36c3acf465297f23eaca4b21fcf","title":"Package command: show //go:embed directives","description":"Show `//go:embed` directives in the package command output.\n\n```go\n//go:embed templates/*\nvar templates embed.FS\n\n//go:embed version.txt\nvar version string\n\n//go:embed static/*.css static/*.js\nvar assets embed.FS\n```\n\n## Why This Matters\n\nEmbedded files are:\n- Compiled into the binary\n- Important for understanding what resources a package needs\n- Easy to miss when reviewing code\n\n## Proposed Output\n\nAdd an Embeds section:\n```\n# Embeds (3)\n//go:embed templates/*\nvar templates embed.FS // assets.go:12\n\n//go:embed version.txt  \nvar version string // version.go:8\n\n//go:embed static/*.css static/*.js\nvar assets embed.FS // assets.go:15\n```\n\n## Implementation\n\nLook for `//go:embed` comments attached to var declarations. The AST has `Doc` and `Comment` fields on declarations that contain these directives.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-23T01:24:12.358492993Z","updated_at":"2026-01-23T02:11:00.024045626Z","closed_at":"2026-01-23T02:11:00.024045626Z"}
{"id":"wc-9466","content_hash":"6ad424bce4bba453c1e4f0072b5277dcc6f8143adb5d739d45fdd8d704e08cb0","title":"Audit Go analysis ecosystem - packages and tools available","description":"## Context\nBefore building core infrastructure, we need a clear understanding of what the Go ecosystem provides. We want to leverage existing, battle-tested packages rather than reinventing. However, we will NOT shell out to external tools (gopls CLI, guru, etc.) - only use as libraries.\n\n## Goals\n1. Audit standard library analysis packages\n2. Audit golang.org/x/tools packages\n3. Identify any third-party packages worth considering\n4. Determine what we must build from scratch\n5. Document integration strategies\n\n## Scope\n\n### Standard Library (go/*)\nAudit these packages:\n- `go/ast` - AST representation and traversal\n- `go/parser` - parsing source files\n- `go/types` - type checking and type info\n- `go/token` - positions, file sets\n- `go/build` - build constraints, package discovery\n- `go/doc` - documentation extraction\n- `go/format` - source formatting\n- `go/printer` - AST printing\n- `go/scanner` - lexical scanning\n- `go/constant` - constant values\n\nFor each: What does it provide? How does it fit our needs?\n\n### golang.org/x/tools/go/*\nAudit these packages:\n- `go/packages` - modern package loading (replaces go/build)\n- `go/ssa` - SSA form construction\n- `go/ssa/ssautil` - SSA utilities\n- `go/callgraph` - call graph interface\n- `go/callgraph/cha` - Class Hierarchy Analysis\n- `go/callgraph/rta` - Rapid Type Analysis  \n- `go/callgraph/vta` - Variable Type Analysis\n- `go/callgraph/static` - static call graph\n- `go/types/typeutil` - type utilities\n- `go/ast/astutil` - AST utilities\n- `go/analysis` - analysis framework (used by go vet)\n- `go/pointer` - pointer analysis\n\nFor each: Capabilities, limitations, performance characteristics.\n\n### gopls Internal Packages\nCan we use any gopls internals as libraries?\n- `golang.org/x/tools/gopls/internal/...`\n- Check if any are importable/stable\n- Identify useful patterns even if not directly usable\n\n### Third-Party Options\nQuick survey of:\n- github.com/go-toolsmith/* - AST utilities\n- Any other notable analysis libraries\n\n## Deliverables\n\nCreate `docs/ecosystem-audit.md` with:\n\n1. **Package Matrix**\n   - Package name, what it does, our use case, notes\n\n2. **Build vs Leverage Decision**\n   - What we use directly\n   - What we wrap/extend\n   - What we build from scratch\n\n3. **Integration Strategy**\n   - Recommended package stack\n   - How packages compose together\n   - Example code patterns\n\n4. **Risk Assessment**\n   - API stability concerns\n   - Performance considerations\n   - Maintenance burden\n\n## Acceptance Criteria\n- [ ] All stdlib go/* packages documented\n- [ ] All x/tools/go/* packages documented\n- [ ] gopls internals assessed\n- [ ] Third-party options surveyed\n- [ ] Clear build vs leverage recommendations\n- [ ] Integration strategy documented\n- [ ] docs/ecosystem-audit.md complete\n\n## Why This Matters\nPer CLAUDE.md: \"Composability first\" and \"Simple over clever\". We want to build on solid foundations, not reinvent. This audit ensures we make informed decisions about our dependency stack.\n\n## Blocks\n- wc-af7d.1 (Package loading) - this research informs how we build it","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T04:07:19.863049002Z","updated_at":"2026-01-10T04:13:15.240751666Z","closed_at":"2026-01-10T04:13:15.240751666Z"}
{"id":"wc-9568","content_hash":"4d3803106f3fc527ed584867393e19b15146e1b8ffc1bd39f93c7ae594d05d0c","title":"package command renders full functions instead of signatures","description":"The package command is rendering full function bodies when it should only show signatures. This likely happened when FormatNode behavior changed or was misused. Need to ensure package command uses Format* (compact/stripped) not Render* (full source).","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-27T12:11:59.557948313Z","updated_at":"2026-01-27T12:31:19.227579917Z","closed_at":"2026-01-27T12:31:19.227579917Z"}
{"id":"wc-95dc","content_hash":"b9d34ea341c40a1c58f94de9eaf114d2df6f4a64e21935ffcb0d533ea62c0428","title":"findConsumers and findSatisfies silently return on nil type info","description":"In symbol.go, two more functions silently return when TypesInfo lookups fail:\n\n- Line 693: findConsumers returns nil when GetTypesObject fails\n- Line 1016: findSatisfies returns nil when TypesInfo.Defs lookup fails\n\nImpact: AI sees no consumers/satisfies results but doesn't know if analysis couldn't proceed.\n\nFix: Add diagnostics explaining why analysis couldn't proceed.\n\nSplit from wc-3c75.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T15:10:36.279112132Z","updated_at":"2026-01-24T02:54:40.823690151Z","closed_at":"2026-01-24T02:54:40.823690151Z"}
{"id":"wc-964f","content_hash":"445a3873c9fb47b97b50ae8fe9f5f57cc9e04f96a895ba6b0fe02a1330e18a59","title":"Symbol disambiguation when multiple matches exist","description":"## Problem\nWhen a symbol name matches multiple definitions (e.g., `Parse` exists in multiple packages), there's no clear way to disambiguate or see all options.\n\n## Current Behavior\n- Returns first match from workspace/symbol\n- No indication that multiple matches exist\n- User must guess the full qualified name\n\n## Proposed Solution\n1. Detect when multiple matches exist\n2. If ambiguous, return structured error with all options:\n```json\n{\n  \"error\": {\n    \"code\": \"ambiguous_symbol\",\n    \"message\": \"Symbol 'Parse' matches multiple definitions\",\n    \"candidates\": [\n      {\"symbol\": \"symbols.Parse\", \"file\": \"internal/symbols/parse.go\", \"line\": 24},\n      {\"symbol\": \"json.Parse\", \"file\": \"encoding/json/decode.go\", \"line\": 100}\n    ]\n  }\n}\n```\n3. Allow explicit selection via full path\n\n## Acceptance Criteria\n- [ ] Detect ambiguous symbols\n- [ ] Return all candidates in error response\n- [ ] Include file/line for each candidate\n- [ ] Works with `--first` flag to take first match (for scripting)","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-10T05:59:50.593400251Z","updated_at":"2026-01-15T14:46:34.937177209Z","closed_at":"2026-01-15T14:46:34.937177209Z"}
{"id":"wc-969f","content_hash":"361c513186fe618b7a3ca5776702cfcdf4d933c54d6a8e759fa53f0a633742e1","title":"Research: Project-wide analysis capabilities in Go tooling","description":"Research ticket to inform wc-2b6e (project command). Cataloging what project-wide\ninformation we can gather using Go packages and x/tools.\n\n## Go Standard Tooling\n\n### go list -json ./...\nPer-package info:\n- `ImportPath` - full import path\n- `Name` - package name\n- `Dir` - directory on disk\n- `GoFiles` - list of .go files\n- `Imports` - direct imports\n- `Deps` - transitive dependencies (all!)\n- `Doc` - package doc comment\n- `Module` - module info (path, version, dir)\n\n### go list -m -json all\nModule-level info:\n- `Path` - module path\n- `Version` - version\n- `Time` - publish time\n- `Indirect` - whether indirect dependency\n- `Dir` - local cache directory\n- `GoVersion` - minimum Go version\n\n### go mod edit -json\n- `Module.Path` - our module path\n- `Go` - Go version\n- `Require` - direct and indirect deps with versions\n- `Replace`, `Exclude`, `Retract` - module directives\n\n## x/tools Packages\n\n### go/packages (what we use now)\nCore loading infrastructure. LoadMode controls detail level:\n- NeedName, NeedFiles, NeedImports (fast)\n- NeedTypes, NeedSyntax (moderate)\n- NeedTypesInfo, NeedTypesSizes (full type checking)\n\nWe currently load with full type info for all analysis.\n\n### go/ssa\nSSA (Static Single Assignment) intermediate representation:\n- Function bodies decomposed into basic blocks\n- All control flow explicit (no if/for/switch - just jumps)\n- Enables precise dataflow analysis\n- We use this for deadcode analysis (via RTA)\n\n### go/callgraph\nCall graph algorithms:\n- `static` - direct calls only (fast, imprecise)\n- `cha` - Class Hierarchy Analysis (handles interfaces)\n- `rta` - Rapid Type Analysis (we use this for deadcode)\n- `vta` - Variable Type Analysis (most precise, slow)\n- `pointer` - points-to analysis (very precise, expensive)\n\n### go/analysis\nFramework for writing analyzers (like go vet):\n- Composable passes\n- Built-in passes: deadcode, unused, nilness, etc.\n- Could integrate existing passes for project health\n\n## Current Wildcat Approach Audit\n\n### What We Compute\n\n| Command | Scope | Data Source | Output Focus |\n|---------|-------|-------------|--------------|\n| package | single pkg | types, AST | symbols, godoc order |\n| symbol | single sym | refs, callgraph | who uses it, interfaces |\n| search | project | symbol index | fuzzy/regex matching |\n| tree | single func | SSA callgraph | up/down call chains |\n| channels | project | AST | channel operations |\n| deadcode | project | RTA | unreachable symbols |\n\n### Patterns We Follow\n\n1. **Symbol-centric**: Everything resolves to symbols with locations\n2. **Reference counting**: Internal vs external, package count\n3. **Interface awareness**: implements/satisfies relationships\n4. **Dual output**: JSON for machines, Markdown for humans\n5. **Scope filtering**: project/package/explicit includes/excludes\n\n### What We Don't Have (Project-Level)\n\n1. **Package topology**\n   - Which packages are \"hubs\" (many dependents)?\n   - Which are \"leaves\" (no dependents)?\n   - Dependency DAG visualization\n   - Cycle detection\n\n2. **Entry points**\n   - main packages\n   - Exported API surface\n   - Test entry points\n\n3. **Cross-package interfaces**\n   - Interfaces defined in one package, implemented in others\n   - Architectural contracts\n\n4. **Metrics aggregation**\n   - Total LOC, file count, symbol count\n   - Per-package breakdown with comparisons\n   - Complexity indicators\n\n5. **Import patterns**\n   - Which external deps are used where?\n   - Internal package coupling\n   - Import depth/breadth\n\n## What Project Command Could Provide\n\n### Essential (MVP)\n1. Package list with basic metrics (files, lines, symbols)\n2. Entry points (main packages)\n3. External dependencies summary\n4. Import graph (who imports whom internally)\n\n### Valuable (V1)\n1. \"Hub\" packages sorted by dependent count\n2. Cross-package interface contracts\n3. Package health indicators (dead code %, test coverage proxy)\n4. Visual histograms for quick scanning\n\n### Advanced (Future)\n1. Architectural layer detection\n2. Suggested refactoring targets\n3. Change impact estimation\n4. API surface stability metrics\n\n## My Opinions (Developer + Customer Perspective)\n\n### What I Want When I Ask \"Tell Me About This Project\"\n\n1. **Where does it start?** - Entry points, main packages\n2. **What's the architecture?** - Core packages, their relationships\n3. **What are the contracts?** - Cross-package interfaces\n4. **Where's the complexity?** - Hubs, large packages, high coupling\n5. **What are the dependencies?** - External, their purposes\n\n### Output Format Thoughts\n\nThe wc-2b6e spec suggests dual-bar histograms (methods vs dependents).\nThis is good for *comparison within a metric*. But:\n\n- AI agents benefit from **explicit anomaly markers** over raw visuals\n- Sorting by actionable metric (dependents) encodes priority\n- Thresholds (\"these 3 packages have \u003e50 dependents\") drive action\n\n**Recommendation**: Combine visual (gestalt) with explicit annotations.\nThe histogram shows shape; the annotations say what to do.\n\n### Implementation Approach\n\nCurrent `LoadWildcat` already loads all packages with full type info.\nWe have:\n- `Project.Packages` - all packages\n- `SymbolIndex` - all symbols indexed\n- SSA/callgraph available via `AnalyzeDeadCode`\n\nFor project command, we could:\n1. Compute dependency graph from existing Package.Imports\n2. Count dependents per package (reverse the graph)\n3. Find cross-package interfaces by checking implementations\n4. Aggregate metrics from existing symbol data\n\nMost of the data is already loaded - we just need to compute views.\n\n## Questions to Discuss\n\n1. Should project command reuse existing Wildcat load, or do a lighter load?\n2. How deep should the dependency graph go? (internal only? one level external?)\n3. Should we include test packages in the analysis?\n4. What's the right balance of detail vs brevity for AI consumption?\n5. Do we want pluggable \"health checks\" (like go/analysis passes)?","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-23T01:20:30.4383775Z","updated_at":"2026-01-26T07:27:30.102739253Z","closed_at":"2026-01-26T07:27:30.102739253Z","dependencies":[{"issue_id":"wc-969f","depends_on_id":"wc-2b6e","type":"blocks","created_at":"2026-01-23T01:20:30.455380097Z","created_by":"jason"}]}
{"id":"wc-9749","content_hash":"1ddac25314e609276354ae43caec48ef3549822eb097b1c7499dbbf89b6feb81","title":"Locations map loses info when symbol called from multiple places","description":"The locations map stores package.Name → file:line, but only keeps the first location seen. If a function is called from multiple places (or appears multiple times in paths), we lose the other call site locations. Need to either: store array of locations per symbol, or rethink how locations relate to paths.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-15T03:12:53.00581035Z","updated_at":"2026-01-15T04:54:34.710058154Z","closed_at":"2026-01-15T04:54:34.710058154Z","dependencies":[{"issue_id":"wc-9749","depends_on_id":"wc-f890","type":"blocks","created_at":"2026-01-15T03:12:53.013381099Z","created_by":"jason"}]}
{"id":"wc-9808","content_hash":"eb6a62808d21f6f45b0d6307f6732697a61b76bacaf68c51959afcd1bfe954d9","title":"Audit gopls symbol definitions for completeness","description":"Audit all symbol/type definitions that gopls supports to ensure our tool has complete coverage. This is a research task to identify any gaps.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T13:22:17.680201848Z","updated_at":"2026-01-11T13:24:48.298075241Z","closed_at":"2026-01-11T13:24:48.298075241Z"}
{"id":"wc-98ff","content_hash":"50505dca427a8e4064c9d72a1bee6da458fce9b5371e32bc470bbc574753ef0d","title":"Research gopls capabilities and produce full report","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:10:51.924627968Z","updated_at":"2026-01-10T03:20:08.274775099Z","closed_at":"2026-01-10T03:20:08.274775099Z"}
{"id":"wc-9a10","content_hash":"07856034fca0b97a3f4e1e6d80f936acdd4571ff519b52444e5ea61a7d6cac25","title":"Support multiple package targets in deadcode command","description":"Update the deadcode command to accept one or more packages as targets instead of just a single package.\n\nCurrent:\n```\nwildcat deadcode internal/lsp\n```\n\nDesired:\n```\nwildcat deadcode internal/lsp internal/symbols internal/traverse\n```\n\nChanges needed:\n1. Change `cobra.MaximumNArgs(1)` to `cobra.MinimumNArgs(0)`\n2. Update `target string` to `targets []string` in DeadcodeCommand\n3. Update Execute to filter by multiple package paths\n4. Update QueryInfo to show multiple targets","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-21T13:39:35.344104427Z","updated_at":"2026-01-21T13:41:05.365593803Z","closed_at":"2026-01-21T13:41:05.365593803Z"}
{"id":"wc-9a7a","content_hash":"8f9580ce5ec1fea4470384b1a6a8fd184cd2066ec05e0738dadb29547fec0a90","title":"Remove dot format support","description":"Dot/graphviz output format is not working with current commands. Remove DotFormatter from formatter.go and return unsupported format error when dot is requested. The formatter looked for old callers/callees command output structure that no longer exists.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-16T06:46:27.896815245Z","updated_at":"2026-01-16T06:49:37.159928268Z","closed_at":"2026-01-16T06:49:37.159928268Z"}
{"id":"wc-9a7f","content_hash":"68cbd763530a3297ea1890e02c69e91e161019a8ebba420de441b7d0bea03f74","title":"File operations silently skip on errors in embed size calculation","description":"In package.go calculateEmbedSize(), file operation errors are silently ignored:\n\nLocations:\n- package.go:519-522: filepath.Glob error -\u003e continue\n- package.go:526-529: os.Stat error -\u003e continue\n- package.go:533-546: WalkDir errors -\u003e return nil\n- package.go:541: d.Info() error -\u003e skip file silently\n\nImpact: Embed size calculations may be incomplete. AI sees a count/size but doesn't know some files couldn't be accessed.\n\nOptions:\n- Track errors and include in EmbedInfo response\n- Return error from calculateEmbedSize\n- Add 'errors' or 'incomplete' field to EmbedInfo","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:52:47.155767129Z","updated_at":"2026-01-23T14:44:40.568355969Z","closed_at":"2026-01-23T14:44:40.568355969Z","dependencies":[{"issue_id":"wc-9a7f","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:52:47.172068021Z","created_by":"jason"}]}
{"id":"wc-9ab6","content_hash":"8cb379fb530d1af40b2e6592cea2a11c0f28138f99466715ef3cf6caebba3ceb","title":"Impact command: transitive symbol discovery (--transitive flag)","description":"## Problem\nWhen removing or refactoring a symbol, developers need to manually discover coupled symbols through iterative exploration. Running `wildcat impact model.Task` shows direct references, but misses:\n- Symbols referenced BY the target (dependencies)\n- Symbols that reference types used by the target (transitive dependents)\n- The full \"blast radius\" of a change\n\n## User Story\n\u003e When I ran wildcat impact model.Task, I got direct references. But I had to manually realize:\n\u003e - model.ExportedTask also needs to go (it's coupled to Task)\n\u003e - TaskIdNamespace needs to go (Task uses it for ID generation)\n\u003e - DB.Task field needs to go (it stores ExportedTask)\n\u003e - GetTask, StoreTask, DeleteTask need to go (they operate on Task)\n\n## Solution\nAdd `--transitive` flag to impact command that recursively discovers:\n\n1. **Outgoing dependencies** - what the target symbol references/uses\n2. **Incoming references** - what references the target (existing behavior)\n3. **Transitive closure** - repeat for discovered symbols up to a depth\n\n### Proposed Output\n```\nwildcat impact --transitive model.Task\n\n{\n  \"query\": { \"command\": \"impact\", \"target\": \"model.Task\", \"transitive\": true },\n  \"target\": { ... },\n  \"symbols\": [\n    { \"symbol\": \"model.Task\", \"role\": \"target\", \"file\": \"...\", \"line\": ... },\n    { \"symbol\": \"model.ExportedTask\", \"role\": \"referenced_by_target\", \"reason\": \"field type in model.Task\" },\n    { \"symbol\": \"id.TaskIdNamespace\", \"role\": \"referenced_by_target\", \"reason\": \"used in model.Task.ID()\" },\n    { \"symbol\": \"DB.Task\", \"role\": \"references_target\", \"reason\": \"field of type model.ExportedTask\" },\n    { \"symbol\": \"DB.GetTask\", \"role\": \"references_target\", \"reason\": \"returns model.Task\" },\n    { \"symbol\": \"DB.StoreTask\", \"role\": \"references_target\", \"reason\": \"parameter model.Task\" },\n    { \"symbol\": \"DB.DeleteTask\", \"role\": \"transitive\", \"reason\": \"uses id.TaskIdNamespace\" }\n  ],\n  \"files\": [\n    { \"file\": \"database/model/task.go\", \"symbols\": 2, \"suggestion\": \"delete_file\" },\n    { \"file\": \"database/db_task.go\", \"symbols\": 3, \"suggestion\": \"delete_file\" },\n    { \"file\": \"database/db.go\", \"symbols\": 1, \"suggestion\": \"edit\" },\n    { \"file\": \"database/id/namespaces.go\", \"symbols\": 1, \"suggestion\": \"edit\" }\n  ],\n  \"summary\": {\n    \"total_symbols\": 7,\n    \"files_affected\": 4,\n    \"delete_files\": 2,\n    \"edit_files\": 2\n  }\n}\n```\n\n## Key Design Decisions\n\n### What counts as \"coupled\"?\n- Type references (field types, parameter types, return types)\n- Direct calls to methods\n- Constants/variables used by the symbol\n- NOT: symbols in same file but unrelated\n\n### Depth limiting\n- `--depth N` to control how many hops (default: 2?)\n- Prevent explosion on highly-connected symbols\n\n### File-level suggestions\n- If ALL symbols in a file are in the removal set → suggest \"delete_file\"\n- Otherwise → suggest \"edit\"\n\n### Role classification\n- `target` - the original query\n- `referenced_by_target` - symbols the target depends on\n- `references_target` - symbols that depend on target\n- `transitive` - discovered through multi-hop traversal\n\n## Implementation Approach\n1. Start with target symbol\n2. Get outgoing references (callees, type refs) - \"what does this use?\"\n3. Get incoming references (callers, refs) - \"what uses this?\"\n4. For each discovered symbol, repeat up to depth limit\n5. Dedupe and classify by role\n6. Group by file, determine file-level action\n\n## Files to Modify\n- `cmd/impact.go` - Add --transitive and --depth flags\n- `internal/output/types.go` - Add TransitiveImpactResponse\n- `internal/traverse/` - May need new traversal logic for outgoing deps\n\n## Acceptance Criteria\n- [ ] `wildcat impact --transitive model.Task` discovers coupled symbols\n- [ ] Symbols classified by role (target, referenced_by, references, transitive)\n- [ ] Files grouped with delete/edit suggestions\n- [ ] Depth limiting prevents runaway expansion\n- [ ] Standard (non-transitive) impact unchanged","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T08:20:09.273889177Z","updated_at":"2026-01-14T01:48:01.92375256Z","closed_at":"2026-01-14T01:48:01.92375256Z"}
{"id":"wc-9b79","content_hash":"aa7917d715af588d7df11668db732c8fd047069c907a9ae54c207aa7f462fb2c","title":"ls: include subpackages in output","description":"When listing a package with `wildcat ls`, include child packages in addition to symbols.\n\nCurrently `wildcat ls internal/commands` only shows top-level symbols in that package. It should also list subpackages like:\n- internal/commands/ls\n- internal/commands/search\n- internal/commands/symbol\n- etc.\n\nThis helps AI agents discover the full structure of a package namespace, not just its symbols.\n\nImplementation notes:\n- In listPackageSection(), enumerate child packages before/after symbols\n- Could use a new PathEntry kind like \"package\" or \"subpackage\"\n- Should respect the --depth flag for recursive subpackage listing","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-27T11:56:03.638114486Z","updated_at":"2026-01-27T12:43:26.59366578Z","closed_at":"2026-01-27T12:43:26.59366578Z"}
{"id":"wc-9b8c","content_hash":"ce8168f53a9e8aceed3a58e1abf6936849869d025a571ffcac7f4137c071ee67","title":"Document optimal AI-only output format findings","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:41:19.072348731Z","updated_at":"2026-01-10T03:52:06.902239952Z","closed_at":"2026-01-10T03:52:06.902239952Z","dependencies":[{"issue_id":"wc-9b8c","depends_on_id":"wc-4d61","type":"discovered-from","created_at":"2026-01-10T03:41:19.088255179Z","created_by":"jason"}]}
{"id":"wc-9bec","content_hash":"224b0be3b61f40d15108df269dec8b015ae61a4ee3eaf216f0402bfeda0f9025","title":"Tree: change scope to output filter with elision","description":"Change tree's --scope from traversal constraint to output filter, consistent with search/symbol/deadcode.\n\nCurrent behavior:\n- scope controls which calls to FOLLOW during traversal\n- out-of-scope calls are dead ends\n\nNew behavior:\n- Always traverse full call graph (within depth limit)\n- scope filters what's SHOWN in output\n- Use ParseScope for pattern support (internal/..., -excluded)\n- Elide out-of-scope intermediate nodes with '...'\n\nExample with --scope internal/commands:\n  main.Execute\n    commands.Run\n      ...                    // calls through internal/golang elided\n      commands.Format\n    commands.Validate\n\nImplementation:\n1. Replace custom scope enum with ParseScope\n2. Traverse full graph regardless of scope\n3. When rendering, elide consecutive out-of-scope nodes\n4. Show '...' with count or package hints\n\nThis gives consistent scope semantics across all commands.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-23T04:44:30.870509802Z","updated_at":"2026-01-23T04:57:19.920295879Z","closed_at":"2026-01-23T04:57:19.920295879Z"}
{"id":"wc-9c76","content_hash":"7bc35e17489f12c7cc238b3692cb54341e94f82e339bb0b53414fe7759a85345","title":"refactor: migrate root command to main.go and delete cmd folder","description":"Move cobra root command setup from cmd/root.go into main.go in project root. Delete the cmd/ folder after migration. Simplifies project structure.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-22T15:15:01.484107574Z","updated_at":"2026-01-22T15:21:14.53635183Z","closed_at":"2026-01-22T15:21:14.53635183Z"}
{"id":"wc-9ce5","content_hash":"87ceebf0279b905e1b0842ab6c4a8066f3d93e75a176f22102eab9ff0e44d7d7","title":"Write formal EBNF grammar for path syntax","description":"Write a complete, formal EBNF grammar for the path syntax that can guide implementation.\n\n**Prerequisites:**\n- wc-c565 (path spec research) - provides the analysis and design decisions\n\n**Deliverable:**\n- `docs/path-syntax-grammar.ebnf` - formal grammar file\n- Should be precise enough to drive parser implementation\n- Document canonical vs accepted forms\n- Include examples for each production\n\n**Design decisions to encode:**\n- Dots for methods only (one level: `pkg.Type.Method`)\n- Slashes for structural components (`/fields[]`, `/params[]`, etc.)\n- Brackets for selection (named or positional)\n- Accepted alternatives (e.g., `/methods[Name]` as alternative to `.Method` for interfaces)\n\n**Reference:**\n- docs/reference/go-constructs-analysis.md (analysis with draft grammar)\n- docs/reference/path-to-ast-mapping.md (implementation mapping)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-27T05:12:26.313139764Z","updated_at":"2026-01-27T05:14:47.960326428Z","closed_at":"2026-01-27T05:14:47.960326428Z"}
{"id":"wc-9e00","content_hash":"b489705e22405477856350b650613b1ff8f20d4f2adff45c05e788d421a05caf","title":"deadcode: investigate Response types in output/types.go marked as dead","description":"During dead code cleanup, noticed TreeResponse, SymbolResponse, SearchResponse, PackageResponse in internal/output/types.go are flagged as dead. These appear to be JSON response types. Need to verify: (1) are they actually unused, or (2) is this a false positive because deadcode doesn't trace JSON marshaling usage patterns. Example: types.go:76-83 TreeResponse, types.go:126-138 SymbolResponse","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-22T14:42:51.144552672Z","updated_at":"2026-01-22T14:44:18.319765382Z","closed_at":"2026-01-22T14:44:18.319765382Z"}
{"id":"wc-a09d","content_hash":"e335f9b5c1d3c00e4236d43261f3074fb98b0255a94f1251972eac1ae20819de","title":"Annotate dead files in deadcode output","description":"Detect and annotate when an entire file contains only dead code.\n\nIf all symbols in a file are dead, show:\n```\n## package github.com/jasonmoo/wildcat/internal/lsp\n\n### Dead Files\n- client.go (390 lines) - all 18 symbols dead\n```\n\nThis helps identify files that can be entirely deleted.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-21T13:32:12.338455036Z","updated_at":"2026-01-21T13:36:48.257889015Z","closed_at":"2026-01-21T13:36:48.257889015Z","dependencies":[{"issue_id":"wc-a09d","depends_on_id":"wc-033e","type":"blocks","created_at":"2026-01-21T13:32:21.358217721Z","created_by":"jason"}]}
{"id":"wc-a1ae","content_hash":"47018e32f230e600f6496d01639ab794216492d82092dd1b46b0a9486483d001","title":"Editing Commands: AST-aware editing for AI","description":"Research what editing commands could look like for AI agents.\n\nCurrent tools (like claude code's edit) use simple search-and-replace requiring unique string matches. Explore alternatives:\n\n- AST-aware editing that understands code structure\n- A DSL for editing operations\n- Using pointers/references from other command output\n- Making it batteries-included for AI workflows\n\nGoal: editing that's robust, precise, and naturally composable with other wildcat commands.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-15T08:36:39.171136102Z","updated_at":"2026-01-27T03:27:46.025220117Z","closed_at":"2026-01-27T03:27:46.025220117Z"}
{"id":"wc-a1ee","content_hash":"e5eaa9140e2487d34933b482a32274aac856b6167a7ef8a0aa0e8f949836ca55","title":"Build test to enumerate all paths in a package","description":"Create a test that parses a Go package and renders out the complete set of paths to all addressable symbols.\n\n**Purpose:** Exploratory - we want to see the full path vocabulary for a real package. This informs the path syntax design for the read/edit commands.\n\n**Test should:**\n1. Load a package (use one of wildcat's own packages, e.g., `internal/golang`)\n2. Walk all declarations\n3. Generate paths for every addressable element:\n   - Functions: `pkg.Func`, `pkg.Func/params[N]`, `pkg.Func/returns[N]`, `pkg.Func/body`\n   - Types: `pkg.Type`, `pkg.Type/fields/Name`, `pkg.Type/methods/Method`\n   - Methods: `pkg.Type.Method` (or alternative syntax)\n   - Vars/Consts: `pkg.Var`, `pkg.Const`\n   - Interfaces: `pkg.Interface`, `pkg.Interface/methods/Method`\n4. Print all paths in a structured format\n5. Note any edge cases or ambiguities discovered\n\n**Output example:**\n```\ngolang.Project\ngolang.Project/fields/Root\ngolang.Project/fields/Module  \ngolang.Project/methods/Load\ngolang.Project.Load/params[0]\ngolang.Project.Load/params[1]\ngolang.Project.Load/body\n...\n```\n\n**Goal:** Understand the shape of the path space before implementing read/edit. Surface any design questions about path syntax.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-26T10:21:51.93419532Z","updated_at":"2026-01-26T10:43:12.530352969Z","closed_at":"2026-01-26T10:43:12.530352969Z"}
{"id":"wc-a307","content_hash":"c0e0f6fc6945531fe894e203f80de2edf0da749fae02838ad76c154393e63f4a","title":"Add snippets to impact command output","description":"Enhance the impact command to include code snippets in its output for better context","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-11T12:42:11.094124271Z","updated_at":"2026-01-11T13:09:15.742313863Z","closed_at":"2026-01-11T13:09:15.742313863Z"}
{"id":"wc-a3b2","content_hash":"0314d63f9ad3bc73868a87e5af2be66c0ccc4dc81644b5dcbde7cf3be805b3b5","title":"imported_by shows package imports, not symbol imports","description":"In the symbol command, imported_by currently shows all packages that import the target symbol's package. It should only show packages that actually import/use the symbol itself.\n\nExample: 'wildcat symbol lsp.Client' shows all packages importing the lsp package, but should only show packages that actually reference lsp.Client.\n\nThis is misleading because a package might import lsp for other symbols without ever using Client.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-18T05:20:08.83477149Z","updated_at":"2026-01-18T05:24:46.697886332Z","closed_at":"2026-01-18T05:24:46.697886332Z"}
{"id":"wc-a665","content_hash":"5abd9edd068ca7275984538d1f7717529c46cb604a6ebb57df607c6914de822a","title":"interfaces.go silently skips types with nil type info","description":"In interfaces.go, multiple locations silently skip when TypesInfo lookups fail:\n\n- Lines 48-49: obj == nil continues\n- Lines 73-74: obj == nil continues  \n- Lines 123-124: tobj == nil continues\n\nImpact: Interface satisfaction checks are incomplete without indication.\n\n**Consider first:** Could these use TypesInfo iteration instead of AST walking?\n- TypesInfo.Defs contains all type definitions with type info\n- Iterating TypesInfo directly eliminates nil checks\n- See findImplementations refactor (wc-d4a4) for the pattern.\n\nIf TypesInfo iteration doesn't fit, fall back to:\n- Track skipped types/checks\n- Add appropriate diagnostics\n\nSplit from wc-3c75.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T15:10:10.704478711Z","updated_at":"2026-01-26T04:15:18.276886619Z","closed_at":"2026-01-26T04:15:18.276886619Z","dependencies":[{"issue_id":"wc-a665","depends_on_id":"wc-e649","type":"blocks","created_at":"2026-01-24T11:16:15.706529742Z","created_by":"jason"}]}
{"id":"wc-aa86","content_hash":"6cc54d17d6fe2931d91a50466ca39704e2711f6b22a5d98bff4804bbba508360","title":"Add command-layer tests","description":"## Problem\nNo tests for the cmd layer. All commands are untested at the integration level.\n\n## Current State\n```\n?   github.com/jasonmoo/wildcat/cmd  [no test files]\n```\n\n## Scope\nAdd integration tests for each command:\n- callers\n- callees  \n- tree\n- refs\n- impact\n- formats\n\n## Approach\n1. Use testdata directory with sample Go files\n2. Start real gopls for integration tests\n3. Test both success and error paths\n4. Verify JSON output structure\n\n## Test Cases per Command\n- Valid symbol resolves correctly\n- Invalid symbol returns error with suggestions\n- Flags work (--compact, --depth, --exclude-tests, etc.)\n- Output format is correct JSON structure\n\n## Files\n- cmd/callers_test.go\n- cmd/callees_test.go\n- cmd/tree_test.go\n- cmd/refs_test.go\n- cmd/impact_test.go\n- testdata/*.go (sample files)\n\n## Acceptance Criteria\n- [ ] Each command has at least 3 test cases\n- [ ] Tests use real LSP (gopls)\n- [ ] Error paths tested\n- [ ] Flag behavior tested","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-10T05:59:38.328699463Z","updated_at":"2026-01-14T07:33:41.217394711Z","closed_at":"2026-01-14T07:33:41.217394711Z"}
{"id":"wc-ab2c","content_hash":"509b4bcf46e095a437a8f5c5f44b773d9e0b44a55ea80130dfd997bb576fa4e4","title":"Rework tree command to use golang.Symbol instead of raw AST","description":"The tree command currently works directly with AST nodes (FuncDecl, etc.) and builds names via string concatenation:\n\n```go\n// tree.go:318\nSymbol: targetPkg.Identifier.Name + \".\" + targetFn.Name.Name,\n\n// tree.go:437\nname = info.Receiver + \".\" + name\n\n// tree.go:439  \nkey := info.Pkg.Identifier.PkgPath + \".\" + name\n\n// tree.go:463\nsym := cf.pkgIdent.Name + \".\" + cf.name\n```\n\n## Proposal\n\nRework the tree walking logic to look up or create golang.Symbol objects instead of working with raw AST. This would:\n\n1. Give access to Symbol helpers (PkgSymbol, PkgPathSymbol, PkgTypeSymbol, etc.)\n2. Provide access to precomputed data (Satisfies, ImplementedBy, Consumers, Descendants)\n3. Ensure consistent naming across the codebase\n4. Reduce duplication of name-building logic\n\n## Exploration needed\n\n- How does WalkCalls currently work? Does it have access to Symbols?\n- Can we look up Symbols from FuncDecl efficiently?\n- What's the performance impact of Symbol lookup during tree walking?\n- Should FuncInfo hold a Symbol reference instead of raw AST data?","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T02:24:19.051145727Z","updated_at":"2026-01-26T02:51:32.163242501Z","closed_at":"2026-01-26T02:51:32.163242501Z"}
{"id":"wc-abcf","content_hash":"8b2bf5cdc2fc5cae167fbc218be204ea64fcff2abd7d26aaad4dd86f26629405","title":"Add paths command for path discovery","description":"Create a command that lists available paths within a given scope. This is the discovery mechanism for the path-based read command.\n\n**Naming:** Consider `ls` (filesystem analogy) or `paths`. Could support both as aliases.\n\n- `ls` - short, familiar, matches the filesystem mental model\n- `paths` - explicit, self-documenting\n\n**Usage:**\n```bash\nwildcat ls golang                    # all paths in package\nwildcat ls golang.Symbol             # paths within a type (fields, methods)\nwildcat ls golang.WalkReferences     # paths within a function (params, returns, body)\nwildcat ls golang.Symbol.String      # paths within a method\n```\n\n**Output:**\nLists paths without source code - just the paths themselves:\n```\ngolang.Symbol\ngolang.Symbol.Name\ngolang.Symbol.Kind\ngolang.Symbol.Object\ngolang.Symbol[0]\ngolang.Symbol[1]\ngolang.Symbol[2]\ngolang.Symbol.String\ngolang.Symbol.String/body\ngolang.Symbol.String/returns[0]\n...\n```\n\n**Scope behavior:**\n- Package path → all symbols and their sub-paths\n- Type → fields (dot notation), methods (dot notation), positional access\n- Function/Method → /body, /params[N], /params[name], /returns[N], /returns[name]\n- Field/Const/Var → just the path itself (leaf nodes)\n\n**Purpose:**\n1. Discovery tool - find what paths are available before using `read`\n2. Complements path annotations in other command outputs\n3. Helps AI learn the path vocabulary for a codebase\n\n**Filesystem analogy:**\n- `ls` - list paths (this command)\n- `read` / `cat` - show contents\n- `edit` - modify contents\n\n**Related:**\n- docs/path-syntax.md - documents the syntax\n- wc-10a8 - read command that consumes these paths\n- wc-2eea - field resolution (needed for Type.Field paths)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-26T12:28:00.661797586Z","updated_at":"2026-01-27T09:16:42.722970249Z","closed_at":"2026-01-27T09:16:42.722970249Z"}
{"id":"wc-ae07","content_hash":"ebf99997dc4c7fef4225e0df3196c05b62c6dac4e3c7fa3e024013c3c7fe2492","title":"Audit go list usage - consider build.Import","description":"## Context\nDuring the channels command work, we discovered that `build.Import` provides much of what we need for package resolution without shelling out to `go list`.\n\n## Files using go list\n- `cmd/deps.go:41-85` - goListPackage struct, go list -json\n- `cmd/package.go:75-81` - package info via go list\n\n## Investigation needed\n1. What info does each call to `go list` provide?\n2. Can `build.Import` or `build.Package` provide the same?\n3. What are the trade-offs (performance, accuracy, module-awareness)?\n\n## Benefits of build.Import\n- No subprocess spawn\n- Direct Go API\n- Already used in ResolvePackagePath\n\n## Considerations\n- `go list` may provide module info that build.Import doesn't\n- Need to verify feature parity before replacing","status":"closed","priority":3,"issue_type":"chore","created_at":"2026-01-16T02:52:21.567552491Z","updated_at":"2026-01-16T07:02:03.568463544Z","closed_at":"2026-01-16T07:02:03.568463544Z"}
{"id":"wc-ae41","content_hash":"f271161ab62b3bc37ad90bfe70537b54796653f176ad66160453afeebc2e4f14","title":"read command: support reading type with all methods","description":"Add ability to read a type and all its methods in one shot.\n\nUse case: \"show me parser and all its methods\"\n\nCurrently requires multiple commands:\n```\nwildcat read spath.parser\nwildcat read spath.parser.parse\nwildcat read spath.parser.parseSymbol\nwildcat read spath.parser.parseSubpath\nwildcat read spath.parser.findPackageSymbolBoundary\n```\n\nOptions:\n1. Flag like `--with-methods` on read\n2. Special path syntax like `spath.parser.*` or `spath.parser/methods`\n3. Depth flag that includes children\n\nThis would significantly improve the \"understand a type\" workflow.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-27T14:24:59.891436984Z","updated_at":"2026-01-28T05:18:58.30538084Z","closed_at":"2026-01-28T05:18:58.30538084Z"}
{"id":"wc-ae8e","content_hash":"67ecbc2f110277f984762b814a3424a1ebee9770ad1a2597546d430430e02b94","title":"Explore using PackageSymbol in search/SymbolIndex","description":"Currently search.go has its own Symbol type. Now that PackageSymbol has precomputed information (signature, location methods, methods, constructors), we should explore whether SymbolIndex can use PackageSymbol directly instead of maintaining a separate Symbol type. This would unify the abstractions and avoid duplicating information.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T06:55:04.622440464Z","updated_at":"2026-01-25T13:59:53.501584891Z","closed_at":"2026-01-25T13:59:53.501584891Z"}
{"id":"wc-aeb7","content_hash":"52bc9663c45f32629ecff3f005bf25fca8814aec7065276c041894dad907b065","title":"Add rename command for cross-file symbol renaming","description":"Add a `rename` command that renames a symbol and updates all references.\n\n**Usage:**\n```bash\nwildcat rename golang.OldName NewName\nwildcat rename golang.Symbol.OldField NewField\nwildcat rename golang.Func/params[old] new\n```\n\n**From semantic-feedback.md:**\n\u003e Today I run `wildcat symbol`, get all references, then do N separate string-replace edits hoping each is unique. With paths, one command could rename the symbol at all reference sites.\n\n**Scope:**\n- Rename types, functions, methods, fields, parameters, return values\n- Update all references in the project\n- Handle import aliases if package-qualified references change\n\n**Implementation options:**\n1. Use gopls rename (LSP-based, proven)\n2. Build our own using type info from go/types\n3. Hybrid: use gopls for heavy lifting, wildcat for UX\n\n**Considerations:**\n- Atomic operation (all-or-nothing)\n- Preview mode (show what would change)\n- Conflict detection (name already exists)\n\n**See:** docs/semantic-feedback.md section on \"What Would Make This Transformative\"","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-26T13:43:36.267377085Z","updated_at":"2026-01-26T13:43:36.267377085Z"}
{"id":"wc-af4f","content_hash":"66fdb0f031d975bb5d6ade9802164b16e6ea598a478ca4ad5cd53a22c2ab73c5","title":"Document search output kind field","description":"Search output includes a useful kind field that's not documented:\n\n{\"symbol\": \"config\", \"kind\": \"struct\", \"location\": \"main.go:22\"}\n\nThis could help with filtering results.","status":"closed","priority":3,"issue_type":"chore","created_at":"2026-01-18T05:47:12.565510372Z","updated_at":"2026-01-18T06:08:32.090152871Z","closed_at":"2026-01-18T06:08:32.090152871Z"}
{"id":"wc-af7d","content_hash":"0b892bebda8181a87c6fa0d1780d23f6be2d3fce07a06752ca09e6ba78e1cc7a","title":"Wildcat MVP Implementation","description":"## Overview\nComplete implementation of Wildcat - **language-agnostic** static analysis CLI for AI agents.\n\n## ARCHITECTURE PIVOT (wc-d974)\nFollowing LSP feasibility research, Wildcat now uses an **LSP-based architecture**:\n- Works with any language that has an LSP server (Go, Python, TypeScript, Rust, C++, Java)\n- Wildcat acts as an **LSP orchestrator** - making multiple calls, handling recursion, extracting snippets\n- Language-agnostic support with consistent JSON output\n\n## Goals\n1. Build LSP client infrastructure for communicating with language servers\n2. Create orchestration layer for symbol lookup, recursive traversal, snippet extraction\n3. Implement MVP commands: callers, callees, tree, refs, impact\n4. Deliver JSON output optimized for AI tool integration\n\n## Success Criteria\n- All MVP commands functional with JSON output\n- Symbol-based queries work (pkg.Func, Type.Method)\n- Error responses include suggestions for self-correction\n- Snippets and absolute paths in all results\n- Works with gopls (Go) and at least one other language server\n\n## Architecture Layers\n1. **LSP Infrastructure**: LSP client, server configs, JSON-RPC over stdio\n2. **Orchestration**: Symbol lookup, recursive traversal, snippet extraction\n3. **Output Formatting**: JSON types, snippets, error handling\n4. **Commands**: callers, callees, tree, refs, impact\n\n## Key Tickets\n- wc-cb10: LSP client infrastructure\n- wc-87e7: Language server configurations\n- wc-099e: Orchestration layer\n- wc-af7d.4: Output formatting\n- wc-af7d.5: Error handling\n- wc-af7d.6-10: MVP commands\n\n## Reference\n- docs/lsp-feasibility.md - LSP architecture decision\n- docs/product-design.md - detailed specs\n- docs/gopls-report.md - gap analysis showing why we're building this","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-10T03:55:31.122462659Z","updated_at":"2026-01-10T06:58:24.780619118Z","closed_at":"2026-01-10T06:58:24.780619118Z"}
{"id":"wc-af7d.1","content_hash":"51b1cd0e9572d22c4ed8c2ce8d9da1c2f08d826ad0500bc4b6d1d67e8627245f","title":"Package loading infrastructure","description":"## Context\nFoundation for all Wildcat analysis. Must load Go packages with full type information.\n\n## Scope\nCreate `internal/loader` package that:\n\n1. **Load packages using golang.org/x/tools/go/packages**\n   - Configure with LoadAllSyntax mode for full type info\n   - Handle module discovery from current directory\n   - Support loading specific packages or patterns (./...)\n\n2. **Scope control**\n   - Module only (default): packages in current go.mod\n   - Direct deps: module + direct dependencies\n   - All deps: full transitive closure\n   - Implement via LoadMode flags\n\n3. **Error handling**\n   - Wrap package load errors with context\n   - Detect and report parse errors in source\n   - Return structured errors for missing packages\n\n## Interface Design\n```go\ntype Loader interface {\n    // Load packages matching patterns\n    Load(patterns ...string) ([]*packages.Package, error)\n    \n    // LoadAll loads all packages in current module\n    LoadAll() ([]*packages.Package, error)\n}\n\ntype Config struct {\n    Dir           string    // Working directory\n    IncludeDeps   bool      // Include direct dependencies\n    IncludeAllDeps bool     // Include transitive dependencies\n    BuildFlags    []string  // Build flags (-tags, etc.)\n}\n```\n\n## Acceptance Criteria\n- [ ] Load single package by path\n- [ ] Load all packages in module with ./...\n- [ ] Scope control works (module/deps/all)\n- [ ] Type information available (pkg.TypesInfo)\n- [ ] Syntax trees available (pkg.Syntax)\n- [ ] Errors include file/line for parse errors\n- [ ] Unit tests with test fixtures\n\n## Files\n- internal/loader/loader.go\n- internal/loader/loader_test.go\n\n## Dependencies\n- golang.org/x/tools/go/packages","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:55:45.60224243Z","updated_at":"2026-01-10T04:58:06.569743063Z","closed_at":"2026-01-10T04:58:06.569743063Z","dependencies":[{"issue_id":"wc-af7d.1","depends_on_id":"wc-9466","type":"blocks","created_at":"2026-01-10T04:07:39.885626658Z","created_by":"jason"},{"issue_id":"wc-af7d.1","depends_on_id":"wc-d974","type":"blocks","created_at":"2026-01-10T04:17:08.191125365Z","created_by":"jason"}]}
{"id":"wc-af7d.10","content_hash":"81b8a1fdd6f58e7b09e63c965e9782f00310da87d4978bb8f4f6e1220b819fb3","title":"Implement impact command","description":"## Context\nComprehensive impact analysis: everything affected by changing a symbol. Combines callers, refs, and package analysis into one query.\n\n## Scope\nCreate `cmd/impact.go` that:\n\n1. **Accept symbol argument**\n   - Parse and resolve symbol\n   - Determine symbol kind (function, type, method, etc.)\n\n2. **Gather all impacts**\n   - Transitive callers (recursive, not just direct)\n   - All references (using refs logic)\n   - Interface implementations (if symbol is interface method)\n   - Dependent packages (packages importing this package)\n\n3. **Categorize by impact type**\n   - callers: code paths that invoke this\n   - references: type/value usages\n   - implementations: types implementing interface\n   - dependents: packages that import this package\n\n4. **Include reason field**\n   - \"parameter type\", \"return type\", \"variable declaration\"\n   - \"method call\", \"function call\", \"interface implementation\"\n\n## CLI Design\n```\nwildcat impact \u003csymbol\u003e [flags]\n\nFlags:\n  --exclude-tests     Exclude test files\n  --depth int         Max depth for transitive callers (default unlimited)\n  --include-deps      Include impact in dependencies\n```\n\n## Output Example\n```json\n{\n  \"query\": {\n    \"command\": \"impact\",\n    \"target\": \"config.Config\",\n    \"resolved\": \"github.com/user/proj/internal/config.Config\"\n  },\n  \"target\": {\n    \"symbol\": \"config.Config\",\n    \"kind\": \"type\",\n    \"file\": \"/path/to/config/config.go\",\n    \"line\": 10\n  },\n  \"impact\": {\n    \"callers\": [...],\n    \"references\": [...],\n    \"implementations\": [...],\n    \"dependents\": [...]\n  },\n  \"summary\": {\n    \"total_locations\": 12,\n    \"callers\": 5,\n    \"references\": 4,\n    \"implementations\": 0,\n    \"dependent_packages\": 3,\n    \"in_tests\": 2\n  }\n}\n```\n\n## Implementation Notes\n- Reuse callers logic for transitive call analysis\n- Reuse refs logic for reference finding\n- Add new logic for interface implementations\n- Add package dependency analysis\n\n## Acceptance Criteria\n- [ ] Find transitive callers\n- [ ] Find all references\n- [ ] Find interface implementations (if applicable)\n- [ ] Find dependent packages\n- [ ] Include reason for each impact\n- [ ] Categorized output structure\n- [ ] Summary with counts by category\n- [ ] --depth limits caller traversal\n- [ ] Integration test with type change scenario\n\n## Files\n- cmd/impact.go\n- cmd/impact_test.go\n- internal/analysis/implementations.go (new)\n- internal/analysis/dependents.go (new)\n\n## Depends On\n- wc-af7d.6 (callers - for transitive caller analysis)\n- wc-af7d.9 (refs - for reference finding)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T04:01:19.097775621Z","updated_at":"2026-01-10T05:43:52.665542565Z","closed_at":"2026-01-10T05:43:52.665542565Z","dependencies":[{"issue_id":"wc-af7d.10","depends_on_id":"wc-af7d.6","type":"blocks","created_at":"2026-01-10T04:01:19.101626429Z","created_by":"jason"},{"issue_id":"wc-af7d.10","depends_on_id":"wc-af7d.9","type":"blocks","created_at":"2026-01-10T04:01:19.105780902Z","created_by":"jason"}]}
{"id":"wc-af7d.11","content_hash":"b8769550ac8d16c85e10320db08e5643d5fd5ea8b2f9ea954a871d5563c38053","title":"Implement implements command","description":"## Context\nFind all types implementing an interface. Useful for understanding polymorphism and finding concrete implementations.\n\n## Scope\nCreate `cmd/implements.go` that:\n\n1. **Accept interface type argument**\n   - Parse as Type (must be interface)\n   - Resolve to types.Interface\n\n2. **Find implementations**\n   - Scan all types in scope\n   - Check method sets for interface satisfaction\n   - Include pointer and non-pointer receivers\n\n3. **Format output**\n   - List of implementing types with locations\n   - Include method coverage info\n\n## CLI Design\n```\nwildcat implements \u003cinterface\u003e [flags]\n\nFlags:\n  --package string   Limit to package pattern\n  --include-deps     Include types in dependencies\n```\n\n## Output Example\n```json\n{\n  \"interface\": \"io.Reader\",\n  \"implementations\": [\n    {\n      \"type\": \"*bytes.Buffer\",\n      \"package\": \"bytes\",\n      \"file\": \"/path/to/file.go\",\n      \"line\": 45\n    }\n  ]\n}\n```\n\n## Acceptance Criteria\n- [ ] Resolve interface type\n- [ ] Find all implementing types in module\n- [ ] Handle pointer vs value receivers\n- [ ] Output with type locations\n- [ ] --include-deps expands scope\n\n## Files\n- cmd/implements.go\n- cmd/implements_test.go\n\n## Priority\nMedium (P2) - Future command, not MVP","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T04:01:32.786601328Z","updated_at":"2026-01-10T06:06:03.411423558Z","closed_at":"2026-01-10T06:06:03.411423558Z","dependencies":[{"issue_id":"wc-af7d.11","depends_on_id":"wc-af7d.2","type":"blocks","created_at":"2026-01-10T04:01:32.79092761Z","created_by":"jason"},{"issue_id":"wc-af7d.11","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T04:01:32.79440973Z","created_by":"jason"}]}
{"id":"wc-af7d.12","content_hash":"7c5d82d0080b12cf98e2e6cb93a101491154571155654ab3eadc0e90fda8b2a5","title":"Implement satisfies command","description":"## Context\nFind all interfaces a type satisfies. Inverse of implements command.\n\n## Scope\nCreate `cmd/satisfies.go` that:\n\n1. **Accept type argument**\n   - Parse as Type (concrete type)\n   - Resolve to types.Named or types.Pointer\n\n2. **Find satisfied interfaces**\n   - Scan all interfaces in scope\n   - Check if type's method set satisfies each interface\n   - Include standard library interfaces\n\n3. **Format output**\n   - List of interfaces with locations\n\n## CLI Design\n```\nwildcat satisfies \u003ctype\u003e [flags]\n\nFlags:\n  --include-stdlib   Include standard library interfaces\n  --package string   Limit interface search to pattern\n```\n\n## Output Example\n```json\n{\n  \"type\": \"*Server\",\n  \"satisfies\": [\n    {\n      \"interface\": \"io.Closer\",\n      \"package\": \"io\",\n      \"methods\": [\"Close\"]\n    },\n    {\n      \"interface\": \"http.Handler\",\n      \"package\": \"net/http\",\n      \"methods\": [\"ServeHTTP\"]\n    }\n  ]\n}\n```\n\n## Acceptance Criteria\n- [ ] Resolve concrete type\n- [ ] Find all satisfied interfaces\n- [ ] Include method list for each interface\n- [ ] --include-stdlib for standard library\n\n## Files\n- cmd/satisfies.go\n- cmd/satisfies_test.go\n\n## Priority\nMedium (P2) - Future command, not MVP","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T04:01:42.359231713Z","updated_at":"2026-01-10T06:07:45.342709635Z","closed_at":"2026-01-10T06:07:45.342709635Z","dependencies":[{"issue_id":"wc-af7d.12","depends_on_id":"wc-af7d.2","type":"blocks","created_at":"2026-01-10T04:01:42.363074538Z","created_by":"jason"},{"issue_id":"wc-af7d.12","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T04:01:42.367227556Z","created_by":"jason"}]}
{"id":"wc-af7d.13","content_hash":"c81cbf89da3068295980424ee5bd7dd57fab9b5c5f4b7acc40c6131c2084eef0","title":"Implement deps command","description":"## Context\nPackage dependency graph. Show what a package imports or what imports it.\n\n## Scope\nCreate `cmd/deps.go` that:\n\n1. **Accept package path argument**\n   - Resolve package path\n   - Handle relative paths (./internal/server)\n\n2. **Two modes**\n   - Forward (default): what does this package import?\n   - Reverse (--reverse): what packages import this?\n\n3. **Format output**\n   - List of packages with import locations\n\n## CLI Design\n```\nwildcat deps \u003cpackage\u003e [flags]\n\nFlags:\n  --reverse        What imports this package (default: what it imports)\n  --depth int      Transitive depth (default 1, direct only)\n  --exclude-stdlib Exclude standard library\n```\n\n## Output Example\n```json\n{\n  \"package\": \"github.com/user/proj/internal/server\",\n  \"direction\": \"imports\",\n  \"dependencies\": [\n    {\n      \"package\": \"github.com/user/proj/internal/config\",\n      \"import_file\": \"/path/to/server/server.go\",\n      \"import_line\": 8\n    },\n    {\n      \"package\": \"net/http\",\n      \"import_file\": \"/path/to/server/server.go\",\n      \"import_line\": 5\n    }\n  ]\n}\n```\n\n## Acceptance Criteria\n- [ ] Show direct imports\n- [ ] Show reverse (importers)\n- [ ] Transitive with --depth\n- [ ] --exclude-stdlib filters\n\n## Files\n- cmd/deps.go\n- cmd/deps_test.go\n\n## Priority\nMedium (P2) - Future command, not MVP","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T04:01:54.678956764Z","updated_at":"2026-01-10T06:14:04.234755198Z","closed_at":"2026-01-10T06:14:04.234755198Z","dependencies":[{"issue_id":"wc-af7d.13","depends_on_id":"wc-af7d.1","type":"blocks","created_at":"2026-01-10T04:01:54.682917158Z","created_by":"jason"},{"issue_id":"wc-af7d.13","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T04:01:54.686291533Z","created_by":"jason"}]}
{"id":"wc-af7d.14","content_hash":"7935d8875e3f2bb79f0f6d3d4098fc853a5696d65fd24684c8b9e6a80f03d47e","title":"Implement readme command","description":"## Context\nOutput AI onboarding instructions. Designed to be included in system prompts, CLAUDE.md, or MCP server context.\n\n## Scope\nCreate `cmd/readme.go` that outputs comprehensive usage guidance for AI agents.\n\n1. **When to use Wildcat**\n   - Symbol queries (callers, callees, tree)\n   - Impact analysis\n   - Reference finding\n\n2. **When to use alternatives**\n   - grep: text patterns, non-Go files\n   - gopls: diagnostics, formatting, rename\n\n3. **Command quick reference**\n   - All commands with examples\n   - Common flags\n\n4. **Workflow patterns**\n   - Refactoring workflow\n   - Understanding new code\n   - Impact assessment before changes\n\n## CLI Design\n```\nwildcat readme [flags]\n\nFlags:\n  --compact    Quick reference only (no workflows)\n```\n\n## Output Format\nPlain text/markdown suitable for:\n- Including in CLAUDE.md\n- System prompts\n- MCP server context\n\n## Acceptance Criteria\n- [ ] Comprehensive tool guidance\n- [ ] When to use vs alternatives\n- [ ] Command quick reference with examples\n- [ ] Workflow patterns\n- [ ] --compact for minimal version\n- [ ] Updates as commands are added\n\n## Files\n- cmd/readme.go\n- cmd/readme_test.go\n\n## Priority\nMedium (P2) - Should be done after MVP commands exist\n\n## Depends On\n- wc-af7d.10 (impact - all MVP commands should exist first)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T04:02:08.298025663Z","updated_at":"2026-01-10T06:15:38.343641665Z","closed_at":"2026-01-10T06:15:38.343641665Z","dependencies":[{"issue_id":"wc-af7d.14","depends_on_id":"wc-af7d.10","type":"blocks","created_at":"2026-01-10T04:02:08.302315001Z","created_by":"jason"}]}
{"id":"wc-af7d.2","content_hash":"de2fe8a44e84726f7cd597cd2bd81ccb026636a7bc507dec2c0c1e89b4de3f88","title":"Symbol resolution and parsing","description":"## Context\nUsers query by symbol name (pkg.Func, Type.Method). We need to parse these inputs and resolve them to actual Go objects.\n\n## Scope\nCreate `internal/symbols` package that:\n\n1. **Parse symbol input formats**\n   - `Function` - function in current/contextual package\n   - `pkg.Function` - function in package named \"pkg\"\n   - `Type.Method` - method on type\n   - `path/to/pkg.Function` - fully qualified\n   - `(*Type).Method` - method on pointer receiver\n\n2. **Resolve to types.Object**\n   - Search loaded packages for matching symbol\n   - Handle package name vs package path ambiguity\n   - Support method resolution on types\n\n3. **Fuzzy matching for suggestions**\n   - When symbol not found, find similar names\n   - Use Levenshtein distance or similar\n   - Return top 3-5 suggestions\n\n4. **Handle ambiguity**\n   - Multiple packages with same name\n   - Return all candidates with full paths\n\n## Interface Design\n```go\ntype Symbol struct {\n    Package  string   // Package path or name\n    Type     string   // Receiver type (if method)\n    Pointer  bool     // Pointer receiver\n    Name     string   // Function/method name\n    Raw      string   // Original input\n}\n\ntype Resolver interface {\n    // Parse parses symbol string into structured form\n    Parse(input string) (*Symbol, error)\n    \n    // Resolve finds the types.Object for a symbol\n    Resolve(sym *Symbol) (types.Object, error)\n    \n    // Suggest returns similar symbols for typo correction\n    Suggest(sym *Symbol, limit int) []string\n}\n\ntype ResolveResult struct {\n    Object   types.Object\n    Package  *packages.Package\n    Position token.Position  // File, line, col\n}\n```\n\n## Acceptance Criteria\n- [ ] Parse pkg.Func format\n- [ ] Parse Type.Method format\n- [ ] Parse (*Type).Method format\n- [ ] Parse path/to/pkg.Func format\n- [ ] Resolve function in package\n- [ ] Resolve method on type\n- [ ] Return position (file:line) for resolved symbol\n- [ ] Suggest similar symbols when not found\n- [ ] Handle ambiguous package names\n- [ ] Unit tests for all parse formats\n\n## Files\n- internal/symbols/parse.go\n- internal/symbols/resolve.go\n- internal/symbols/suggest.go\n- internal/symbols/*_test.go\n\n## Depends On\n- wc-af7d.1 (Package loading infrastructure)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:56:02.890832458Z","updated_at":"2026-01-10T04:58:12.787805907Z","closed_at":"2026-01-10T04:58:12.787805907Z","dependencies":[{"issue_id":"wc-af7d.2","depends_on_id":"wc-af7d.1","type":"blocks","created_at":"2026-01-10T03:56:02.895157496Z","created_by":"jason"}]}
{"id":"wc-af7d.3","content_hash":"92af09031a962f3771bc84949ee421f9ed92e39db2a5c7a11fef97753ebd7598","title":"Call graph construction","description":"## Context\nCall graph is the core data structure for callers, callees, tree, and impact commands. We need to build it from loaded packages using SSA and callgraph algorithms.\n\n## Scope\nCreate `internal/callgraph` package that:\n\n1. **Build SSA representation**\n   - Convert packages to SSA form using golang.org/x/tools/go/ssa\n   - Use ssa.BuilderMode for necessary analysis\n   - Cache SSA program for reuse\n\n2. **Construct call graph**\n   - Support three algorithms:\n     - CHA (Class Hierarchy Analysis) - fast, imprecise\n     - RTA (Rapid Type Analysis) - medium, balanced (default)\n     - VTA (Variable Type Analysis) - slow, precise\n   - Cache graph for reuse across queries\n\n3. **Query interface**\n   - Get callers of a function\n   - Get callees of a function\n   - Traverse up/down to depth N\n   - Filter by package pattern\n   - Exclude stdlib\n\n## Interface Design\n```go\ntype Algorithm string\n\nconst (\n    AlgorithmCHA Algorithm = \"cha\"\n    AlgorithmRTA Algorithm = \"rta\"\n    AlgorithmVTA Algorithm = \"vta\"\n)\n\ntype Graph interface {\n    // Callers returns all callers of the given function\n    Callers(fn *ssa.Function) []*callgraph.Edge\n    \n    // Callees returns all functions called by the given function\n    Callees(fn *ssa.Function) []*callgraph.Edge\n    \n    // Walk traverses the graph from a starting function\n    Walk(fn *ssa.Function, direction Direction, depth int, visitor func(*callgraph.Edge) bool)\n}\n\ntype Builder interface {\n    // Build constructs call graph from loaded packages\n    Build(pkgs []*packages.Package, algo Algorithm) (Graph, error)\n    \n    // SSAFunction returns SSA function for a types.Func\n    SSAFunction(fn *types.Func) *ssa.Function\n}\n\ntype Direction int\n\nconst (\n    DirectionUp   Direction = iota  // callers\n    DirectionDown                   // callees\n)\n```\n\n## Acceptance Criteria\n- [ ] Build SSA from packages\n- [ ] Construct call graph with CHA\n- [ ] Construct call graph with RTA\n- [ ] Construct call graph with VTA\n- [ ] Query callers of function\n- [ ] Query callees of function\n- [ ] Walk graph with depth limit\n- [ ] Filter by package pattern\n- [ ] Exclude stdlib option\n- [ ] Map types.Func to ssa.Function\n- [ ] Unit tests for each algorithm\n\n## Files\n- internal/callgraph/builder.go\n- internal/callgraph/graph.go\n- internal/callgraph/walk.go\n- internal/callgraph/*_test.go\n\n## Dependencies\n- golang.org/x/tools/go/ssa\n- golang.org/x/tools/go/ssa/ssautil\n- golang.org/x/tools/go/callgraph\n- golang.org/x/tools/go/callgraph/cha\n- golang.org/x/tools/go/callgraph/rta\n- golang.org/x/tools/go/callgraph/vta\n\n## Depends On\n- wc-af7d.1 (Package loading infrastructure)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:56:21.999630583Z","updated_at":"2026-01-10T04:58:06.674542647Z","closed_at":"2026-01-10T04:58:06.674542647Z","dependencies":[{"issue_id":"wc-af7d.3","depends_on_id":"wc-af7d.1","type":"blocks","created_at":"2026-01-10T03:56:22.00415759Z","created_by":"jason"}]}
{"id":"wc-af7d.4","content_hash":"8852a73bcca245499dedd6029400c370f62be25bcd4b00ca860ab309910dc499","title":"JSON output formatting and snippets","description":"## Context\nAll commands output structured JSON. We need consistent formatting, snippet extraction, and output types that are ready for AI tool consumption.\n\n## Scope\nCreate `internal/output` package that:\n\n1. **Define output types**\n   - Query block (command, target, resolved)\n   - Target block (symbol, file, line, signature)\n   - Result items (symbol, package, file, line, line_end, snippet, call_expr, args, in_test)\n   - Summary block (count, packages, in_tests, truncated)\n   - Error block (code, message, suggestions, context)\n\n2. **Snippet extraction**\n   - Extract source lines around a position\n   - Configurable context lines (default 3)\n   - Preserve original indentation\n   - Extract just the call expression\n\n3. **Path handling**\n   - Always output absolute paths\n   - Resolve from token.Position\n\n4. **JSON serialization**\n   - Consistent field naming (snake_case)\n   - Pretty print option\n   - Streaming for large results\n\n## Interface Design\n```go\ntype QueryInfo struct {\n    Command  string `json:\"command\"`\n    Target   string `json:\"target\"`\n    Resolved string `json:\"resolved\"`\n}\n\ntype TargetInfo struct {\n    Symbol    string `json:\"symbol\"`\n    File      string `json:\"file\"`\n    Line      int    `json:\"line\"`\n    Signature string `json:\"signature,omitempty\"`\n}\n\ntype Result struct {\n    Symbol   string   `json:\"symbol\"`\n    Package  string   `json:\"package\"`\n    File     string   `json:\"file\"`\n    Line     int      `json:\"line\"`\n    LineEnd  int      `json:\"line_end\"`\n    Snippet  string   `json:\"snippet,omitempty\"`\n    CallExpr string   `json:\"call_expr,omitempty\"`\n    Args     []string `json:\"args,omitempty\"`\n    InTest   bool     `json:\"in_test\"`\n}\n\ntype Summary struct {\n    Count     int      `json:\"count\"`\n    Packages  []string `json:\"packages\"`\n    InTests   int      `json:\"in_tests\"`\n    Truncated bool     `json:\"truncated\"`\n}\n\ntype ErrorResponse struct {\n    Code        string            `json:\"code\"`\n    Message     string            `json:\"message\"`\n    Suggestions []string          `json:\"suggestions,omitempty\"`\n    Context     map[string]any    `json:\"context,omitempty\"`\n}\n\ntype SnippetExtractor interface {\n    // Extract returns source lines around position\n    Extract(pos token.Position, contextLines int) (string, error)\n    \n    // ExtractExpr returns just the expression at position\n    ExtractExpr(pos token.Position) (string, error)\n}\n```\n\n## Acceptance Criteria\n- [ ] Define all output types with JSON tags\n- [ ] Extract snippet with configurable context\n- [ ] Extract call expression only\n- [ ] Output absolute paths\n- [ ] Detect test files (in_test field)\n- [ ] Serialize to JSON with proper formatting\n- [ ] Handle edge cases (start/end of file)\n- [ ] Unit tests for snippet extraction\n\n## Files\n- internal/output/types.go\n- internal/output/snippet.go\n- internal/output/json.go\n- internal/output/*_test.go\n\n## Depends On\n- wc-af7d.1 (Package loading - needs file access)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:56:42.168398223Z","updated_at":"2026-01-10T05:29:28.844419713Z","closed_at":"2026-01-10T05:29:28.844419713Z","dependencies":[{"issue_id":"wc-af7d.4","depends_on_id":"wc-af7d.1","type":"blocks","created_at":"2026-01-10T03:56:42.172872031Z","created_by":"jason"}]}
{"id":"wc-af7d.5","content_hash":"a553d754394c008a5f205e5efb4160005727c45b65c17ae4f8e4fd0bc6bfcec2","title":"Error handling with suggestions","description":"## Context\nAI agents can self-correct if errors include helpful suggestions. We need structured error responses with fuzzy-matched alternatives.\n\n## Scope\nCreate `internal/errors` package that:\n\n1. **Define error types**\n   - SymbolNotFound - symbol doesn't exist\n   - AmbiguousSymbol - multiple matches\n   - PackageNotFound - package path invalid\n   - ParseError - source has syntax errors\n   - LoadError - failed to load packages\n\n2. **Include suggestions**\n   - Use fuzzy matching to find similar symbols\n   - Limit to top 3-5 suggestions\n   - Include context (packages searched, etc.)\n\n3. **Convert to JSON**\n   - Implement error interface\n   - Provide ToJSON() method for output\n   - Include error code for programmatic handling\n\n## Interface Design\n```go\ntype Code string\n\nconst (\n    CodeSymbolNotFound   Code = \"symbol_not_found\"\n    CodeAmbiguousSymbol  Code = \"ambiguous_symbol\"\n    CodePackageNotFound  Code = \"package_not_found\"\n    CodeParseError       Code = \"parse_error\"\n    CodeLoadError        Code = \"load_error\"\n)\n\ntype WildcatError struct {\n    Code        Code\n    Message     string\n    Suggestions []string\n    Context     map[string]any\n}\n\nfunc (e *WildcatError) Error() string\nfunc (e *WildcatError) ToJSON() []byte\n\n// Constructor functions\nfunc NewSymbolNotFound(symbol string, suggestions []string) *WildcatError\nfunc NewAmbiguousSymbol(symbol string, candidates []string) *WildcatError\nfunc NewPackageNotFound(pkg string) *WildcatError\nfunc NewParseError(file string, line int, msg string) *WildcatError\nfunc NewLoadError(patterns []string, err error) *WildcatError\n```\n\n## Acceptance Criteria\n- [ ] Define error types with codes\n- [ ] Include suggestions in SymbolNotFound\n- [ ] Include candidates in AmbiguousSymbol\n- [ ] ToJSON produces valid JSON\n- [ ] Error() returns human-readable message\n- [ ] Context includes useful debugging info\n- [ ] Unit tests for all error types\n\n## Files\n- internal/errors/errors.go\n- internal/errors/errors_test.go\n\n## Depends On\n- wc-af7d.2 (Symbol resolution - for suggestion generation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:56:57.643255869Z","updated_at":"2026-01-10T05:31:02.047632331Z","closed_at":"2026-01-10T05:31:02.047632331Z","dependencies":[{"issue_id":"wc-af7d.5","depends_on_id":"wc-af7d.2","type":"blocks","created_at":"2026-01-10T03:56:57.646710381Z","created_by":"jason"}]}
{"id":"wc-af7d.6","content_hash":"1cc03f33a52f612884f7b78e9e87d3f617fa83e62175b2964d76c84a5b311857","title":"Implement callers command","description":"## Context\nFirst and most important command. Find all callers of a function or method. This proves out the entire infrastructure.\n\n## Scope\nCreate `cmd/callers.go` that:\n\n1. **Accept symbol argument**\n   - Parse symbol using symbols.Parse()\n   - Resolve using symbols.Resolve()\n   - Handle errors with suggestions\n\n2. **Query call graph**\n   - Build call graph with selected algorithm (default: RTA)\n   - Find all callers using callgraph.Callers()\n\n3. **Format output**\n   - Extract snippets for each caller\n   - Build Result objects with all fields\n   - Generate summary\n\n4. **Support flags**\n   - --exclude-tests: filter out *_test.go\n   - --package: limit to package pattern\n   - --limit: cap results\n   - --context: lines of context in snippet\n   - --compact: omit snippets\n   - --algorithm: cha|rta|vta\n\n## CLI Design\n```\nwildcat callers \u003csymbol\u003e [flags]\n\nArguments:\n  symbol    Function or method (e.g., pkg.Func, Type.Method)\n\nFlags:\n  --exclude-tests    Exclude test files\n  --package string   Limit to package pattern\n  --limit int        Maximum results (0 = unlimited)\n  --context int      Lines of context (default 3)\n  --compact          Omit snippets\n  --algorithm string Algorithm: cha, rta, vta (default \"rta\")\n```\n\n## Output Example\n```json\n{\n  \"query\": {\n    \"command\": \"callers\",\n    \"target\": \"config.Load\",\n    \"resolved\": \"github.com/user/proj/internal/config.Load\"\n  },\n  \"target\": {\n    \"symbol\": \"config.Load\",\n    \"file\": \"/path/to/config/config.go\",\n    \"line\": 15,\n    \"signature\": \"func Load(path string) (*Config, error)\"\n  },\n  \"results\": [...],\n  \"summary\": {\n    \"count\": 5,\n    \"packages\": [\"main\", \"server\"],\n    \"in_tests\": 1,\n    \"truncated\": false\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] Parse symbol argument\n- [ ] Resolve symbol to function\n- [ ] Find callers in call graph\n- [ ] Output JSON with all fields\n- [ ] --exclude-tests works\n- [ ] --package filtering works\n- [ ] --limit caps results\n- [ ] --context controls snippet size\n- [ ] --compact omits snippets\n- [ ] Error output includes suggestions\n- [ ] Integration test with real Go code\n\n## Files\n- cmd/callers.go\n- cmd/callers_test.go\n\n## Depends On\n- wc-af7d.2 (Symbol resolution)\n- wc-af7d.3 (Call graph)\n- wc-af7d.4 (Output formatting)\n- wc-af7d.5 (Error handling)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T04:00:11.861183858Z","updated_at":"2026-01-10T05:38:48.120509161Z","closed_at":"2026-01-10T05:38:48.120509161Z","dependencies":[{"issue_id":"wc-af7d.6","depends_on_id":"wc-af7d.2","type":"blocks","created_at":"2026-01-10T04:00:11.864938473Z","created_by":"jason"},{"issue_id":"wc-af7d.6","depends_on_id":"wc-af7d.3","type":"blocks","created_at":"2026-01-10T04:00:11.867959646Z","created_by":"jason"},{"issue_id":"wc-af7d.6","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T04:00:11.871809909Z","created_by":"jason"},{"issue_id":"wc-af7d.6","depends_on_id":"wc-af7d.5","type":"blocks","created_at":"2026-01-10T04:00:11.874970218Z","created_by":"jason"},{"issue_id":"wc-af7d.6","depends_on_id":"wc-cb10","type":"blocks","created_at":"2026-01-10T04:58:18.407243428Z","created_by":"jason"},{"issue_id":"wc-af7d.6","depends_on_id":"wc-099e","type":"blocks","created_at":"2026-01-10T04:58:18.442294555Z","created_by":"jason"}]}
{"id":"wc-af7d.7","content_hash":"00e0befd83838ad3df6c4d8f8748231b532108edda22803ebc6c2bdd958432e3","title":"Implement callees command","description":"## Context\nMirror of callers command. Find all functions called by a given function. Shares most infrastructure with callers.\n\n## Scope\nCreate `cmd/callees.go` that:\n\n1. **Accept symbol argument**\n   - Same parsing/resolution as callers\n\n2. **Query call graph**\n   - Find all callees using callgraph.Callees()\n   - Same algorithm options\n\n3. **Format output**\n   - Same output structure as callers\n   - Results show what the target calls\n\n4. **Support same flags**\n   - --exclude-tests, --package, --limit, --context, --compact, --algorithm\n\n## CLI Design\n```\nwildcat callees \u003csymbol\u003e [flags]\n```\n\nSame flags as callers command.\n\n## Implementation Notes\n- Extract shared logic from callers into helper function\n- Only difference is graph traversal direction\n- Consider refactoring callers to use shared code\n\n## Acceptance Criteria\n- [ ] Parse symbol argument\n- [ ] Find callees in call graph\n- [ ] Output JSON with all fields\n- [ ] All flags work (same as callers)\n- [ ] Shared code with callers (no duplication)\n\n## Files\n- cmd/callees.go\n- cmd/callees_test.go\n- cmd/shared.go (if extracting common logic)\n\n## Depends On\n- wc-af7d.6 (callers command - shares infrastructure)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T04:00:23.688759041Z","updated_at":"2026-01-10T05:39:15.314930121Z","closed_at":"2026-01-10T05:39:15.314930121Z","dependencies":[{"issue_id":"wc-af7d.7","depends_on_id":"wc-af7d.6","type":"blocks","created_at":"2026-01-10T04:00:23.692622664Z","created_by":"jason"}]}
{"id":"wc-af7d.8","content_hash":"63a53173f0ecf757f691e17e2213680707727961ec956745d7bf78b568590e3b","title":"Implement tree command","description":"## Context\nBuild a call tree from a starting point. Recursive traversal of callers (up) or callees (down) with depth control.\n\n## Scope\nCreate `cmd/tree.go` that:\n\n1. **Accept symbol argument**\n   - Same parsing/resolution as callers/callees\n\n2. **Recursive traversal**\n   - Walk graph up (callers) or down (callees)\n   - Respect depth limit\n   - Track visited nodes to avoid cycles\n   - Collect edges with positions\n\n3. **Build tree structure**\n   - nodes: map of function -\u003e details + connections\n   - edges: list of from/to with positions\n   - Different from flat results list\n\n4. **Support flags**\n   - --depth: max traversal depth (default 3)\n   - --direction: up|down (default down)\n   - --exclude-tests, --exclude-stdlib\n   - --algorithm: cha|rta|vta\n\n## CLI Design\n```\nwildcat tree \u003csymbol\u003e [flags]\n\nFlags:\n  --depth int        Maximum depth (default 3)\n  --direction string up or down (default \"down\")\n  --exclude-tests    Exclude test files\n  --exclude-stdlib   Exclude standard library\n  --algorithm string cha, rta, vta (default \"rta\")\n```\n\n## Output Example\n```json\n{\n  \"query\": {\n    \"command\": \"tree\",\n    \"root\": \"main.main\",\n    \"depth\": 3,\n    \"direction\": \"down\"\n  },\n  \"nodes\": {\n    \"main.main\": {\n      \"file\": \"/path/to/main.go\",\n      \"line\": 10,\n      \"signature\": \"func main()\",\n      \"calls\": [\"cmd.Execute\", \"os.Exit\"]\n    },\n    \"cmd.Execute\": {\n      \"file\": \"/path/to/cmd/root.go\",\n      \"line\": 15,\n      \"calls\": [\"config.Load\"]\n    }\n  },\n  \"edges\": [\n    {\"from\": \"main.main\", \"to\": \"cmd.Execute\", \"file\": \"/path/main.go\", \"line\": 11}\n  ],\n  \"summary\": {\n    \"node_count\": 5,\n    \"edge_count\": 8,\n    \"max_depth_reached\": 3,\n    \"truncated\": false\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] Traverse down (callees) recursively\n- [ ] Traverse up (callers) recursively\n- [ ] Respect depth limit\n- [ ] Handle cycles (don't infinite loop)\n- [ ] Build nodes map with details\n- [ ] Build edges list with positions\n- [ ] --exclude-stdlib filters standard library\n- [ ] Summary shows depth reached\n- [ ] Integration test with recursive calls\n\n## Files\n- cmd/tree.go\n- cmd/tree_test.go\n\n## Depends On\n- wc-af7d.6 (callers)\n- wc-af7d.7 (callees)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T04:00:43.166160313Z","updated_at":"2026-01-10T05:39:15.357461817Z","closed_at":"2026-01-10T05:39:15.357461817Z","dependencies":[{"issue_id":"wc-af7d.8","depends_on_id":"wc-af7d.6","type":"blocks","created_at":"2026-01-10T04:00:43.170703458Z","created_by":"jason"},{"issue_id":"wc-af7d.8","depends_on_id":"wc-af7d.7","type":"blocks","created_at":"2026-01-10T04:00:43.174334873Z","created_by":"jason"}]}
{"id":"wc-af7d.9","content_hash":"db1a28b38078c21fefc74b0d7be94d1bcacd48f47b6f6a1810f7da1d06a96888","title":"Implement refs command","description":"## Context\nFind all references to a symbol, not just calls. Uses type information rather than call graph. Important for type/variable/constant usage tracking.\n\n## Scope\nCreate `cmd/refs.go` that:\n\n1. **Accept symbol argument**\n   - Parse and resolve symbol\n   - Can be function, type, variable, constant\n\n2. **Find references using types.Info**\n   - Walk AST of all files\n   - Check Uses map for references to target object\n   - Include Defs for completeness\n\n3. **Categorize references**\n   - Call sites (function calls)\n   - Type references (variable declarations, parameters)\n   - Value references (assignments, passing as argument)\n\n4. **Format output**\n   - Same structure as callers\n   - Add \"reason\" field for reference type\n\n## CLI Design\n```\nwildcat refs \u003csymbol\u003e [flags]\n\nFlags:\n  --exclude-tests    Exclude test files\n  --package string   Limit to package pattern\n  --limit int        Maximum results\n  --context int      Lines of context (default 3)\n  --compact          Omit snippets\n```\n\n## Implementation Approach\n```go\n// Walk all packages\nfor _, pkg := range packages {\n    for ident, obj := range pkg.TypesInfo.Uses {\n        if obj == targetObject {\n            // Found a reference\n            pos := pkg.Fset.Position(ident.Pos())\n            // Extract snippet, build result\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Find function references (not just calls)\n- [ ] Find type references\n- [ ] Find variable/constant references\n- [ ] Output JSON with same structure as callers\n- [ ] Include reference type/reason\n- [ ] All standard flags work\n- [ ] Integration test with various reference types\n\n## Files\n- cmd/refs.go\n- cmd/refs_test.go\n\n## Depends On\n- wc-af7d.2 (Symbol resolution)\n- wc-af7d.4 (Output formatting)\n- wc-af7d.5 (Error handling)\n\n## Note\nDoes NOT depend on call graph (wc-af7d.3). Uses type checker info directly.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T04:00:59.248894512Z","updated_at":"2026-01-10T05:40:08.716605367Z","closed_at":"2026-01-10T05:40:08.716605367Z","dependencies":[{"issue_id":"wc-af7d.9","depends_on_id":"wc-af7d.2","type":"blocks","created_at":"2026-01-10T04:00:59.253045928Z","created_by":"jason"},{"issue_id":"wc-af7d.9","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T04:00:59.256479231Z","created_by":"jason"},{"issue_id":"wc-af7d.9","depends_on_id":"wc-af7d.5","type":"blocks","created_at":"2026-01-10T04:00:59.260561319Z","created_by":"jason"}]}
{"id":"wc-b078","content_hash":"7829c0c0613b7c671da322d43024560f16580605bf15bdc538f557da9b88b691","title":"Add suggestions to all responses, not just errors","description":"Currently suggestions only appear in error responses (symbol_not_found). Consider adding a \"suggestions\" or \"related\" field to successful responses too.\n\nFor example, after showing callers of config.Load, could suggest:\n- Other functions in the same package\n- Functions with similar names\n- Symbols referenced by the results\n\nThis turns every response into a navigation aid, not just dead-ends.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-12T14:01:37.18936279Z","updated_at":"2026-01-12T14:12:02.324434602Z","closed_at":"2026-01-12T14:12:02.324434602Z"}
{"id":"wc-b0eb","content_hash":"89ceb73375f51f647fac75f11f057d27e0d601d8a393408c490f80dc672b4e6b","title":"Test hardening across the codebase","description":"Current test coverage is sparse relative to the implementation. Observed test files:\n- interfaces_test.go\n- search_test.go\n- refs_test.go\n- deadcode_test.go\n- pkgpath_test.go\n- scope_test.go\n\nMissing coverage for:\n- Command execution paths (search, symbol, tree, package, deadcode commands)\n- Error handling paths (especially after silent failure fixes)\n- Edge cases: malformed input, partial codebases, unusual AST patterns\n- Snippet extraction and merging\n- Channel operations detection\n- Format functions (especially error cases after wc-79d6)\n\nApproach:\n- Table-driven tests (already the norm, continue this)\n- Test interfaces, not implementations\n- Mock external dependencies (file system, go/packages)\n- Include regression tests for each silent failure fix\n\nPriority areas:\n1. Core analysis: refs.go, calls.go, interfaces.go, deadcode.go\n2. Symbol resolution: search.go, pkgpath.go\n3. Commands: each command's Execute() path\n4. Error paths: once error philosophy (wc-c79f) is established\n\nContext from discussion:\n- Wait until feature set stabilizes before heavy test investment\n- Tests enable safe optimization later\n- Silent failure fixes will make testing easier (predictable error behavior)\n- This is a prerequisite for loading optimizations (wc-TBD)","status":"open","priority":4,"issue_type":"task","created_at":"2026-01-23T06:08:24.45514581Z","updated_at":"2026-01-23T06:09:06.808657899Z"}
{"id":"wc-b201","content_hash":"8897e6124d5c2c158a70bacc0c87962aeff9c97124304502117c4877f83eb82a","title":"Filter out /internal/ paths from external packages in search results","description":"Search results include symbols from internal packages of external dependencies, e.g.:\n- golang.org/x/tools/internal/stdlib.Symbol.Version\n\nThese are not accessible or editable - they just happen to be in the import chain.\n\nFilter criteria:\n- If the file path is in go/pkg/mod/ (external dependency)\n- AND the import path contains /internal/\n- THEN exclude from results\n\nKeep /internal/ paths from the project itself (e.g. github.com/jasonmoo/wildcat/internal/...) since those are valid results.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-16T09:53:07.72739421Z","updated_at":"2026-01-16T09:56:26.085721155Z","closed_at":"2026-01-16T09:56:26.085721155Z"}
{"id":"wc-b21c","content_hash":"309e3e29b815385bfc8aad8090d835025636d63cf6cb49465677f92817186b08","title":"Channel operations silently skipped when type info unavailable","description":"In channels.go, channel operations are silently skipped when ChannelElemType() returns empty string:\n\nLocations (all follow pattern 'if elemType := ChannelElemType(...); elemType != \"\" { ... }'):\n- channels.go:122 (select send)\n- channels.go:132 (select receive expr)\n- channels.go:144 (select receive assign)\n- channels.go:191 (send)\n- channels.go:203 (receive)\n- channels.go:220 (close)\n- channels.go:241 (range)\n\nImpact: If type info isn't available for a channel, its operations don't appear in analysis. AI doesn't know operations were skipped.\n\nOptions:\n- Include operation with 'type_unknown' field\n- Track skipped operations count in response\n- Return error from ChannelElemType","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:52:27.392332688Z","updated_at":"2026-01-23T13:44:06.268602193Z","closed_at":"2026-01-23T13:44:06.268602193Z","dependencies":[{"issue_id":"wc-b21c","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:52:27.408964613Z","created_by":"jason"}]}
{"id":"wc-b24c","content_hash":"aabc443774b9565a133ac489314cbd3b5ad1421024304c177b2adc01a28de003","title":"Add edit command with path-based addressing","description":"Create an `edit` command that modifies source code at a semantic path.\n\n**Usage:**\n```bash\nwildcat edit golang.Symbol.Name                    # edit a field\nwildcat edit golang.WalkReferences/params[ctx]     # edit a parameter\nwildcat edit golang.WalkReferences/body            # edit function body\n```\n\n**Key design questions:**\n\n1. **Body granularity** - Full body replacement vs. surgical edits\n   - Full body replacement is simpler but requires reproducing large functions\n   - Statement-level addressing (e.g., /body/stmts[3]) is fragile as indices shift\n   - Consider content-based identification for statements (future work)\n\n2. **Input format** - How does the new content come in?\n   - Stdin: `wildcat edit path \u003c new_content.go`\n   - Inline: `wildcat edit path 'new content here'`\n   - Declarative: `wildcat edit path --rename newName`\n\n3. **Validation** - After edit, run type checking and report errors\n\n**See also:**\n- docs/semantic-feedback.md - AI feedback on editing approach\n- docs/path-syntax.md - path syntax specification\n- wc-10a8 - read command (companion to edit)\n- wc-abcf - ls command (discovery for edit)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-26T13:41:57.583143638Z","updated_at":"2026-01-26T13:41:57.583143638Z"}
{"id":"wc-b2ec","content_hash":"ddba164d5f9aa371485c2b9fa0e8c3043613dbc8dddffbfcdfeaab62471d4dfc","title":"Panic in findNode when package has nil file position","description":"When running wildcat symbol commands.Diagnostic, got a panic:\n\n```\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x327074]\n\ngoroutine 1 [running]:\ngo/token.(*File).Name(...)\n\t/home/jason/go1.x/src/go/token/position.go:117\ngithub.com/jasonmoo/wildcat/internal/golang.findNode(0x400052c680, 0xa2bbad)\n\t/home/jason/go/src/github.com/jasonmoo/wildcat/internal/golang/symbol.go:119 +0x84\n```\n\nfindNode in symbol.go assumes pkg.Fset.File() returns non-nil, but this can fail for symbols without valid positions. Should add a nil check and handle gracefully.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T13:01:35.220059864Z","updated_at":"2026-01-26T03:35:28.631650832Z","closed_at":"2026-01-26T03:35:28.631650832Z"}
{"id":"wc-b32f","content_hash":"51595383cddccf62a73d186ce9967e66f76f27a560f8806ddf678361d3339072","title":"Add AST context output alongside snippets","description":"## Problem\nCurrent impact/refs output includes text snippets, but these are just raw strings. To make intelligent statements about code context, we need structured information about the enclosing AST.\n\n## Idea\nAlongside (or instead of) text snippets, provide AST-aware context:\n- What construct encloses this reference? (function, method, struct field, type decl, etc.)\n- What is the signature/shape of that enclosure?\n- What other symbols does the enclosure reference?\n\n## Example Current Output\n```json\n{\n  \"file\": \"db.go\",\n  \"line\": 42,\n  \"snippet\": \"func GetTask(id TaskID) *Task {\"\n}\n```\n\n## Example Enriched Output (TBD)\n```json\n{\n  \"file\": \"db.go\",\n  \"line\": 42,\n  \"enclosure\": {\n    \"kind\": \"function\",\n    \"name\": \"GetTask\",\n    \"signature\": \"func(TaskID) *Task\",\n    \"types_used\": [\"TaskID\", \"Task\"]\n  }\n}\n```\n\n## Notes\n- Exact shape TBD at implementation time\n- May require go/ast parsing\n- Could enable smarter impact analysis (e.g., \"this function is Task-centric\")\n\n## Related\n- wc-9ab6: Transitive symbol discovery (may use this)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-14T01:40:19.661266691Z","updated_at":"2026-01-15T14:50:30.024851863Z","closed_at":"2026-01-15T14:50:30.024851863Z"}
{"id":"wc-b416","content_hash":"5a3ac4cf208238bedabb8e7787900a3df4e8dd46402ad8212e4b36adf2a2c270","title":"Support /doc path for godoc comments","description":"Add `/doc` as a path component to address godoc comments.\n\n**Examples:**\n```\ngolang.Symbol/doc              # doc comment for a type\ngolang.WalkReferences/doc      # doc comment for a function\ngolang.Symbol.Name/doc         # doc comment for a field (if any)\n```\n\n**Use cases:**\n- Read documentation: `wildcat read golang.Symbol/doc`\n- Update documentation: `wildcat edit golang.Symbol/doc`\n- Verify all exported symbols have docs\n\n**Implementation:**\n- Parse comments from AST (ast.CommentGroup)\n- Handle both // and /* */ styles\n- Include the full comment block, not just the first line\n\n**See:** docs/semantic-feedback.md proposes this as a useful addition to the path system.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-26T13:42:17.610910114Z","updated_at":"2026-01-26T13:42:17.610910114Z"}
{"id":"wc-b636","content_hash":"c2a4421fecc40f64f79992c4aaa372353741ab59bc736083c074d1c782bcee0c","title":"Normalize symbol names to always include package prefix","description":"Currently symbol names from gopls are inconsistent:\n- Search for \"golang.Resolv\" returns \"golang.ResolvePackagePath\" \n- Search for \"Resolv\" returns \"ResolvePackagePath\" (no prefix)\n\nBut gopls always provides package info via ContainerName field:\n  \"symbol\": \"ResolvePackagePath\",\n  \"package\": \"github.com/jasonmoo/wildcat/internal/golang\"\n\nWe should normalize all symbol names to include a short package prefix derived from ContainerName. This enables:\n1. Consistent output format for search and suggestions\n2. Reliable filtering by package prefix\n3. Better user experience - always know which package a symbol is from\n\nImplementation:\n- Update formatSymbolShort to build \"pkg.Symbol\" from ContainerName\n- Use last path segment of import path as short prefix (e.g., \"golang\" from \".../internal/golang\")\n- Apply to both search results and error suggestions","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-16T09:39:48.090398893Z","updated_at":"2026-01-16T09:48:38.808148935Z","closed_at":"2026-01-16T09:48:38.808148935Z"}
{"id":"wc-b6a6","content_hash":"c36bfca99fd0c0d3b8c6af9b9a34e6bd6a87ee7629cd23afdc62c6305bbdbcf7","title":"imported_by in symbol vs package inconsistent","description":"imported_by format differs between commands:\n\n- symbol: Just package names as strings ([\"github.com/jasonmoo/bbb/ai/agents\", ...])\n- package: Objects with location ([{\"package\": \"...\", \"location\": \"...\"}])\n\nThe symbol version is less useful - you can't see where the import happens.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-18T05:47:12.244583403Z","updated_at":"2026-01-18T06:01:18.712381953Z","closed_at":"2026-01-18T06:01:18.712381953Z"}
{"id":"wc-b718","content_hash":"f8f2bc111bdc57e837aa560f030e7e46cf989ab4b555515c2dc52e341bc6e33d","title":"Output plugin system for custom formats","description":"## Context\nThis is the hackathon \"curveball\" feature. Wildcat needs to support user-defined output formats beyond JSON.\n\n## Deferred Decision\nFor MVP, we output JSON only. This ticket captures the plugin design for later implementation.\n\n## Proposed Architecture\n\n### Three-tier approach (simple → complex):\n\n1. **Built-in formatters** - Common formats shipped with Wildcat\n   - json (default)\n   - yaml\n   - dot (graphviz)\n   - markdown (tables)\n\n2. **Go templates** - User customization without code\n   - `--output template:./my.tmpl`\n   - Access to full result structure\n   - Easy to share as text files\n\n3. **External plugins** - Complex transformations\n   - `--output plugin:myplugin`\n   - Discovers `wildcat-format-myplugin` in PATH or plugin dir\n   - Receives JSON on stdin, outputs formatted result\n   - Language-agnostic (any executable)\n\n## Interface Design\n\n```go\n// internal/output/formatter.go\ntype Formatter interface {\n    // Format transforms the result into the desired output format\n    Format(result any) ([]byte, error)\n    \n    // Name returns the formatter name (e.g., \"dot\", \"yaml\")\n    Name() string\n    \n    // Description returns help text for --help\n    Description() string\n}\n\n// Registry for formatters\ntype Registry interface {\n    Register(f Formatter)\n    Get(name string) (Formatter, error)\n    List() []string\n}\n\n// For external plugins\ntype ExternalPlugin struct {\n    Command string   // e.g., \"wildcat-format-dot\"\n    Args    []string\n}\n\nfunc (p *ExternalPlugin) Format(result any) ([]byte, error) {\n    // Marshal to JSON, pipe to command, return stdout\n}\n```\n\n## CLI Design\n\n```bash\n# Built-in\nwildcat callers config.Load                      # JSON (default)\nwildcat callers config.Load --output yaml\nwildcat callers config.Load --output dot\nwildcat callers config.Load --output markdown\n\n# Template\nwildcat callers config.Load --output template:./custom.tmpl\n\n# External plugin  \nwildcat callers config.Load --output plugin:myplugin\n# Looks for: wildcat-format-myplugin\n\n# List available formatters\nwildcat formats\n```\n\n## Plugin Discovery\n\n1. Check `$PATH` for `wildcat-format-\u003cname\u003e`\n2. Check `~/.config/wildcat/plugins/`\n3. Check `./plugins/` in current directory\n\n## Built-in Formatters to Implement\n\n### dot (graphviz)\nFor tree command - visualize call graphs:\n```dot\ndigraph callgraph {\n  \"main.main\" -\u003e \"cmd.Execute\"\n  \"cmd.Execute\" -\u003e \"config.Load\"\n}\n```\n\n### yaml\nDirect YAML serialization of JSON output.\n\n### markdown\nTables for callers/refs, indented lists for trees:\n```markdown\n## Callers of config.Load\n\n| Caller | File | Line |\n|--------|------|------|\n| main.main | main.go | 23 |\n```\n\n## Acceptance Criteria\n- [ ] Formatter interface defined\n- [ ] Registry for formatter lookup\n- [ ] Built-in: yaml formatter\n- [ ] Built-in: dot formatter (for tree)\n- [ ] Built-in: markdown formatter\n- [ ] Go template support\n- [ ] External plugin discovery\n- [ ] External plugin execution (stdin/stdout)\n- [ ] `wildcat formats` command to list available\n- [ ] Plugin error handling (not found, execution failure)\n- [ ] Documentation for writing plugins\n\n## Files\n- internal/output/formatter.go (interface)\n- internal/output/registry.go\n- internal/output/yaml.go\n- internal/output/dot.go\n- internal/output/markdown.go\n- internal/output/template.go\n- internal/output/plugin.go (external)\n- cmd/formats.go\n\n## Design Principles (from CLAUDE.md)\n- **Composability first**: Formatter interface allows easy extension\n- **Simple over clever**: Start with built-ins, templates before external plugins\n\n## Priority\nP3 (Backlog) - Implement after MVP commands work with JSON output.\n\n## Depends On\n- wc-af7d.4 (JSON output formatting - need base types first)","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-10T05:14:19.768564456Z","updated_at":"2026-01-10T05:51:13.948844689Z","closed_at":"2026-01-10T05:51:13.948844689Z","dependencies":[{"issue_id":"wc-b718","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T05:14:23.909419837Z","created_by":"jason"}]}
{"id":"wc-b79d","content_hash":"6f82166965b506246eaec4e5fb223b1722a04790dadfc1f69156afb1e70130f9","title":"Hackathon demo preparation","description":"## Context\nPrepare and execute a compelling demo of Wildcat for the hackathon judges.\n\n## Demo Script\n\n### 1. The Problem (30 sec)\n- AI agents need to understand code semantically, not just grep\n- \"What calls this function?\" \"What breaks if I change this?\"\n- Existing tools: gopls is IDE-focused, grep is text-only\n\n### 2. The Solution (30 sec)\n- Wildcat: LSP-based static analysis for AI agents\n- Language-agnostic (Go, Python, TypeScript, Rust, C++)\n- JSON output optimized for tool integration\n\n### 3. Live Demo (2-3 min)\n\n```bash\n# Find all callers of a function\n./bin/wildcat callers lsp.NewClient\n\n# What would break if we changed this type?\n./bin/wildcat impact lsp.Client\n\n# Find all types implementing an interface\n./bin/wildcat implements output.Formatter\n\n# Visualize call graph\n./bin/wildcat callers output.NewWriter -o dot\n\n# Package dependencies\n./bin/wildcat deps ./internal/lsp --reverse\n\n# AI onboarding\n./bin/wildcat readme --compact\n```\n\n### 4. Output Formats (30 sec)\n- JSON (default) - for AI consumption\n- YAML, Markdown - human readable\n- DOT - Graphviz visualization\n- Extensible plugin system\n\n### 5. Curveball Feature (30 sec)\n- Output plugin system\n- Built-in: json, yaml, markdown, dot\n- Custom: Go templates, external plugins\n- `wildcat formats` to list available\n\n## Key Talking Points\n- Uses LSP for language-agnostic support\n- Answers semantic questions grep can't\n- Designed for AI agents, not humans\n- Extensible output system (curveball)\n- Self-documenting (readme command)\n\n## Demo Environment\n- [ ] Clean terminal with large font\n- [ ] Pre-built binary ready\n- [ ] Test commands work on wildcat codebase\n- [ ] Have backup screenshots if LSP is slow\n\n## Acceptance Criteria\n- [ ] Demo script rehearsed\n- [ ] All commands tested\n- [ ] Timing under 5 minutes\n- [ ] Backup plan if something fails","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-10T06:18:09.779572934Z","updated_at":"2026-01-10T06:25:33.576243537Z","closed_at":"2026-01-10T06:25:33.576243537Z"}
{"id":"wc-b84c","content_hash":"02cc024277237c0efe14f591a9961833ee05b5ac0e68e4691cedd125642b5255","title":"Package resolution panics instead of returning error","description":"In pkgpath.go:78, ResolvePackageName() panics on packages.Load error instead of returning it:\n\nLocation: internal/golang/pkgpath.go:77-79\n\nCode:\n  pkgs, err := packages.Load(...)\n  if err != nil {\n    panic(err)\n  }\n\nImpact: Tool crashes instead of giving AI actionable error message.\n\nAdditionally, pkgpath.go:216-226 doesn't check pkg.Errors after loading './...' - package-level errors are silently attached to Package structs but never examined.\n\nOptions:\n- Return the error properly\n- Check and aggregate pkg.Errors after load","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:52:20.945164875Z","updated_at":"2026-01-23T10:21:02.022617207Z","closed_at":"2026-01-23T10:21:02.022617207Z","dependencies":[{"issue_id":"wc-b84c","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:52:20.961449481Z","created_by":"jason"}]}
{"id":"wc-ba2f","content_hash":"d21eb09e91d23a07ad59fba58dfd5056c38531c757452f1f16fed02ce905fd62","title":"Fix symbol --scope to filter output, not search area","description":"Currently symbol's --scope limits WHERE it searches for callers/refs. It should search the full project and filter WHAT gets shown in output.\n\nCurrent behavior (wrong):\n- --scope pkg1,pkg2 only searches pkg1 and pkg2 for callers\n- Misses callers from other packages\n\nCorrect behavior:\n- Find all callers/refs across entire project\n- Filter output to only show usages from scoped packages\n- Consistent with search and deadcode scope semantics\n\nThis enables 'show me how symbol X is used in packages A and B' use case.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-23T04:28:31.97612035Z","updated_at":"2026-01-23T04:38:26.704778528Z","closed_at":"2026-01-23T04:38:26.704778528Z"}
{"id":"wc-bb7e","content_hash":"ae6f18431d4ddc3130a2bd2a9ae8b24bbb29b3ca5af7e7e5866ab76efea9f852","title":"Add method count before method list in package output","description":"Add a count header before the methods section in package command output (e.g., 'Methods (12):') to give users a quick sense of the package's method surface area.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-15T02:26:44.92294367Z","updated_at":"2026-01-15T02:41:29.630100167Z","closed_at":"2026-01-15T02:41:29.630100167Z"}
{"id":"wc-bd36","content_hash":"d97e77092c5cf85a18894c0a34868dc238eca638f2af7609616b2f8be5dbe725","title":"ls command fails on paths with slashes in package name","description":"When using ls with a path like 'internal/commands.Wildcat', it fails with 'expected identifier or selector, got *ast.BinaryExpr'. The slash is being parsed as a division operator by the Go expression parser in resolveSymbolQuery.\n\nReproduce:\n```\n./wildcat ls internal/commands.Wildcat\nError: (path_not_found) cannot resolve \"internal/commands.Wildcat\": expected identifier or selector, got *ast.BinaryExpr\n```\n\nThe workaround is using short package name: `./wildcat ls commands.Wildcat`\n\nFix: The spath.Parse should be tried first since it handles paths with slashes. Only fall back to Go expression parsing for simple queries.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-27T07:37:54.375327919Z","updated_at":"2026-01-27T07:38:39.700665961Z","closed_at":"2026-01-27T07:38:39.700665961Z"}
{"id":"wc-c0dc","content_hash":"c3c4e1c344257472acbde8ee9781004892f1e15589bb0b3dcfca27bbb8483231","title":"tree command returns nothing for main.main --down","description":"Bug: wildcat tree main.main --down returns no results.\n\nExpected: Should show the call tree of what main.main calls.\n\nNeed to investigate:\n- Is the symbol being resolved correctly?\n- Is --down being parsed correctly (vs --direction down)?\n- Is there an issue with the call hierarchy traversal?","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-16T11:23:40.762481357Z","updated_at":"2026-01-16T13:32:13.803877145Z","closed_at":"2026-01-16T13:32:13.803877145Z"}
{"id":"wc-c43b","content_hash":"aae4977571492d15ee20c04a844539954e681ed517c2d2b44ca972ef1160cecd","title":"symbol: support multiple symbol arguments","description":"Allow passing multiple symbols to the symbol command for batch analysis. Example: wildcat symbol Foo Bar Baz. Each symbol should be analyzed and results combined in output.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-22T15:30:19.321786815Z","updated_at":"2026-01-22T15:33:43.21110388Z","closed_at":"2026-01-22T15:33:43.21110388Z"}
{"id":"wc-c45d","content_hash":"2d27a45e20c3d47a41a6e537a96b701c40a83c374788fb5ef4a610b596c7eaa6","title":"Package markdown: Imports/Imported By rendering broken","description":"Shows empty bullets instead of package names:\n\n## Imports\n- ``\n- ``\n\nJSON has the data ({\"package\": \"context\", \"location\": \"...\"}) but markdown template isn't extracting it.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-18T05:47:12.004963704Z","updated_at":"2026-01-18T05:57:37.690563864Z","closed_at":"2026-01-18T05:57:37.690563864Z"}
{"id":"wc-c557","content_hash":"3413d4dcfce0e1c08f7f8e14ff6ffa0f127eb514e710c7bcd3a37f7fe8959d19","title":"Audit snippet extraction for byte-for-byte fidelity","description":"Review the snippet extraction code in `internal/output/snippet.go` to ensure it returns byte-for-byte content from source files.\n\n**Concern:**\nThe current implementation uses `bufio.Scanner` to split files into lines, caches them as `[]string`, then reassembles with `strings.Join(lines, \"\\n\")`. This approach may:\n- Lose trailing newlines\n- Normalize line endings (CRLF vs LF)\n- Lose other whitespace at line boundaries\n\n**For Claude's Edit tool:**\nByte-for-byte fidelity matters because the Edit tool does exact string matching. If the snippet shown doesn't exactly match the file content, Edit will fail.\n\n**Audit should check:**\n1. `getLines()` - uses Scanner which splits on newlines\n2. `Extract()` / `ExtractRange()` - rejoins with `\\n`\n3. `ExtractSmart()` - same pattern\n\n**Potential fix:**\nRead file as bytes, find line boundaries, extract byte ranges directly without splitting/rejoining. Or cache the raw bytes alongside the line index.\n\n**Goal:** Ensure snippets can be used reliably with the Edit tool by preserving exact file content.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-26T10:35:56.661521287Z","updated_at":"2026-01-26T10:41:54.399736092Z","closed_at":"2026-01-26T10:41:54.399736092Z"}
{"id":"wc-c565","content_hash":"c298a8c6cb6c10f733ba9636119cadb7d50c81f4fe6f8d123599d7e2a9c5d70f","title":"Build path spec from Go language specification","description":"Create a comprehensive path specification derived directly from the Go language spec to ensure full representation of all addressable language constructs.\n\n**Goal:**\nThe path syntax should be able to address ANY element in Go source code. Derive the vocabulary systematically from the Go spec rather than ad-hoc.\n\n**Go language constructs to cover:**\n\nFrom the Go spec (https://go.dev/ref/spec):\n\n1. **Declarations**\n   - Package: `pkg`\n   - Import: `pkg/imports[name]` or `pkg/imports[0]`\n   - Const: `pkg.ConstName`\n   - Var: `pkg.VarName`\n   - Type: `pkg.TypeName`\n   - Func: `pkg.FuncName`\n   - Method: `pkg.Type.Method`\n\n2. **Type components**\n   - Struct fields: `pkg.Type.Field` or `pkg.Type[0]`\n   - Interface methods: `pkg.Interface.Method`\n   - Embedded types: `pkg.Type/embeds[EmbeddedType]`\n\n3. **Function components**\n   - Parameters: `/params[name]` or `/params[0]`\n   - Results: `/returns[name]` or `/returns[0]`\n   - Body: `/body`\n   - Receiver: `/receiver` (for methods)\n\n4. **Additional addressable elements**\n   - Doc comments: `/doc`\n   - Struct tags: `.Field/tag`\n   - Type parameters (generics): `/typeparams[T]`\n   - Constraints: `/typeparams[T]/constraint`\n\n5. **Block structure** (future consideration)\n   - Statements: `/body/stmts[N]` or content-based\n   - Labels: `/body/labels[name]`\n\n**Deliverable:**\nUpdate docs/path-syntax.md with complete grammar derived from Go spec. Include:\n- EBNF or similar formal grammar\n- Complete list of path categories (/params, /returns, /body, /doc, /tag, etc.)\n- Resolution rules (how short names resolve to full paths)\n- Ambiguity handling\n\n**Research:**\n- Review Go language spec: https://go.dev/ref/spec\n- Review go/ast package types for implementation mapping\n- Compare with existing systems (XPath, ESQuery, tree-sitter) documented in conversation\n\n**See also:**\n- docs/path-syntax.md (current spec)\n- docs/semantic-feedback.md (AI feedback on design)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-27T03:36:15.86791762Z","updated_at":"2026-01-27T05:27:06.738919942Z","closed_at":"2026-01-27T05:27:06.738919942Z"}
{"id":"wc-c583","content_hash":"77d388e21376af4d63003e82800ad9eb41c757deb5943721ab82c7e38367255e","title":"Snippet extractor AST fallbacks hide parse errors","description":"In snippet.go, AST parsing errors cause silent fallback to simpler extraction:\n\nLocations:\n- snippet.go:72-78 (ExtractSmart): AST error -\u003e line-based fallback\n- snippet.go:290-293 (mergeLocationsByDeclaration): parse error -\u003e proximity merge\n- snippet.go:463-479 (extractMergedSnippet): parse error -\u003e simple range\n\nImpact: AI doesn't know the file couldn't be parsed. Might be syntax errors in the code being analyzed.\n\nNote: This is arguably intentional fallback behavior, but some indication that AST parsing failed could be valuable.\n\nOptions:\n- Add warning/error field to Snippet struct\n- Log when fallback occurs\n- Accept as intentional graceful degradation (document decision)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:52:40.722466386Z","updated_at":"2026-01-26T04:32:18.90881305Z","closed_at":"2026-01-26T04:32:18.90881305Z","dependencies":[{"issue_id":"wc-c583","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:52:40.738931953Z","created_by":"jason"}]}
{"id":"wc-c5a4","content_hash":"203cb56195a8208c04c73d85cf739a719b21df959cdbbe0ca45cbcde3d81a960","title":"Audit: symbol command - Package facility usage","description":"Audit the symbol command for appropriate use of Package facilities:\n\n**Facilities to consider:**\n- `Types.Scope()` - package-level declarations, already type-resolved\n- `TypesInfo.Defs/Uses` - AST ident → object mappings  \n- `Syntax` (AST) - needed for formatting, file association\n\n**Questions to answer:**\n1. Where do we iterate AST when Scope() would be cleaner?\n2. Where do we lookup in TypesInfo with nil checks that could be avoided?\n3. Is AST formatting needed, or could types.TypeString suffice?\n4. Are we using the right facility for each task?\n\n**Known areas to review:**\n- findImplementations (recently refactored to use TypesInfo.Defs)\n- findConsumers - iterates AST looking for funcs with interface params\n- findSatisfies - iterates AST looking for interfaces\n- Reference finding with TypesInfo.Uses\n\nPart of broader Package facility audit. Supersedes wc-389a.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-24T11:14:40.110099223Z","updated_at":"2026-01-25T09:37:54.476026357Z","closed_at":"2026-01-25T09:37:54.476026357Z"}
{"id":"wc-c5c4","content_hash":"67c48a65822ce016f20396379151470e77626170f048170c88f71bf278193db1","title":"Unify package markdown output: default vs -o markdown","description":"The package command has two separate markdown rendering paths:\n\n1. Default (no -o flag): uses renderPackageMarkdown() in cmd/package.go\n2. -o markdown flag: uses MarkdownFormatter in internal/output/formatter.go\n\nThese produce different output formats, which is confusing.\n\nExample differences:\n- Default uses '# package X' header, -o markdown uses '# Package: X'\n- Default uses inline comments (signature // location), -o markdown uses tables\n- Imports grouping logic is duplicated\n\nOptions:\n1. Remove the separate renderPackageMarkdown and always use the formatter\n2. Keep both but document the difference (compact vs verbose)\n3. Unify the formatter to match the compact default style\n\nThe default compact style is preferred for AI consumption - should probably make -o markdown match it.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-18T08:18:52.495409132Z","updated_at":"2026-01-18T08:20:08.219375925Z","closed_at":"2026-01-18T08:20:08.219375925Z"}
{"id":"wc-c60c","content_hash":"b40f924df1ffe40196ac41c3623166c164a01fef8be0e36b8513bbb1e2711276","title":"Filter unexported stdlib interfaces from satisfies list","description":"**Problem:**\nTypes show unexported internal stdlib interfaces in their \"satisfies\" list:\n\n```\ntype Id struct{ id string } // satisfies: context.stringer, os/signal.stringer, runtime.stringer, fmt.Stringer, ...\n```\n\n**Issue:**\n`context.stringer`, `os/signal.stringer`, `runtime.stringer` are unexported internal interfaces that happen to have the same signature as `fmt.Stringer`. They add noise without value.\n\n**Expected:**\nOnly show:\n- Exported interfaces (`fmt.Stringer`, `json.Marshaler`, etc.)\n- Project-defined interfaces (exported or not, as they're intentional)\n\n**Filter rules:**\n1. Skip unexported stdlib interfaces (lowercase name + stdlib package)\n2. Keep exported stdlib interfaces\n3. Keep all project interfaces\n\n**Related:**\n- wc-22c3 (error alias implementers regression)","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-29T04:10:33.986784209Z","updated_at":"2026-01-29T04:21:07.873650534Z","closed_at":"2026-01-29T04:21:07.873650534Z"}
{"id":"wc-c687","content_hash":"8566d7c197417e55a01ed276b58f1d8b512f786b116b232c6d1a2209cf72d1d8","title":"read command: call depth option for expanded output","description":"Add a `--depth` or `--expand` flag to read that follows calls and renders them inline.\n\nExample:\n```\nwildcat read spath.Parse --depth 1\n```\n\nWould show Parse plus the immediate calls it makes (parser.parse), rendered together.\n\n`--depth 2` would include parser.parse's calls (findPackageSymbolBoundary, parseSymbol, parseSubpath).\n\nUse cases:\n- \"Show me how this function works end-to-end\"\n- Understanding a call chain without multiple round trips\n- Getting full context for making changes\n\nConsiderations:\n- Output size limits - may need truncation or summarization\n- Cycle detection for recursive calls\n- Could integrate with tree command's call graph analysis\n- Maybe show collapsed/expandable sections in markdown output","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-27T14:25:00.282810688Z","updated_at":"2026-01-28T07:10:35.243180468Z","closed_at":"2026-01-28T07:10:35.243180468Z"}
{"id":"wc-c6e3","content_hash":"c37149d240a277d9efc8a44ce14909085a787bfffdabcdc35b6ed8359df3fe62","title":"Add wildcat deadcode command - detect unreachable code","description":"Add a command to detect dead/unreachable code in a Go codebase.\n\nPotential approaches:\n- Use callers/refs to find symbols with no references\n- Leverage gopls or go/analysis for reachability analysis\n- Consider exported vs unexported symbols differently\n- Handle main packages and test files appropriately\n\nOutput should identify:\n- Unexported functions/methods never called\n- Unexported types never instantiated\n- Unexported constants/variables never referenced\n- Potentially exported symbols only used within the same package\n\nRelated to existing commands: callers, refs, impact","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-14T07:20:42.930939262Z","updated_at":"2026-01-21T14:17:51.347809181Z","closed_at":"2026-01-21T14:17:51.347809181Z"}
{"id":"wc-c79f","content_hash":"953fe438ed551c4331dc65a97da4fbf328bead44df921a720646262fa57f4934","title":"Establish error handling philosophy and consistency","description":"The codebase has multiple error handling patterns without a guiding principle:\n\nCurrent patterns observed:\n1. Return Go error (bubbles up, CLI shows it)\n2. Return *ErrorResult (structured error with code, suggestions, context)\n3. Panic (crashes tool)\n4. Silent continue/return (loses information)\n5. Inline in output - proposed in wc-79d6 for signatures\n6. Diagnostics channel - proposed in wc-f06a for non-fatal issues\n\nNeed to establish when each is appropriate:\n\nProposed philosophy:\n\n**Fatal errors (analysis cannot proceed)** -\u003e Return error or *ErrorResult\n- Package not found\n- Invalid symbol name\n- Scope pattern syntax error\n- File system errors that block loading\n\n**User input errors** -\u003e Return *ErrorResult with suggestions\n- Symbol not found (include fuzzy matches)\n- Invalid --kind value (list valid kinds)\n- Ambiguous symbol (list candidates)\n\n**Partial failures (analysis degraded but useful)** -\u003e Diagnostics (wc-f06a)\n- Some packages had type errors\n- Some files couldn't be parsed\n- TypesInfo lookups failed for N symbols\n\n**Rendering failures (display issue, not analysis issue)** -\u003e Inline (wc-79d6)\n- Signature couldn't be formatted\n- Snippet extraction failed\n- Location couldn't be determined\n\n**Never appropriate:**\n- Panic (convert to error)\n- Silent discard (convert to diagnostic or inline)\n\nAdditional consistency needed:\n- Error codes: establish naming convention (snake_case, namespaced?)\n- Error messages: establish tone/format\n- Suggestions: when to include, how many\n- Context: what metadata to attach\n\nThis ticket is about documenting the philosophy and creating a checklist for code review. Implementation of the philosophy happens in the individual tickets.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-23T06:03:18.767878043Z","updated_at":"2026-01-26T05:12:31.018104411Z","closed_at":"2026-01-26T05:12:31.018104411Z","dependencies":[{"issue_id":"wc-c79f","depends_on_id":"wc-f06a","type":"related","created_at":"2026-01-23T06:03:24.374640214Z","created_by":"jason"},{"issue_id":"wc-c79f","depends_on_id":"wc-79d6","type":"related","created_at":"2026-01-23T06:03:24.422259719Z","created_by":"jason"}]}
{"id":"wc-ca02","content_hash":"3bb75aa677ad77cdd74e7a822089f91a5644bbc8a23819c5022a244dc8d58b71","title":"Migrate commands to shared ScopeFilter","description":"Update symbol, search, and tree commands to use the new shared ScopeFilter from commands/scope.go instead of their own scope parsing implementations. This will ensure consistent package resolution across all commands.\n\nCommands to update:\n- internal/commands/symbol/symbol.go (has its own scopeFilter type and parseScope)\n- internal/commands/search/search.go (has filterByScope function)\n- internal/commands/tree/tree.go (has scope handling)\n\nThe new ScopeFilter provides:\n- Consistent package path resolution via ResolvePackageName\n- IsTarget() for exact target matching\n- InScope() for scope filtering (project/all/includes/excludes)\n","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-21T12:38:54.69607806Z","updated_at":"2026-01-21T14:20:55.167651615Z","closed_at":"2026-01-21T14:20:55.167651615Z"}
{"id":"wc-cadc","content_hash":"927632e45f5a33e18f6f7c0ebc6b6a87055f6f13f94a20ab9cda77254cb85e4b","title":"Migrate LSP client to go.lsp.dev/protocol","description":"Replace custom LSP JSON-RPC implementation with go.lsp.dev/jsonrpc2 and go.lsp.dev/protocol libraries.\n\n## Why\n- Battle-tested implementation handles LSP protocol edge cases\n- Discovered we missed server-to-client requests (window/workDoneProgress/create)\n- Reduces maintenance burden for protocol nuances\n\n## Scope\n- Replace internal/lsp/jsonrpc.go with go.lsp.dev/jsonrpc2\n- Update internal/lsp/protocol.go to use go.lsp.dev/protocol types\n- Simplify internal/lsp/client.go to use library handlers\n- Remove custom notification/request handling code\n\n## Acceptance Criteria\n- [ ] All existing tests pass\n- [ ] Commands work identically\n- [ ] Progress notifications still work for WaitForReady","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-15T14:38:38.584698412Z","updated_at":"2026-01-18T07:27:59.015642082Z","closed_at":"2026-01-18T07:27:59.015642082Z"}
{"id":"wc-cb10","content_hash":"3530ccc4c877c7fb870cdb32cbfd1b7456eaf38a2cad1bed23fd70c43bfba3d0","title":"LSP client infrastructure","description":"## Context\nFollowing the LSP feasibility research (wc-d974), we're pivoting to an LSP-based architecture. This makes Wildcat language-agnostic, supporting any language with an LSP server.\n\n## Architecture Decision\n**Wildcat as LSP Orchestrator**: We use LSP servers (gopls, rust-analyzer, pyright, etc.) as backends, orchestrating multiple calls, handling recursion, extracting snippets, and formatting output for AI consumption.\n\n## Scope\nCreate `internal/lsp` package that:\n\n### 1. LSP Client Core\n- JSON-RPC 2.0 client over stdio\n- Request/response with ID tracking\n- Notification handling\n- Timeouts and error handling\n\n### 2. Server Lifecycle Management\n- Start LSP server process\n- Initialize/shutdown handshake\n- Keep-alive for multiple queries\n- Graceful cleanup\n\n### 3. Core LSP Methods\nImplement wrappers for:\n- `initialize` / `shutdown`\n- `textDocument/didOpen` (for symbol lookup context)\n- `workspace/symbol` - find symbols by name\n- `textDocument/prepareCallHierarchy`\n- `callHierarchy/incomingCalls`\n- `callHierarchy/outgoingCalls`\n- `textDocument/references`\n- `textDocument/implementation`\n- `textDocument/typeDefinition`\n\n### 4. Protocol Types\nDefine Go types for:\n- Position, Range, Location\n- TextDocumentIdentifier\n- SymbolInformation\n- CallHierarchyItem, CallHierarchyIncomingCall, CallHierarchyOutgoingCall\n- ReferenceParams, ImplementationParams\n\n## Interface Design\n```go\ntype Client interface {\n    // Lifecycle\n    Initialize(ctx context.Context, rootURI string) error\n    Shutdown(ctx context.Context) error\n\n    // Symbol lookup\n    WorkspaceSymbol(ctx context.Context, query string) ([]SymbolInformation, error)\n\n    // Call hierarchy\n    PrepareCallHierarchy(ctx context.Context, uri string, pos Position) ([]CallHierarchyItem, error)\n    IncomingCalls(ctx context.Context, item CallHierarchyItem) ([]CallHierarchyIncomingCall, error)\n    OutgoingCalls(ctx context.Context, item CallHierarchyItem) ([]CallHierarchyOutgoingCall, error)\n\n    // References\n    References(ctx context.Context, uri string, pos Position) ([]Location, error)\n    Implementation(ctx context.Context, uri string, pos Position) ([]Location, error)\n}\n\ntype ServerConfig struct {\n    Command  string   // e.g. \"gopls\", \"rust-analyzer\"\n    Args     []string // e.g. [\"-mode=stdio\"]\n    RootURI  string   // workspace root\n}\n```\n\n## Acceptance Criteria\n- [ ] JSON-RPC client over stdio works\n- [ ] Can start/stop LSP server\n- [ ] Initialize handshake succeeds\n- [ ] workspace/symbol returns results\n- [ ] Call hierarchy methods work\n- [ ] References method works\n- [ ] Proper timeout handling\n- [ ] Unit tests with mock server\n- [ ] Integration test with gopls\n\n## Files\n- internal/lsp/client.go\n- internal/lsp/protocol.go (types)\n- internal/lsp/jsonrpc.go\n- internal/lsp/server.go (lifecycle)\n- internal/lsp/*_test.go\n\n## Why This Matters\nThis is the foundation for language-agnostic support. Every Wildcat command will use this client to communicate with language servers.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-10T04:56:59.354691328Z","updated_at":"2026-01-10T05:26:40.66299368Z","closed_at":"2026-01-10T05:26:40.66299368Z"}
{"id":"wc-cb13","content_hash":"a35feb1d678e4ceceaa851ce7f4b4f42977fd6ff5a2babf37cf9a0276c5702a8","title":"Bug: symbol command shows wrong signature for constants","description":"Symbol command returns incorrect signature when querying constants.\n\n## Reproduction\n```\nwildcat symbol id.TaskIdNamespace\n```\n\n## Actual Output\n```json\n{\n  \"query\": {\n    \"command\": \"symbol\",\n    \"target\": \"id.TaskIdNamespace\",\n    \"resolved\": \"github.com/jasonmoo/bbb/database/id.TaskIdNamespace\",\n    \"scope\": \"project\"\n  },\n  \"target\": {\n    \"symbol\": \"github.com/jasonmoo/bbb/database/id.TaskIdNamespace\",\n    \"signature\": \"const TracesIdNamespace Namespace\",  // WRONG\n    \"definition\": \"/home/jason/go/src/github.com/jasonmoo/bbb/database/id/namespaces.go:18:18\"\n  }\n}\n```\n\n## Expected\nSignature should be `const TaskIdNamespace Namespace` (matching the queried symbol).\n\n## Likely Cause\nConstants in Go can be grouped in a single `const` block, sharing an `ast.ValueSpec`. The signature formatting may be picking the wrong identifier from the spec, or the wrong spec entirely.\n\n## Investigation\n- Check how `FormatValueSpec` handles multi-name ValueSpecs\n- Check how symbol lookup resolves to the correct ValueSpec\n- Verify the correct identifier is being used when formatting","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-21T06:02:53.912252954Z","updated_at":"2026-01-21T06:28:23.794433767Z","closed_at":"2026-01-21T06:28:23.794433767Z"}
{"id":"wc-cb8b","content_hash":"35a381c313e7a704c7989770a254f972adcc70b71392c8e84e9fcb8f1457fe1b","title":"Audit: tree command - Package facility usage","description":"Audit the tree command for appropriate use of Package facilities:\n\n**Facilities to consider:**\n- `Types.Scope()` - package-level declarations, already type-resolved\n- `TypesInfo.Defs/Uses` - AST ident → object mappings\n- `Syntax` (AST) - needed for formatting, file association\n\n**Questions to answer:**\n1. Where do we iterate AST when Scope() would be cleaner?\n2. Where do we lookup in TypesInfo with nil checks that could be avoided?\n3. Is AST formatting needed, or could types.TypeString suffice?\n4. Are we using the right facility for each task?\n\nPart of broader Package facility audit. Supersedes wc-389a.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-24T11:14:44.709343922Z","updated_at":"2026-01-24T11:20:48.853563322Z","closed_at":"2026-01-24T11:20:48.853563322Z"}
{"id":"wc-cc1e","content_hash":"86e820b5f19483951ced2fb957f9b63d32711a1832f97dd8b3179ee7446d6931","title":"Support glob/prefix patterns in --scope exclusions","description":"Allow patterns like -internal/* to exclude multiple packages at once.\n\nCurrently --scope -pkg requires exact package paths. Glob patterns would be more flexible:\n- -internal/* excludes all internal packages\n- -*_test could exclude test packages (if we had them)\n- -cmd/* excludes all cmd subpackages\n\nDiscovered from wc-1393 (documenting scope syntax).","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-22T15:57:43.335915332Z","updated_at":"2026-01-23T02:47:20.80237659Z","closed_at":"2026-01-23T02:47:20.80237659Z"}
{"id":"wc-cc53","content_hash":"90184715a2cad57f0c340a247ae54701025328b02ae2c82ad1874fdcbdf07c37","title":"Clean up dead code in wildcat project","description":"Use the deadcode command to identify and remove unreachable code.\n\n## Context\nWildcat is a CLI tool, not a library. Any code not reachable from main/init\nis dead code and safe to remove. After recent refactoring (visitor APIs,\nnative commands), there's likely accumulated dead code.\n\n## Process\n1. Run `./wildcat deadcode ./...` to identify unreachable functions/methods\n2. Review each candidate - confirm it's truly unused\n3. Remove dead code in batches, testing between each\n4. Run tests after cleanup to verify nothing breaks\n\n## Benefits\n- Smaller, cleaner codebase\n- Faster builds\n- Less cognitive overhead\n- Dogfooding the deadcode command\n\n## Notes\n- Watch for false positives (reflect-based calls, interface satisfaction)\n- Some \"dead\" code may be intentionally kept for future use - use judgment","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-22T04:07:46.972185081Z","updated_at":"2026-01-22T13:46:58.367494785Z","closed_at":"2026-01-22T13:46:58.367494785Z"}
{"id":"wc-cccd","content_hash":"a96fca678d43386cd39bd3ea5e0e365b46119ff161fe6d5ee2f938ce243ba2de","title":"Document tree command function/method limitation","description":"tree only works on functions/methods but docs don't mention this.\n\nError message is clear: \"Content is not a function\"\n\nSuggest adding to docs: \"Note: tree operates on functions and methods only, not types or constants.\"","status":"closed","priority":3,"issue_type":"chore","created_at":"2026-01-18T05:47:12.355493993Z","updated_at":"2026-01-18T05:57:37.725735506Z","closed_at":"2026-01-18T05:57:37.725735506Z"}
{"id":"wc-cce9","content_hash":"22cb234993897c5754933010613a29730716356f625067b38e18ab1b2767edf9","title":"Stop tree traversal at stdlib boundary for down direction","description":"When direction=down, we currently recurse into stdlib internals (e.g., fmt.Sprintf → fmt.newPrinter → fmt.free). This clutters output with irrelevant details. Should stop at stdlib functions - show the call to fmt.Sprintf but don't recurse into its implementation.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-15T03:12:47.391825805Z","updated_at":"2026-01-15T05:07:26.157177715Z","closed_at":"2026-01-15T05:07:26.157177715Z","dependencies":[{"issue_id":"wc-cce9","depends_on_id":"wc-f890","type":"blocks","created_at":"2026-01-15T03:12:47.398891414Z","created_by":"jason"}]}
{"id":"wc-ce00","content_hash":"a3cf8ee1838dbc3db82cf5d2c7fd88e91bfa834355bec4dbe54b467ea46db904","title":"Bug: Duplicate package name in resolved symbol output","description":"When resolving symbols, output shows duplicate package names like:\n\n  \"resolved\": \"github.com/jasonmoo/bbb/database/model.model.Task\"\n\nShould be:\n\n  \"resolved\": \"github.com/jasonmoo/bbb/database/model.Task\"\n\nRoot cause: gopls returns Name as \"model.Task\" (with package prefix) and ContainerName as the full path. formatSymbol() concatenates them, creating duplication.\n\nFix: Detect when Name already starts with the short package name and avoid double-prefixing.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-12T14:02:20.694724208Z","updated_at":"2026-01-12T14:04:49.030500076Z","closed_at":"2026-01-12T14:04:49.030500076Z"}
{"id":"wc-cea9","content_hash":"0dcd8ffca4b67900689e7e60077837788ff089dd28f17dd559353e7a289e1ecf","title":"Update search output to match symbol structure","description":"Restructure search results to use package-organized output like symbol command:\n- Group results by package using PackageUsage\n- Include dir field per package\n- Use consistent Location/Snippet types\n- Add scope to query output","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-16T08:27:36.661961551Z","updated_at":"2026-01-16T11:07:38.359506316Z","closed_at":"2026-01-16T11:07:38.359506316Z"}
{"id":"wc-cf03","content_hash":"fed8e5e762e804cca4593d1b6b8842368b298dbb2e3136944976a153c8bd53f9","title":"Generic interface instantiation errors silently discarded","description":"In interfaces.go, types.Instantiate errors are silently ignored when checking if types implement generic interfaces:\n\nLocations:\n- interfaces.go:199-210 (IsInterfaceMethod)\n- interfaces.go:270-280 (FindSatisfiedInterfaces)\n\nPattern:\n  if inst, err := types.Instantiate(...); err == nil { ... }\n\nImpact: If generic interface instantiation fails, the type silently appears to not implement the interface. AI doesn't know why.\n\nOptions:\n- Log instantiation failures\n- Include in output as 'could_not_check' field\n- Track and report at end","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:52:00.463413939Z","updated_at":"2026-01-26T04:27:01.795190059Z","closed_at":"2026-01-26T04:27:01.795190059Z","dependencies":[{"issue_id":"wc-cf03","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:52:00.481389927Z","created_by":"jason"}]}
{"id":"wc-cfc7","content_hash":"d063cc51ceeb8b6c74bf7ab926dcc8b55e4067d6751c47c6026515a43253323d","title":"Default scope to 'project' for search and symbol commands","description":"Currently:\n- search defaults to all (including external dependencies)\n- symbol defaults to target package only\n\nProposed: Both should default to 'project' scope for consistency and typical usage.\n\nUsers can still use --scope to narrow (specific packages) or the commands will need an 'all' scope if users want to include external deps in search.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-16T11:24:18.591669743Z","updated_at":"2026-01-16T11:29:59.359994174Z","closed_at":"2026-01-16T11:29:59.359994174Z"}
{"id":"wc-d133","content_hash":"c21e2a493ff2e88b4a6e48c9b63c0255c1e4b47067bdb046d6543a767dc0cf18","title":"lookup-error on blank identifier interface checks (var _ Type = ...)","description":"**Problem:**\nReference output shows `\u003clookup-error\u003e` for blank identifier declarations used for compile-time interface checks:\n```go\nvar _ Object = (*Task)(nil)\n```\n\n**Context:**\nThese `var _ Interface = (*ConcreteType)(nil)` patterns are common Go idioms for compile-time interface satisfaction checks. The blank identifier `_` isn't a real symbol, so lookup fails.\n\n**Expected behavior:**\nEither:\n- Skip blank identifier declarations in reference output\n- Or handle them gracefully without error tokens\n\n**Likely cause:**\nSymbol lookup code trying to resolve `_` as a named symbol when walking references or displaying results.","status":"open","priority":2,"issue_type":"bug","created_at":"2026-01-29T01:48:13.893972169Z","updated_at":"2026-01-29T01:48:13.893972169Z"}
{"id":"wc-d4a4","content_hash":"630b81e0366da49dde4b5ee48680aa1fffa2d99e3975df339da229c682315732","title":"findImplementations silently skips types with nil type info","description":"In symbol.go, findImplementations silently skips types when TypesInfo lookup fails:\n\n- Line 632: typeObj nil check in main implementation loop\n- Line 1046: ifaceObj nil check when finding interface implementers\n\nImpact: AI sees 'types that implement X' but doesn't know some types couldn't be checked.\n\nFix: Track count of skipped types, add diagnostic like 'N types could not be checked for interface implementation'.\n\nSplit from wc-3c75.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T15:09:58.776618123Z","updated_at":"2026-01-24T10:31:00.556791805Z","closed_at":"2026-01-24T10:31:00.556791805Z"}
{"id":"wc-d974","content_hash":"ccfb717b986bbba299f71e4d24ae05b07c70a6eb649c93abdfdc3e0763d0bca6","title":"Research LSP protocol for language-agnostic approach","description":"## Context\nBefore committing to Go-specific implementation, explore whether LSP (Language Server Protocol) can provide the features we need. If yes, Wildcat could be language-agnostic, working with any language that has an LSP server.\n\nThis is a potential PIVOT that would change our architecture significantly.\n\n## Key Questions\n\n### 1. Feature Coverage\nDoes LSP provide what we need for each Wildcat command?\n\n| Command | LSP Method | Sufficient? |\n|---------|------------|-------------|\n| callers | callHierarchy/incomingCalls | ? |\n| callees | callHierarchy/outgoingCalls | ? |\n| tree | recursive call hierarchy? | ? |\n| refs | textDocument/references | ? |\n| impact | combination of above? | ? |\n| implements | textDocument/implementation | ? |\n\n### 2. Call Hierarchy Depth\n- Does LSP support transitive/recursive call hierarchy?\n- Or only direct callers/callees (depth 1)?\n- Would we need to make recursive calls ourselves?\n\n### 3. Output Richness\n- Do responses include snippets/context?\n- File paths, line numbers, columns?\n- Enough for AI tool consumption?\n\n### 4. Performance\n- LSP is designed for interactive IDE use\n- How does it perform for batch queries?\n- Startup time for LSP servers?\n- Can we keep server running for multiple queries?\n\n### 5. Cross-Language Consistency\nSurvey LSP support across key languages:\n- Go (gopls)\n- Python (pyright, pylsp)\n- TypeScript/JavaScript (typescript-language-server)\n- Rust (rust-analyzer)\n- Java (eclipse.jdt.ls)\n- C/C++ (clangd)\n\nWhich features are consistently available?\n\n### 6. Symbol Specification\n- How do we specify symbols in LSP? (need file:line:col?)\n- Can we query by name like \"pkg.Func\"?\n- This was a key gopls limitation - does LSP protocol solve it?\n\n## Research Tasks\n\n1. **Read LSP 3.17 spec** for call hierarchy, references, implementation\n2. **Test gopls LSP mode** - make actual LSP calls, examine responses\n3. **Compare responses** to our desired output format\n4. **Test other LSP servers** - at least one other language\n5. **Evaluate recursive queries** - can we build trees?\n6. **Assess performance** - time queries, measure overhead\n\n## Deliverables\n\nCreate `docs/lsp-feasibility.md` with:\n1. Feature-by-feature LSP capability assessment\n2. Sample LSP request/response for each feature\n3. Gap analysis: what LSP provides vs what we need\n4. Cross-language support matrix\n5. Performance observations\n6. Recommendation: Go-specific vs LSP-based vs hybrid\n\n## Decision Criteria\n\n**Go with LSP if:**\n- Call hierarchy provides depth/recursive queries OR easy to implement client-side\n- Output is rich enough (file, line, context)\n- Performance is acceptable for batch use\n- Good support across 3+ major languages\n\n**Stay Go-specific if:**\n- LSP call hierarchy is too limited (depth 1 only, no recursion)\n- Output lacks necessary context\n- Performance is problematic\n- Cross-language support is inconsistent\n\n## Why This Matters\nLanguage-agnostic tool = much larger impact. But only if LSP can deliver the depth of analysis we need. This research determines our path.\n\n## Priority\nP0 - This decision affects all subsequent work. Must resolve before continuing with wc-af7d.1.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-10T04:16:58.761377704Z","updated_at":"2026-01-10T04:54:55.767044668Z","closed_at":"2026-01-10T04:54:55.767044668Z"}
{"id":"wc-db4f","content_hash":"af308b56cfa41f62f7354c700adce599aa66b3b4f8a7d6d74bf99851e944d434","title":"Tree buildCallersTree silently returns on nil types.Object","description":"In tree.go:337-340, buildCallersTree silently returns nil when TypesInfo.Defs lookup fails:\n\nLocation: internal/commands/tree/tree.go:337-340\n\nCode:\n  targetObj := targetPkg.Package.TypesInfo.Defs[targetFn.Name]\n  if targetObj == nil {\n    return nil\n  }\n\nImpact: Caller tree analysis silently stops. AI sees empty callers without knowing why (could be symbol resolution issue vs actually no callers).\n\nOptions:\n- Return error from buildCallersTree\n- Include 'analysis_incomplete' flag in TreeCommandResponse\n- Track and report when analysis couldn't proceed","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:53:30.240193691Z","updated_at":"2026-01-23T15:00:00.226923463Z","closed_at":"2026-01-23T15:00:00.226923463Z","dependencies":[{"issue_id":"wc-db4f","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:53:30.255965608Z","created_by":"jason"}]}
{"id":"wc-dcda","content_hash":"0d6d500446c7a518bac167c82bed057ccf287ca7b4b3d0e9bc14be0a53bdd496","title":"Group Satisfies and Implementations by package","description":"Group the Satisfies and Implementations sections by package like References is grouped. This allows using short file:start:end annotations instead of full paths.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-22T06:08:57.723102524Z","updated_at":"2026-01-22T06:12:29.224899793Z","closed_at":"2026-01-22T06:12:29.224899793Z"}
{"id":"wc-dcf4","content_hash":"37aaf1d3b1bac6884798ac1da3cb36fdafbe6038dc7d0fa8c9f478170ddf1a8b","title":"Reorder commands in help output by scope hierarchy","description":"Order commands from broadest to narrowest scope:\n\n1. project (future command)\n2. package - package-level analysis\n3. symbol - symbol-level analysis  \n4. search - find symbols\n5. tree - call graph traversal\n6. channels - concurrency analysis\n\nThis creates a logical progression: project → package → symbol → search (find) → specialized (tree, channels).\n\nCurrently cobra orders commands alphabetically. Need to set custom order or use command groups.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-16T11:07:54.802412596Z","updated_at":"2026-01-17T08:03:45.6755171Z","closed_at":"2026-01-17T08:03:45.6755171Z"}
{"id":"wc-de3c","content_hash":"8fb5d715a7b12a044917b8b401e9c9c6f28c8abba5750e98a09dfac10f11f7cf","title":"Truncate multiline constants in package command output","description":"When listing constants in the package command, multiline constant values should be truncated for cleaner output. Currently multiline constants display in full which clutters the listing.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-15T02:26:12.925788307Z","updated_at":"2026-01-15T02:43:51.395662655Z","closed_at":"2026-01-15T02:43:51.395662655Z"}
{"id":"wc-deda","content_hash":"7032e37b375b7f190a685c7161047e190fbead76d75b2ae923ae20fd6c8efb8e","title":"Write README.md and product design doc","description":"## Context\nWe've completed research on gopls (see docs/gopls-report.md) and designed \nWildcat's approach through conversation. Need to capture this in formal docs.\n\n## Scope\n1. README.md - Public-facing, explains premise and value proposition\n   - Problem: gopls is IDE-focused, not AI-optimized\n   - Solution: Wildcat - Go static analysis for AI agents\n   - Key features: symbol-based queries, JSON output, actionable results\n   - Examples showing the difference\n\n2. docs/product-design.md - Detailed feature specs\n   - Target user: AI agents (Claude, etc.)\n   - Command specifications (callers, tree, refs, etc.)\n   - Output format specs (JSON structure)\n   - Filtering/limiting options\n   - Error handling approach\n\n## Acceptance Criteria\n- [ ] README.md captures value prop clearly\n- [ ] Product design doc has detailed specs for MVP commands\n- [ ] Both reference research in docs/gopls-report.md\n\n## Relevant Files\n- docs/gopls-report.md - Gap analysis\n- docs/research.md - Initial design notes","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:40:40.229778888Z","updated_at":"2026-01-10T03:43:57.002420885Z","closed_at":"2026-01-10T03:43:57.002420885Z"}
{"id":"wc-e0c3","content_hash":"19580d9f1f485b70e9b320141110b44d8d21b283620d5c1fc7e8fe25825329f1","title":"Add regex search to search command","description":"Auto-detect regex metacharacters (* + ? ^ $ [ ] { } ( ) | \\\\) and switch to regex mode. Matches against symbol names only (not full import paths). Results sorted by symbol name length (shorter first). Mode shown in output. Help text updated.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-22T10:16:42.284169031Z","updated_at":"2026-01-22T10:16:47.377939135Z","closed_at":"2026-01-22T10:16:47.377939135Z"}
{"id":"wc-e170","content_hash":"1a7fd3856b6f90b7ef09e188d620dfcc790a6be9a6f0d001d154c53419f05b3d","title":"make(chan) silently skipped when TypeOf returns nil","description":"In channels.go, the make case directly checks TypeOf(node) and silently skips if nil:\n\n```go\ncase \"make\":\n    if t := pkg.Package.TypesInfo.TypeOf(node); t != nil {\n        if ch, ok := t.Underlying().(*types.Chan); ok {\n            // emit op\n        }\n    }\n```\n\nThe second check (is it a channel?) is correct - make() can create maps/slices too. But the first check (TypeOf != nil) has the same silent failure pattern as wc-b21c.\n\nUnlike send/receive/close/range, we can't just call ChannelElemType here because that expects a channel expression, not a make() call. We'd need to inspect the AST of make's first argument to determine if it's a channel type when type info is unavailable.\n\nOptions:\n- Parse make's first arg AST to detect chan keyword\n- Emit with ElemType '\u003cunknown type\u003e' when TypeOf is nil but AST shows chan\n- Accept this limitation and document it\n\nRelated: wc-b21c (fixed)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-23T13:49:24.931203661Z","updated_at":"2026-01-26T04:49:15.195339573Z","closed_at":"2026-01-26T04:49:15.195339573Z","dependencies":[{"issue_id":"wc-e170","depends_on_id":"wc-b21c","type":"related","created_at":"2026-01-23T13:49:29.318715391Z","created_by":"jason"},{"issue_id":"wc-e170","depends_on_id":"wc-e649","type":"blocks","created_at":"2026-01-24T11:16:15.807057002Z","created_by":"jason"}]}
{"id":"wc-e19d","content_hash":"01010183ed19ad605404379f520df82515c5de6281b92b3fd20ffa3e189256d3","title":"Command Remodel: project/package/symbol/search/calltree","description":"Consolidate wildcat commands around clear scopes: project, package, symbol, search.\n\n## Commands to Remove\n- `completion` - not needed for AI tool\n- `formats` - list can go in help text or readme\n\n## Commands to Consolidate into `symbol` (renamed from `impact`)\nCurrent `impact` already has: callers, references, implementations\n\nCandidates to fold in:\n- `callers` → already in impact, remove standalone\n- `callees` → add to symbol output, remove standalone  \n- `refs` → already in impact as \"references\", remove standalone\n- `satisfies` → add to symbol output for types, remove standalone\n- `implements` → already in impact for interfaces, remove standalone\n\n## Commands to Consolidate into `package`\n- `deps` → package already has Imports and ImportedBy sections\n\n## Renames\n- `impact` → `symbol`\n- `symbols` → `search`\n\n## Final Command Set\n- `project` - project/module level info (new)\n- `package` - package profile with all symbols, imports, imported_by\n- `symbol` - everything about a specific symbol (def, callers, callees, refs, satisfies, implements)\n- `search` - fuzzy symbol search\n- `tree` - call tree traversal (keep separate - different purpose: visualization/exploration)\n- `channels` - concurrency analysis (specialized)\n- `readme` - AI onboarding\n- `version` - standard\n\n## Evaluation Needed\n1. Is `tree` redundant if `symbol` shows callers/callees? (I think no - tree is for multi-hop traversal)\n2. Does `package` fully replace `deps`? (Check if deps has anything extra)\n3. What's the right depth for callers/callees in symbol output? (Direct only vs transitive)","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-15T08:36:38.969203267Z","updated_at":"2026-01-16T06:31:38.798336442Z","closed_at":"2026-01-16T06:31:38.798336442Z"}
{"id":"wc-e1e7","content_hash":"120bb07b3b9b89ba0c39864a8cfa864d1f18687eccf1737564a6c527a266d864","title":"Research: Code coverage metrics integration","description":"Explore whether we can get code coverage metrics from Go tooling and integrate them into the package and project commands.\n\n## Research Findings\n\n### Can coverage be obtained via static analysis?\n\n**No.** Coverage fundamentally requires runtime execution. Static analysis can identify code paths and dead code, but cannot determine what percentage of code is actually executed by tests without running them.\n\n### Programmatic Coverage Consumption\n\n**`golang.org/x/tools/cover`** (already a wildcat dependency):\n\n```go\nfunc ParseProfiles(fileName string) ([]*Profile, error)\nfunc ParseProfilesFromReader(rd io.Reader) ([]*Profile, error)\n\ntype Profile struct {\n    FileName string          // e.g., \"github.com/foo/bar/file.go\"\n    Mode     string          // \"set\", \"count\", or \"atomic\"\n    Blocks   []ProfileBlock\n}\n\ntype ProfileBlock struct {\n    StartLine, StartCol int\n    EndLine, EndCol     int\n    NumStmt, Count      int  // NumStmt = statements in block, Count = execution count\n}\n```\n\n### Coverage Profile Format\n\n```\nmode: set\ngithub.com/foo/bar/file.go:10.5,15.2 3 1\n```\nFormat: `filename:startline.startcol,endline.endcol numstatements count`\n\n### Calculating Coverage\n\n```go\nvar covered, total int\nfor _, block := range profile.Blocks {\n    total += block.NumStmt\n    if block.Count \u003e 0 {\n        covered += block.NumStmt\n    }\n}\npct := float64(covered) / float64(total) * 100\n```\n\n## Approach: Progressive Enhancement\n\nAuto-detect coverage profiles anywhere in the codebase and enhance existing output when available. No test running - just read existing data.\n\n**Profile detection:** Walk the project tree, sniff for known filenames:\n- `coverage.out`, `cover.out`, `.coverprofile`, `c.out`\n- Profiles can live in any package directory (tests often generate them locally)\n- Merge all discovered profiles into unified coverage data\n\n**When no coverage data:** Silent - just don't show coverage annotations. Not an error.\n\n## Integration Ideas\n\n### Package Command\n- Show package coverage % in summary\n- Annotate functions with individual coverage\n\n### Project Command  \n- Add coverage % to package histogram bars\n- Annotate interface implementations: \"8 implementations, 80% coverage\"\n- Show coverage distribution across core packages\n\n### Symbol Command\n- Show function/method coverage if available\n- For types: aggregate coverage of all methods\n\n### Creative Possibilities\n- Heat map style: which packages have low coverage?\n- Interface coverage: are all implementations tested?\n- Call graph coverage: is this code path tested end-to-end?\n\n## Implementation Notes\n\n- Add `internal/golang/coverage.go` for profile parsing utilities\n- Walk project tree to discover all coverage profiles\n- Merge multiple profiles (same file may appear in multiple profiles)\n- Coverage data keyed by filename - need to map to packages\n- Profile filenames use import paths, not filesystem paths\n- Consider caching parsed/merged profiles per session\n\n## Acceptance Criteria\n- [x] Document what's feasible (static analysis: no, profile parsing: yes)\n- [x] Recommend approach (read existing profiles, progressive enhancement)\n- [ ] Implement coverage detection (walk + sniff)\n- [ ] Implement profile parsing and merging\n- [ ] Integrate into package/project/symbol commands","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-26T07:25:17.674137459Z","updated_at":"2026-01-27T03:27:26.078759842Z"}
{"id":"wc-e1f0","content_hash":"7da1861cbf660b726ce630bf2ba79d4b3c4e4b3a472819d257d421a0128e908b","title":"Make JSON output match markdown structure in deadcode command","description":"The JSON output of deadcode is currently a flat list of DeadSymbol, but the markdown output has rich structure:\n\n**Current JSON:**\n```json\n{\n  \"query\": {...},\n  \"summary\": {...},\n  \"dead\": [{symbol}, {symbol}, ...]\n}\n```\n\n**Desired JSON (matching markdown):**\n```json\n{\n  \"query\": {...},\n  \"summary\": {...},\n  \"dead_packages\": [\"pkg1\", \"pkg2\"],\n  \"packages\": {\n    \"pkg1\": {\n      \"is_dead\": true,\n      \"dead_files\": [\"file1.go\", \"file2.go\"],\n      \"files\": {\n        \"file1.go\": {\"total_symbols\": 5, \"dead_symbols\": 5}\n      },\n      \"constants\": [...],\n      \"variables\": [...],\n      \"functions\": [...],\n      \"types\": [\n        {\n          \"symbol\": {...},\n          \"constructors\": [...],\n          \"methods\": [...]\n        }\n      ],\n      \"dead_methods\": [...]\n    }\n  }\n}\n```\n\nOptions:\n1. Restructure core response types to match desired output (affects both JSON and markdown)\n2. Keep core types flat, create separate marshal structs for JSON\n\nRecommendation: Option 1 - restructure core types. This ensures consistency and makes the data model clearer. The MarshalMarkdown can iterate the structured data.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-21T13:44:12.733821522Z","updated_at":"2026-01-21T14:02:18.244580661Z","closed_at":"2026-01-21T14:02:18.244580661Z"}
{"id":"wc-e206","content_hash":"7a3bb6a01f2b0ec019ec3cd518fc9a8a3fdaa4b495691d59dfcf1854fad8d5fb","title":"Extend tree --scope to support patterns and exclusions","description":"Currently tree --scope only supports keywords: all, project, package. Extend to support patterns and exclusions like symbol/search.\n\nCurrent: wildcat tree Foo --scope project\nNew: wildcat tree Foo --scope 'project,-internal/test/...'\n\nChallenges:\n- Tree traverses a call graph, not just filtering results\n- If scope excludes nodes mid-graph, need to represent truncation\n- May need 'truncated due to scope' indicators in output\n\nImplementation:\n- Replace custom Scope type with ParseScope\n- Update inScope() to use scopeFilter.InScope()\n- Add truncation indicators when call chain leaves scope\n- Update help text\n\nThis is lower priority than deadcode since tree's current scope is functional, just less flexible.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-23T03:33:32.23994128Z","updated_at":"2026-01-23T04:44:18.375280968Z","closed_at":"2026-01-23T04:44:18.375280968Z"}
{"id":"wc-e572","content_hash":"281107d8134a7115ccaf46f109d8632b9ca3544cfec42baf7bb7967abc66910e","title":"Document package JSON rich type info","description":"Package JSON has rich type info that's not documented:\n\n```json\n{\n  \"signature\": \"type Id struct{...}\",\n  \"functions\": [{\"signature\": \"func CreateId(...)\", ...}],\n  \"methods\": [...],\n  \"satisfies\": [\"driver.Valuer\", \"fmt.Stringer\", ...]\n}\n```\n\nTypes include functions (constructors), methods, and satisfies.","status":"closed","priority":3,"issue_type":"chore","created_at":"2026-01-18T05:47:13.649674336Z","updated_at":"2026-01-18T06:12:59.623720025Z","closed_at":"2026-01-18T06:12:59.623720025Z"}
{"id":"wc-e649","content_hash":"dbe4875bd93258b9bc60e99b7897a55e2ba91ec3c908e2e2d82fb7cdcad10679","title":"Audit: golang package - Package facility usage","description":"Audit internal/golang for appropriate use of Package facilities:\n\n**Facilities to consider:**\n- `Types.Scope()` - package-level declarations, already type-resolved\n- `TypesInfo.Defs/Uses` - AST ident → object mappings\n- `Syntax` (AST) - needed for formatting, file association\n\n**Questions to answer:**\n1. Where do we iterate AST when Scope() would be cleaner?\n2. Where do we lookup in TypesInfo with nil checks that could be avoided?\n3. Is AST formatting needed, or could types.TypeString suffice?\n4. Are we using the right facility for each task?\n\n**Key files to review:**\n- interfaces.go - CollectInterfaces, FindImplementors, FindSatisfiedInterfaces\n- refs.go - reference walking with TypesInfo.Uses\n- calls.go - call graph walking\n- search.go - symbol collection for indexing\n- channels.go - channel operation detection\n\nPart of broader Package facility audit. Supersedes wc-389a.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-24T11:14:59.182144982Z","updated_at":"2026-01-26T04:47:26.702582285Z","closed_at":"2026-01-26T04:47:26.702582285Z"}
{"id":"wc-e655","content_hash":"93b94265f29053819575bf4c88086696aa65162a90bf089167b1d11c3c8105a9","title":"Audit types for omitempty usage","description":"Review all JSON struct tags in internal/output/types.go and remove omitempty where appropriate. Empty values are meaningful signals - an empty array or empty string indicates 'none found' vs the field being absent. Only keep omitempty where truly optional metadata.","status":"closed","priority":3,"issue_type":"chore","created_at":"2026-01-18T04:09:11.033752753Z","updated_at":"2026-01-18T07:33:34.453103661Z","closed_at":"2026-01-18T07:33:34.453103661Z"}
{"id":"wc-e691","content_hash":"139ee570c41642eb98013b20107ccf70c21645c4f29a76421b6b4add87bd8979","title":"Eval: Custom benchmark for Wildcat strengths","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T02:37:15.65170102Z","updated_at":"2026-01-14T07:28:20.261214103Z","closed_at":"2026-01-14T07:28:20.261214103Z"}
{"id":"wc-e720","content_hash":"4d646416a0f97569ce6e6bdfff5f6b80f43b4ebd69bd6a897cff16030f85c7af","title":"chore: remove orphaned formatter infrastructure from output package","description":"The formatter.go file contains orphaned code from a previous design. Commands now use Result interface with MarshalJSON/MarshalMarkdown methods directly. Dead code includes: Formatter interface, YAMLFormatter, MarkdownFormatter with all helper methods, and related types (ErrorDetail, SearchMatch) in types.go. Discovered during wc-4967 dead code cleanup session.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-22T14:54:02.755201718Z","updated_at":"2026-01-22T14:57:02.072882595Z","closed_at":"2026-01-22T14:57:02.072882595Z"}
{"id":"wc-e896","content_hash":"4254661bfbd692ea15ae6ad6244664113c8c58a62f0a451b0fe87ebb8568e7bd","title":"Tree --scope: elide out-of-scope intermediate calls with ...","description":"When tree command uses --scope, out-of-scope calls are still part of the call graph but shouldn't clutter output.\n\nProposed behavior:\n- Build full call tree across project\n- For paths that go through out-of-scope packages, show elision:\n\nExample with --scope internal/commands:\n  main.Execute\n    internal/commands.Run\n      ...                          // calls through internal/golang\n      internal/commands.Format\n    \nInstead of hiding the path entirely or showing all intermediate nodes.\n\nThis preserves the tree structure while focusing on scoped packages. The '...' indicates 'there are calls here but they're outside your scope.'","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-23T04:28:40.988858623Z","updated_at":"2026-01-23T04:44:18.472622467Z","closed_at":"2026-01-23T04:44:18.472622467Z"}
{"id":"wc-e911","content_hash":"a6bca35bc88720b67d8208b001235f878bbce31353121fafb65c7d9743e8e7bd","title":"Extract implements/satisfies helpers to golang package","description":"Extract reusable interface relationship helpers from package command to internal/golang/ for use by both package and symbol commands.\n\n## Helpers to Extract\n\n1. **CollectInterfaces(project *Project, stdlib []*packages.Package) []InterfaceInfo**\n   - Gather all interfaces from project packages + stdlib\n   - Return struct with pkgPath, name, and *types.Named\n   - Currently inlined in package.go:223-269\n\n2. **FindImplementors(iface *types.Interface, packages []*Package) []TypeInfo**\n   - Find all types that implement a given interface\n   - Check both T and *T\n   - Currently inlined in package.go:271-306\n\n3. **FindSatisfiedInterfaces(typ types.Type, interfaces []InterfaceInfo) []string**\n   - Find all interfaces a concrete type satisfies\n   - Handle builtin error interface (types.Universe)\n   - Handle generic interface instantiation\n   - Skip empty interfaces\n   - Currently inlined in package.go:308-367\n\n## Consumers\n- internal/commands/package/package.go - iterate over all types in package\n- internal/commands/symbol/symbol.go - single target symbol\n\n## Notes\n- Package command currently stores results as []string (qualified names)\n- Symbol command needs location + signature for output.SymbolLocation\n- May need two variants or a richer return type","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T07:26:19.560997219Z","updated_at":"2026-01-21T08:16:47.829178911Z","closed_at":"2026-01-21T08:16:47.829178911Z","dependencies":[{"issue_id":"wc-e911","depends_on_id":"wc-90a1.6","type":"discovered-from","created_at":"2026-01-21T07:26:31.089798926Z","created_by":"jason"}]}
{"id":"wc-e955","content_hash":"cee54969d79638d5c0429725600fcb7c09c6180e8ce172426fef2b52dae5d4e5","title":"Feature: Find function definition by name","description":"When modifying a function, we need to find where it's defined. Currently using grep for 'model=' to find where a variable is used. Wildcat could provide: 1) Find definition of a function/variable by name 2) Jump to definition like IDE 'go to definition'. Discovered while searching for model parameter in refactor_harness.py.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-11T03:35:25.959838194Z","updated_at":"2026-01-14T07:33:41.326034884Z","closed_at":"2026-01-14T07:33:41.326034884Z"}
{"id":"wc-ea9e","content_hash":"767fb2741d48c218f86cef256e546b9340b483fe7a5483114b56e9df52b0bdd9","title":"Research gopls LSP feature coverage","description":"Research ticket to understand the full gopls feature set.\n\n## Goals\n1. Document all gopls capabilities and LSP methods it supports\n2. Compare against the full LSP specification\n3. Identify what LSP features are NOT implemented in gopls\n4. Note any gopls-specific extensions beyond standard LSP\n\n## Deliverable\nA comprehensive report (can be added as comments on this ticket) covering:\n- Supported LSP methods (textDocument/*, workspace/*, etc.)\n- LSP spec version conformance\n- Notable gaps or limitations\n- Any Go-specific extensions\n\n## Notes\nThis is pure research - no code changes to wildcat required.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-12T01:43:54.466691825Z","updated_at":"2026-01-12T02:18:00.462932742Z","closed_at":"2026-01-12T02:18:00.462932742Z"}
{"id":"wc-eaea","content_hash":"a099c717fd6d5f9149322be338f3d33eece93b2129e65e420e86326fbce3484d","title":"Fix References section counting and deduplication","description":"1. Add counts to #### References subheadings\n2. When a snippet contains multiple refs to the target type, roll up into single snippet with annotation showing n refs\n3. Section refs count should show total refs, not merged results count","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-22T05:58:16.787620287Z","updated_at":"2026-01-22T06:07:30.907391547Z","closed_at":"2026-01-22T06:07:30.907391547Z"}
{"id":"wc-ec85","content_hash":"d4727ce9c7758895af705e1a19f2a90224de692ae148d95031bbe222a98dda22","title":"Deps command: show both imports and imported_by in single response","description":"## Problem\nCurrent `wildcat deps` command requires `--reverse` flag to toggle between showing what a package imports vs what imports it. This requires two separate invocations to get the full picture.\n\n## Solution\nReturn both directions in a single response:\n- `imports` - packages this package depends on\n- `imported_by` - packages that depend on this package\n\nRemove the `--reverse` flag entirely.\n\n## Current Behavior\n```bash\nwildcat deps ./internal/lsp              # shows imports\nwildcat deps ./internal/lsp --reverse    # shows imported_by\n```\n\n## Proposed Output\n```json\n{\n  \"query\": {\n    \"command\": \"deps\",\n    \"target\": \"./internal/lsp\"\n  },\n  \"package\": \"github.com/jasonmoo/wildcat/internal/lsp\",\n  \"imports\": [\n    { \"package\": \"context\", ... },\n    { \"package\": \"fmt\", ... }\n  ],\n  \"imported_by\": [\n    { \"package\": \"github.com/jasonmoo/wildcat/cmd\", \"file\": \"...\", \"line\": ... }\n  ],\n  \"summary\": {\n    \"imports_count\": 5,\n    \"imported_by_count\": 3\n  }\n}\n```\n\n## Files to Modify\n- `cmd/deps.go` - Remove --reverse flag, fetch both directions\n- `internal/output/types.go` - Update DepsResponse structure\n\n## Acceptance Criteria\n- [ ] Single invocation returns both imports and imported_by\n- [ ] --reverse flag removed\n- [ ] Output structure includes both lists\n- [ ] Summary shows counts for both","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-13T08:16:19.026199533Z","updated_at":"2026-01-13T14:34:38.30426557Z","closed_at":"2026-01-13T14:34:38.30426557Z"}
{"id":"wc-ecb8","content_hash":"2010221b5b3c911de6ed0f35b7462da6e33f40e7123ed17119820fb5f8b000f1","title":"Research AST-annotated code format for AI editing","description":"## Problem\nLSP was designed for IDEs with cursor positions. AI agents need a different interface for precise code operations without tracking positions.\n\n## Core Idea\nAnnotate code with AST node IDs so AI can target any entity precisely:\n\n```go\nαfunc βrunChannels(γcmd δ*cobra.Command, εargs ζ[]string) ηerror {\n    θwriter, ιerr := κGetWriter(λos.μStdout)\n    νif ξerr οπnil {\n        ρreturn σfmt.τErrorf(υ\"invalid: %w\", φerr)\n    }\n}\n```\n\nThen operations are simple: `μ = \"Stderr\"`, `delete ν`, `β = \"executeChannels\"`\n\n## Design Options Explored\n\n**Representation formats:**\n- Parallel view (code + AST side by side)\n- Nested JSON with IDs as keys\n- Prefixed format `\"id:symbol\"` in JSON arrays\n- Inline prefixes on source code (single unicode char per token)\n\n**ID schemes:**\n- Numeric: 001, 002...\n- Unicode single-char: αβγ, ①②③, braille\n- Hierarchical encoding (ID = path)\n\n**Trade-offs:**\n- More granular = more verbose but more precise\n- Human readability not required (AI-only format)\n- Token efficiency matters for LLM context\n\n## Operations This Enables\n- `rename θ newWriter` - rename variable\n- `delete ν` - remove if block  \n- `θ.replace = \"w, err := NewWriter()\"` - replace statement\n- `insert after θ \"defer w.Close()\"` - inject code\n- Path queries: find all refs to μ, what contains ν\n\n## Research Questions\n- Optimal granularity (every token vs significant nodes only?)\n- Best ID scheme for token efficiency\n- How to handle structure changes (IDs shift when code changes)\n- Round-trip: annotated → edit → re-render → new annotations\n- Integration with existing wildcat commands\n\n## Related\nBuilds on channels/peers work - same need for precise code targeting.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-16T04:39:32.891606856Z","updated_at":"2026-01-27T03:27:46.978053975Z","closed_at":"2026-01-27T03:27:46.978053975Z"}
{"id":"wc-ee18","content_hash":"01a66bfd24c0e5f69094a3f0f1f332d19dbfa38790211234310d07f500912553","title":"Mark snippet uniqueness in symbol command output","description":"When the `symbol` command displays code snippets (signatures, definitions, etc.), mark whether each snippet is unique within its file.\n\n**Why:**\nClaude's Edit tool requires the `old_string` to be unique in the file. If a snippet is not unique, Edit will fail. Currently Claude has to guess or retry. This ticket adds explicit marking so Claude knows upfront.\n\n**Proposed marking:**\n- Unique snippets: no marker needed (or subtle marker)\n- Non-unique snippets: clear marker like `[not unique]` or `[2 occurrences]`\n\n**Examples of non-unique snippets:**\n- Common patterns like `return nil`\n- Repeated field names across structs\n- Generic parameter names like `err error`\n\n**Scope:** Focus on snippets that Claude might want to use for edits - signatures, type definitions, field declarations.\n\n**Goal:** Help Claude know immediately if a displayed snippet can be used with the Edit tool, reducing failed edit attempts.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-26T10:21:51.73031895Z","updated_at":"2026-01-26T10:35:15.714680206Z","closed_at":"2026-01-26T10:35:15.714680206Z"}
{"id":"wc-ee2a","content_hash":"4d7373fd0939c9a22f52eec9ec337a63f22f0de9c8c4423a5158f56b7031ced8","title":"Exclude current symbol from fuzzy match suggestions","description":"When showing fuzzy match suggestions, the current symbol should be excluded from the list. This affects multiple commands (symbol, search, etc.) so the fix should be in SearchOptions or Suggestions method.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-21T07:50:03.160880053Z","updated_at":"2026-01-22T02:16:24.730862319Z","closed_at":"2026-01-22T02:16:24.730862319Z"}
{"id":"wc-eef3","content_hash":"85313aaba14347487d9934289152803b2c66dd0f08573f0eaeab368b19a482e7","title":"Harden analysis against partially-compilable code","description":"Current code assumes TypesInfo lookups succeed, which breaks when analyzing:\n- Code with syntax errors\n- Code with missing imports\n- Code mid-refactor (half-written)\n- Code with build tag mismatches\n- Generated code that hasn't been regenerated\n\nSymptoms found in audit:\n- TypesInfo.Defs[name] returns nil -\u003e silently skip (wc-3c75, wc-db4f)\n- TypesInfo.Uses[ident] returns nil -\u003e silently continue\n- pkg.Package.Types.Scope().Lookup() returns nil -\u003e skip\n- GetTypesObject() returns nil -\u003e WalkReferences does nothing (wc-2cc9)\n\nThe pattern 'if obj == nil { continue }' appears ~15 times across the codebase.\n\n**Update:** Many of these symptoms are addressed by iterating TypesInfo directly instead of AST syntax. See findImplementations refactor (wc-d4a4) for the pattern - iterate `TypesInfo.Defs` instead of walking AST and looking up each node. This eliminates nil checks entirely since we only see entries that have type info.\n\nRemaining approach for cases where TypesInfo iteration doesn't fit:\n1. At package load time, check and surface packages.Package.Errors\n2. Track which packages/files have incomplete type info\n3. When TypesInfo lookup fails, emit diagnostic (depends on wc-f06a)\n4. Include 'analysis_coverage' in responses showing what could/couldn't be analyzed\n\nRelated tickets updated to consider TypesInfo pattern first: wc-5cdf, wc-a665\nAudit ticket for broader application: wc-389a","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-23T06:00:31.308812739Z","updated_at":"2026-01-26T04:51:00.897604911Z","dependencies":[{"issue_id":"wc-eef3","depends_on_id":"wc-f06a","type":"related","created_at":"2026-01-23T06:00:37.73868336Z","created_by":"jason"}]}
{"id":"wc-ef9e","content_hash":"2542b75199d372454f96fe24bb2de842217bcab9b56d6e9dfd28a44e2f1a7961","title":"gopls OutgoingCalls crashes on functions calling builtins","description":"gopls v0.20.0 panics with nil pointer dereference in OutgoingCalls (callees) when the target function calls any builtin like len(), make(), append().\n\nRoot cause: golang.org/x/tools/gopls@v0.20.0/internal/golang/call_hierarchy.go:282 calls obj.Pkg().Path() without nil check. Builtins have nil Pkg().\n\n**FIXED in gopls v0.21.0** - Upgrade recommended.\n\nUpstream: https://github.com/golang/go/issues/75230","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-14T13:48:41.966109368Z","updated_at":"2026-01-14T13:51:09.487524001Z","closed_at":"2026-01-14T13:51:09.487524001Z"}
{"id":"wc-efda","content_hash":"6e25795ca12632c887a9c66d0bb9f77750a15c04f0c906022fae83cbea3c945d","title":"Documentation audit after command consolidation","description":"Following wc-e19d command consolidation (16 → 8 commands), need to update all docs:\n\n- Command help text (Short/Long descriptions)\n- README.md \n- readme command output\n- Any other docs referencing old commands\n\nRemoved commands to scrub:\n- deps, completion, formats\n- impact (now symbol), symbols (now search)\n- satisfies, implements (merged into symbol)\n- callers, callees, refs (tree is authoritative, symbol has refs)\n\nNew command set:\n- channels, package, readme, search, symbol, tree, version","status":"closed","priority":1,"issue_type":"chore","created_at":"2026-01-16T06:31:33.302369835Z","updated_at":"2026-01-16T06:47:54.863016407Z","closed_at":"2026-01-16T06:47:54.863016407Z","dependencies":[{"issue_id":"wc-efda","depends_on_id":"wc-e19d","type":"discovered-from","created_at":"2026-01-16T06:31:33.319103582Z","created_by":"jason"}]}
{"id":"wc-efe2","content_hash":"b30b5584b20762d134291e3b12e9c2d33f75f2cbd755069c63d71db16d71d1f5","title":"Symbol command: default to package scope, flag for project-wide","description":"## Summary\n\nAdd `--scope` flag to symbol command to control which packages are included in results.\n\n## Scope Options\n\n- `--scope package` (default) - symbol's defining package only\n- `--scope project` - full project\n- `--scope \u003cpattern\u003e` - custom package filter (format TBD)\n\n## Output Structure\n\nAlways include three summaries for context:\n\n```json\n{\n  \"query\": {\n    \"command\": \"symbol\",\n    \"target\": \"lsp.Client\",\n    \"scope\": \"package\"\n  },\n  \"usage\": {\n    \"callers\": [...],\n    \"references\": [...]\n  },\n  \"summary\": {\n    \"callers\": 2,\n    \"references\": 5\n  },\n  \"package_summary\": {\n    \"callers\": 2,\n    \"references\": 5\n  },\n  \"project_summary\": {\n    \"callers\": 8,\n    \"references\": 47\n  }\n}\n```\n\n- `summary` - stats for the requested scope\n- `package_summary` - always the symbol's defining package (fixed anchor)\n- `project_summary` - always full project (fixed anchor)\n\nWhen scope=package, summary equals package_summary.\nWhen scope=project, summary equals project_summary.\nWhen scope=custom, summary is the filtered count.\n\n## Consistency\n\n- Replace search command's `--package` flag with `--scope` for consistency\n- Aligns with `package` and future `project` commands\n- AI learns one scope vocabulary across all commands\n\n## Open Questions\n\n- Flag format for multiple packages (CSV? repeated flag? other?)\n- Glob/pattern matching semantics (how does `internal/*` match?)\n- Should satisfies/implements be scoped? (probably not - inherently cross-package)\n","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-16T06:29:50.483830698Z","updated_at":"2026-01-16T08:31:19.029695119Z","closed_at":"2026-01-16T08:31:19.029695119Z","dependencies":[{"issue_id":"wc-efe2","depends_on_id":"wc-48e9","type":"blocks","created_at":"2026-01-16T07:53:15.200389309Z","created_by":"jason"}]}
{"id":"wc-f06a","content_hash":"3c1246c2048deb699e4ad8cb47a603d2b028dc9754220c6cf3daeb7fd10cf311","title":"Add warnings/diagnostics channel to response types","description":"Currently there's no standard place to report non-fatal issues. ErrorResult exists for fatal errors, but many situations are 'something went wrong but we can still return partial results.'\n\nExamples from the audit:\n- Signature rendering failed for 3 of 50 symbols\n- 2 packages had TypesInfo lookup failures\n- AST parsing fell back to line-based extraction for 1 file\n- Scope pattern 'foo[' was malformed\n\nProposed approach:\n1. Add a Diagnostics field to response types (or a common base struct)\n2. Define diagnostic severity levels (warning, info)\n3. Include source location and error details\n4. Commands populate this as they encounter non-fatal issues\n\nBenefits:\n- AI knows when results are incomplete\n- Debugging is easier (can see what went wrong)\n- Aligns with 'never silently fail' philosophy\n- Many of the P2/P3 tickets from the audit could be resolved by emitting diagnostics\n\nExample structure:\n  type Diagnostic struct {\n    Level    string // 'warning', 'info'\n    Code     string // 'signature_failed', 'type_lookup_failed'\n    Message  string\n    Location string // optional: file:line\n  }\n\nThis is a foundational change that would make fixing other tickets easier.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-23T06:00:18.998821572Z","updated_at":"2026-01-23T08:24:50.791181662Z","closed_at":"2026-01-23T08:24:50.791181662Z"}
{"id":"wc-f203","content_hash":"fcf37334c9b34e97bd8c30893746ba9df5dc4406407e203fa1778f19566c436d","title":"Smarter snippets using AST walking","description":"Replace line-based snippets with AST-aware logical snippets.\n\n**Current behavior:** Snippets are extracted by line numbers, which can cut off in the middle of functions, structs, or other logical units.\n\n**Proposed behavior:** Use AST walking to produce semantically meaningful snippets (e.g., complete functions, type definitions, method blocks).\n\n**Guardrails needed:**\n- Maximum snippet size limit to prevent massive responses\n- Fallback to line-based when AST parsing fails\n- Consider depth limits for nested structures\n- May need heuristics for 'interesting' boundaries (function vs statement level)\n\n**Open questions:**\n- What's the right max size? Tokens? Bytes? Lines?\n- Should we expand to enclosing scope or contract to fit limit?\n- How to handle multi-symbol snippets (e.g., a function that references a type)?","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-13T03:28:16.375310486Z","updated_at":"2026-01-15T01:58:03.017664208Z","closed_at":"2026-01-15T01:58:03.017664208Z"}
{"id":"wc-f203.1","content_hash":"58f3712422fa348d1cd511739288492ab78df73dbe0de4260d464b6bd1477413","title":"Scope-bounded snippet fallback","description":"When ExtractSmart falls back (enclosing scope \u003e maxLines), the fallback should stay within the scope boundaries instead of crossing them.\n\n**Current behavior:**\n- Find enclosing node (e.g., function at lines 129-281)\n- If \u003e 10 lines, fall back to ±3 lines around target (e.g., lines 126-135)\n- This can show code from the previous function\n\n**Desired behavior:**\n- When falling back, compute window centered on target line\n- Clamp window to [scopeStart, scopeEnd]\n- Example: target=129, scope=129-281 → show lines 129-135 (not 126-135)\n\n**Implementation:**\n- Modify extractASTSnippet to compute bounded window instead of returning error\n- Use scope boundaries from findEnclosingNode\n- Window size = SmartSnippetFallbackContext * 2 + 1 (7 lines)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-14T13:07:11.870074439Z","updated_at":"2026-01-14T13:08:52.900204463Z","closed_at":"2026-01-14T13:08:52.900204463Z"}
{"id":"wc-f203.2","content_hash":"9f2c2196afc63323b94928e55952419811781cf17606aceb0c621e64a3c47206","title":"Merge overlapping snippet ranges","description":"When multiple references in the same file have overlapping or adjacent snippet ranges, merge them into a single snippet.\n\n**Current behavior:**\n- Each reference gets its own snippet\n- 'wildcat refs lsp.Client' on client.go produces 17 separate snippets\n- Many snippets overlap or are adjacent, creating redundant output\n\n**Desired behavior:**\n- After collecting results, identify overlapping/adjacent snippets in same file\n- Merge into single snippet covering all reference lines\n- Track multiple line numbers in merged result\n\n**Data structure changes:**\n- Add 'lines []int' field to Result (for merged results)\n- Keep 'line int' as primary/first line for backwards compat\n- Only populate 'lines' when multiple references merged\n\n**Implementation:**\n- Add MergeOverlappingResults([]Result) []Result function\n- Group results by file\n- Sort by line, identify overlapping ranges\n- Re-extract merged snippets\n- Call after collecting results in each command","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-14T13:07:20.458113314Z","updated_at":"2026-01-15T01:57:58.024612659Z","closed_at":"2026-01-15T01:57:58.024612659Z"}
{"id":"wc-f45a","content_hash":"e9e7731548769bb93a5415a91225dd5b3e05a641b67699a5a56d92b3fd2de0a6","title":"Eval: SWE-bench Lite with Wildcat","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T02:36:36.842030212Z","updated_at":"2026-01-14T07:28:20.25722153Z","closed_at":"2026-01-14T07:28:20.25722153Z"}
{"id":"wc-f490","content_hash":"81d541455ef97c4e2b3dd5cfb2d5a4dceb8c0009c98d755ed5427d70edf7afdd","title":"Symbol Lookup returns nil for both 'not found' and 'ambiguous'","description":"In search.go:142-237, SymbolIndex.Lookup() returns nil for two different cases:\n1. Symbol not found (no matches)\n2. Symbol ambiguous (multiple matches)\n\nLocation: internal/golang/search.go lines 184-185, 199-200, 213-214, 228-229\n\nImpact: Callers cannot distinguish between 'doesn't exist' vs 'exists but ambiguous'. AI might think symbol doesn't exist when it actually does but needs qualification.\n\nOptions:\n- Return (symbol, found bool, ambiguous bool)\n- Return (*Symbol, error) with typed errors\n- Return (*Symbol, []Symbol) where second is candidates if ambiguous","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:51:47.934523981Z","updated_at":"2026-01-23T10:52:53.420799429Z","closed_at":"2026-01-23T10:52:53.420799429Z","dependencies":[{"issue_id":"wc-f490","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:51:47.951699281Z","created_by":"jason"}]}
{"id":"wc-f5d6","content_hash":"ad6d547bf5ef839e34a7a02b665e381905b280616a28f12793b3e11e0f88cc0e","title":"Symbol: exclude report symbols from fuzzy alternates","description":"Fuzzy alternates (\"Similar Symbols\") should not include symbols already shown in the report.\n\n## Problem\nWhen querying a type like `Symbol`, the report includes:\n- Target symbol\n- Methods (Symbol.Signature, Symbol.Location, etc.)\n- Constructors\n- Implementations (if interface)\n- Satisfies (if concrete type)\n- Descendants\n\nBut \"Similar Symbols\" may redundantly list some of these same symbols.\n\n## Solution\nBuild an exclusion set from all symbols that appear in the report:\n- Target symbol (already fixed in wc-ee2a)\n- All methods listed\n- All constructors listed  \n- All implementations listed\n- All satisfies listed\n- All descendants listed\n\nPass this exclusion set to the fuzzy matcher.\n\n## Implementation notes\n- Collect symbol names as we build each section\n- Use the same short name format: `pkg.Type` or `pkg.Type.Method`\n- Pass exclusion set to `wc.Suggestions()` call","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-22T04:06:42.828416313Z","updated_at":"2026-01-22T04:12:58.282258063Z","closed_at":"2026-01-22T04:12:58.282258063Z"}
{"id":"wc-f796","content_hash":"6298a3aee443c7ed31c515c916fe94c491d2ab21fe620f6f43e8f77d595cefc8","title":"Normalize symbol field to fully qualified import path","description":"Search results show inconsistent symbol names:\n- 'golang.TestResolvePackagePath' (short pkg name)\n- 'stdlib.golang.org/x/tools/internal/stdlib.Symbol.Version' (partial path)\n\nMerge symbol and package fields into a single fully qualified symbol field using the full import path, e.g.:\n- 'github.com/jasonmoo/wildcat/internal/golang.TestResolvePackagePath'\n\nRemove separate package field since it's redundant with fully qualified symbol.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-16T09:53:01.210562634Z","updated_at":"2026-01-16T09:56:20.773762352Z","closed_at":"2026-01-16T09:56:20.773762352Z"}
{"id":"wc-f884","content_hash":"d9e61cf57f3e25f513d7f13601e432919def6da12b1f4c5f89cbc0ff6b5909c7","title":"Annotate dead packages in deadcode output","description":"Detect and annotate when an entire package contains only dead code.\n\nIf all symbols in a package are dead, show prominently at the top:\n```\n## Dead Packages (2)\n- internal/lsp (4 files, 1179 lines) - entire package is dead\n- internal/symbols (3 files, 450 lines) - entire package is dead\n\n## Partially Dead Packages\n...\n```\n\nThis helps identify packages that can be entirely deleted vs those needing selective cleanup.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-21T13:32:17.305282618Z","updated_at":"2026-01-21T13:36:48.291604813Z","closed_at":"2026-01-21T13:36:48.291604813Z","dependencies":[{"issue_id":"wc-f884","depends_on_id":"wc-033e","type":"blocks","created_at":"2026-01-21T13:32:21.404255524Z","created_by":"jason"},{"issue_id":"wc-f884","depends_on_id":"wc-a09d","type":"blocks","created_at":"2026-01-21T13:32:21.443124618Z","created_by":"jason"}]}
{"id":"wc-f890","content_hash":"6a8a8834c7ca92a3b7a80865c9cbaac8ff724cbf9af42fe3453529bdb652fb67","title":"Simplify tree command output to path-based format","description":"Current tree output is graph-structured (nodes/edges) - good for algorithms, bad for AI comprehension.\n\nProposed output:\n\nJSON:\n{\n  \"target\": \"StoreEmail\",\n  \"direction\": \"up\",\n  \"paths\": [\n    [\"main\", \"Run\", \"HandleEmail\", \"StoreEmail\"],\n    [\"main\", \"Run\", \"HandleEmail\", \"Respond\", \"StoreEmail\"],\n    [\"TestMessageLifecycle\", \"StoreEmail\"]\n  ]\n}\n\nMarkdown:\nmain → Run → HandleEmail → StoreEmail\nmain → Run → HandleEmail → Respond → StoreEmail\nTestMessageLifecycle → StoreEmail\n\nKey insight: Agents need to understand call flow, not run graph algorithms. Paths are immediately useful without reconstruction.\n\nBoth formats trivially convertible, both immediately comprehensible.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-14T15:01:17.117518371Z","updated_at":"2026-01-15T03:38:08.676617548Z","closed_at":"2026-01-15T03:38:08.676617548Z"}
{"id":"wc-f95e","content_hash":"9be17eea3f750c88c970f6eb06d58c1f40a3c33667d79bfd62865d8bd2ca350c","title":"Panics in wildcat.go should return errors","description":"In wildcat.go, panic is used for conditions that should return errors:\n\nLocations:\n- wildcat.go:40: 'panic(\"this should never happen\")' in Package() when lookup fails\n- search.go:404-406: 'panic(\"? \")' when TypesInfo is nil in CollectSymbols\n\nImpact: Tool crashes with unhelpful message instead of giving AI actionable error.\n\nOptions:\n- Return (*Package, error) from Package()\n- Handle TypesInfo == nil gracefully or skip package with warning\n- Convert panics to proper error returns","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-23T05:52:54.620266869Z","updated_at":"2026-01-23T10:21:02.070338974Z","closed_at":"2026-01-23T10:21:02.070338974Z","dependencies":[{"issue_id":"wc-f95e","depends_on_id":"wc-15c5","type":"discovered-from","created_at":"2026-01-23T05:52:54.637360609Z","created_by":"jason"}]}
{"id":"wc-fa4a","content_hash":"6e802e40440a14feb6ca335f023cbce58767a0b912f8566fe62865ae3fb6ddf7","title":"package: don't duplicate embed variables in Variables section","description":"**Problem:**\nVariables with `//go:embed` directives are listed both in the Embeds section and the Variables section, causing redundancy.\n\n**Current output:**\n```\n# Embeds (1 directive)\n//go:embed templates/*\nvar templates embed.FS // ...\n\n# Variables (1)\nvar templates embed.FS // ...  \u003c- duplicate\n```\n\n**Expected:**\nVariables already shown in Embeds should be excluded from the Variables section.\n\n**Fix:**\nIn `executeOne`, track embed variable names and skip them when building the Variables list.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-29T04:13:54.740662005Z","updated_at":"2026-01-29T04:22:14.440144255Z","closed_at":"2026-01-29T04:22:14.440144255Z"}
{"id":"wc-fb21","content_hash":"c4241a25fab890a23c35cef2a8205b96ca35106426a9c0a08a14cbc20c845a59","title":"Add dead code metrics to package and project commands","description":"Add dead code percentage/counts to package and project command output.\n\n## Context\nWe already have `wildcat deadcode` which uses RTA analysis to find unreachable code. This ticket is about surfacing those metrics in package and project views for quick health assessment.\n\n## Package Command\nAdd to package output:\n- Dead code count (unreachable functions/methods)\n- Dead code % of total symbols\n- Could list the dead symbols or just show count\n\n## Project Command  \nAdd to Core Packages histogram:\n- Dead code % per package\n- Could be a third metric alongside methods/dependents\n- Or an annotation/flag on packages with high dead code %\n\n## Implementation Notes\n- Reuse existing `golang.AnalyzeDeadCode()` \n- Need to attribute dead symbols back to their packages\n- Consider caching - deadcode analysis is expensive (builds SSA)\n\n## Example Output Ideas\n\nPackage:\n```\n## Health\nDead code: 3 symbols (5%)\n```\n\nProject Core Packages:\n```\n 28 methods ██████ internal/commands (3 files) ████████ imported 7  [2% dead]\n```\n\n## Questions\n- Should dead code analysis be opt-in (flag) due to cost?\n- What threshold warrants a warning flag?","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-26T07:25:17.826395429Z","updated_at":"2026-01-27T03:27:26.017563147Z"}
{"id":"wc-fbec","content_hash":"d36bf291f4de91ffc50510ebaecfa4545f6820691d9eb19b8357991b206e2ab4","title":"Align tree --scope with search command pattern","description":"Migrate tree command's scope handling to match search command's flexible pattern.\n\n## Current State (tree)\n- Uses `Scope` type enum: ScopeAll, ScopeProject, ScopePackage\n- ScopePackage means \"same package as target symbol\"\n- Fixed values only, no substring matching\n\n## Target State (match search)\n- Use `scope string` like search command\n- Support: \"project\" (default), \"all\", or package substrings\n- Support include/exclude: \"lsp,-test\", \"commands,output\"\n- Reuse or extract search's `filterByScope()` logic\n\n## Design Decision\nThe tree-specific \"package\" scope (restrict to target's package) could be:\n1. Dropped - users can use `--scope lsp` if target is in lsp package\n2. Kept as special keyword alongside substring matching\n3. Replaced with `--scope .` or `--scope self` convention\n\nRecommend option 1: drop it. Users can achieve same effect with substring.\n\n## Implementation\n1. Change `scope Scope` to `scope string` in TreeCommand\n2. Replace `inScope()` with search-style filtering\n3. Consider extracting filterByScope to shared location (commands package)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T05:33:36.267145666Z","updated_at":"2026-01-21T05:49:59.328751025Z","closed_at":"2026-01-21T05:49:59.328751025Z"}
{"id":"wc-fdb1","content_hash":"7ff8c74aa57e41d148243a9bc2bee68e3ea1263a3b8c74cbbb3713d85c9565c7","title":"Clarify search command: fuzzy vs regex","description":"User feedback: search uses fuzzy matching but ^ is treated literally, not as regex anchor.\n\nQuestions to resolve:\n- Is regex supported at all? If not, document this clearly\n- CLAUDE.md mentions \"^Get won't match methods\" but ^ doesn't work as regex anywhere\n- Should we support regex? Or just clarify that search is fuzzy-only?\n\nExample: `wildcat search ^New` treats ^ as literal character, not start anchor.","status":"closed","priority":2,"issue_type":"chore","created_at":"2026-01-22T07:51:23.223588411Z","updated_at":"2026-01-22T15:35:38.662550809Z","closed_at":"2026-01-22T15:35:38.662550809Z"}
{"id":"wc-fed3","content_hash":"d26e4a7a42a98d89ecd2dc0fc4eb0d462eec7e10acffacda673a4637a2cb6e95","title":"Add fuzzy suggestions to symbol_not_found errors","description":"When a symbol query returns no results, provide helpful fuzzy suggestions instead of just returning empty/not found.\n\nExample improvement:\n```json\n{\n  \"error\": \"symbol_not_found\",\n  \"query\": \"db.Task\",\n  \"similar\": [\n    \"database.DB.Task (struct field, not queryable)\",\n    \"model.Task (type)\",\n    \"model.ExportedTask (type)\"\n  ]\n}\n```\n\nBenefits:\n1. Shows the tool understood what user was looking for\n2. Indicates if query format was wrong (e.g., struct fields work differently)\n3. Confirms whether the thing exists, just not as a queryable symbol\n4. Provides valid alternatives\n\nThis turns a dead-end into a redirect - the \"no\" becomes informative rather than just absence. Similar to how good CLIs give \"did you mean X?\" rather than just \"command not found.\"\n\nGoal: Kill the impulse to grep-verify by making symbol_not_found responses actually helpful.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-12T04:08:27.443196771Z","updated_at":"2026-01-12T04:26:21.459226961Z","closed_at":"2026-01-12T04:26:21.459226961Z"}
{"id":"wc-ff4a","content_hash":"44fb00488fac5ab5cd27f9e77fe579b0a16c43ecc6ee86f73f10024aa4f69b61","title":"Add wildcat peers command - show channel send/receive pairs","description":"## Problem\nUnderstanding concurrent Go code requires knowing what's on both ends of a channel - who sends, who receives. This is hard to discover with grep or basic code navigation.\n\n## Inspiration\nguru's `peers` command: \"show send/receive corresponding to selected channel op\"\n\n## Solution\nAdd `wildcat peers \u003csymbol\u003e` command that shows:\n- All send operations on a channel\n- All receive operations on the same channel\n- The connection between producers and consumers\n\n## Example Output\n```json\n{\n  \"query\": { \"command\": \"peers\", \"target\": \"workQueue\" },\n  \"channel\": {\n    \"symbol\": \"workQueue\",\n    \"type\": \"chan Task\",\n    \"file\": \"worker.go\",\n    \"line\": 15\n  },\n  \"sends\": [\n    { \"file\": \"dispatcher.go\", \"line\": 42, \"snippet\": \"workQueue \u003c- task\" },\n    { \"file\": \"dispatcher.go\", \"line\": 67, \"snippet\": \"workQueue \u003c- urgentTask\" }\n  ],\n  \"receives\": [\n    { \"file\": \"worker.go\", \"line\": 28, \"snippet\": \"task := \u003c-workQueue\" },\n    { \"file\": \"worker.go\", \"line\": 55, \"snippet\": \"for task := range workQueue\" }\n  ],\n  \"summary\": {\n    \"sends\": 2,\n    \"receives\": 2\n  }\n}\n```\n\n## Implementation Notes\n- May require pointer analysis for dynamic channel references\n- guru used `-scope` flag for this - we may need similar\n- Consider whether gopls provides this or if we need go/ssa\n\n## Research Needed\n- [ ] Does gopls support channel peer analysis?\n- [ ] What go/x/tools packages support this? (go/ssa, go/pointer?)\n- [ ] How did guru implement this?\n\n## Acceptance Criteria\n- [ ] `wildcat peers \u003cchannel\u003e` shows sends and receives\n- [ ] Works for named channel variables\n- [ ] Shows file:line for each operation","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-13T08:41:23.335975318Z","updated_at":"2026-01-16T04:58:48.279923145Z","closed_at":"2026-01-16T04:58:48.279923145Z"}
{"id":"wc-ffcd","content_hash":"82df4af4f623e9e2df3655be02bd2f5643bd6f063d3a1316fc0bd616160d4cf5","title":"Audit: search command - Package facility usage","description":"Audit the search command for appropriate use of Package facilities:\n\n**Facilities to consider:**\n- `Types.Scope()` - package-level declarations, already type-resolved\n- `TypesInfo.Defs/Uses` - AST ident → object mappings\n- `Syntax` (AST) - needed for formatting, file association\n\n**Questions to answer:**\n1. Where do we iterate AST when Scope() would be cleaner?\n2. Where do we lookup in TypesInfo with nil checks that could be avoided?\n3. Is AST formatting needed, or could types.TypeString suffice?\n4. Are we using the right facility for each task?\n\n**Note:** Search builds a SymbolIndex - review how symbols are collected and indexed.\n\nPart of broader Package facility audit. Supersedes wc-389a.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-24T11:14:53.604633124Z","updated_at":"2026-01-24T11:22:53.660432187Z","closed_at":"2026-01-24T11:22:53.660432187Z"}
{"id":"wc-ffe6","content_hash":"29b50e80680f5c414fefb2e6e122256416b61fb8a9ecb9eb19f3baa119c968a9","title":"Add wildcat blocking command - show all blocking operations","description":"## Problem\nUnderstanding where code can block is critical for concurrency analysis. Blocking points are scattered across channels, mutexes, IO, and sleep calls.\n\n## Solution\nNew `wildcat blocking` command that reports all blocking operations:\n\n### Channels (existing in channels command)\n- `\u003c-ch` receive\n- `ch \u003c-` send (can block if unbuffered/full)\n- `select` with channel cases\n\n### Mutexes\n- `sync.Mutex.Lock()`\n- `sync.RWMutex.Lock()`, `RLock()`\n- `sync.WaitGroup.Wait()`\n- `sync.Cond.Wait()`\n- `sync.Once.Do()` (first call blocks others)\n\n### IO/System\n- `time.Sleep()`\n- `time.After()`, `time.Tick()`\n- `os.Stdin.Read()`, file reads\n- `net.Conn.Read()`, `Accept()`\n- `http.Client.Do()`, `Get()`, `Post()`\n- `exec.Cmd.Wait()`, `Run()`\n- `context.Done()` receives\n\n### Output Format\n```json\n{\n  \"packages\": [{\n    \"package\": \"...\",\n    \"blocking\": {\n      \"channels\": [...],\n      \"mutexes\": [...],\n      \"io\": [...],\n      \"sleep\": [...],\n      \"context\": [...]\n    }\n  }],\n  \"summary\": {\n    \"total\": N,\n    \"by_kind\": {...}\n  }\n}\n```\n\n## Implementation\n- Extend channels command approach\n- Detect method calls on known blocking types\n- Group by category for easier analysis\n\n## Use Cases\n- Deadlock analysis: find Lock() without Unlock()\n- Performance: find unexpected blocking in hot paths\n- Concurrency review: see all sync points at a glance","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-16T04:40:58.58672628Z","updated_at":"2026-01-22T16:01:10.467307815Z"}
