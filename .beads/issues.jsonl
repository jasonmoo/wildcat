{"id":"wc-099e","content_hash":"d347e2b5c9b509a9e398145d9d6c27291a2951033ff94b2935d9b814bf03217c","title":"Orchestration layer - symbol lookup, recursion, snippets","description":"## Context\nThis is Wildcat's value-add on top of LSP. While LSP provides raw queries, Wildcat orchestrates multiple calls, handles recursion, extracts snippets, and formats output.\n\n## What Wildcat Adds\n\n| Feature | LSP Provides | Wildcat Adds |\n|---------|--------------|--------------|\n| Symbol lookup | workspace/symbol (returns list) | Parse 'pkg.Func' → filter → find exact match |\n| Transitive calls | Direct callers only | Recursive calls to build full tree |\n| Snippets | Line/column position | Read file, extract source context |\n| Call expression | Position only | Extract actual call text |\n| in_test flag | Nothing | Filename pattern matching |\n| Args extraction | Nothing | Parse snippet for arguments |\n\n## Scope\nCreate orchestration packages:\n\n### 1. Symbol Lookup (`internal/symbols`)\n```go\n// Parse user input like \"config.Load\" or \"Server.Start\"\nfunc Parse(input string) (*SymbolQuery, error)\n\n// Find symbol using workspace/symbol + filtering\nfunc Resolve(ctx context.Context, client lsp.Client, query *SymbolQuery) (*ResolvedSymbol, error)\n\n// Generate suggestions for typos\nfunc SuggestSimilar(ctx context.Context, client lsp.Client, query string) ([]string, error)\n```\n\n### 2. Recursive Traversal (`internal/traverse`)\n```go\ntype TraverseOptions struct {\n    Direction    Direction // Up (callers) or Down (callees)\n    MaxDepth     int\n    ExcludeTests bool\n    ExcludeStdlib bool\n    Visited      map[string]bool // cycle detection\n}\n\n// Recursively walk call hierarchy\nfunc WalkCallHierarchy(ctx context.Context, client lsp.Client, root CallHierarchyItem, opts TraverseOptions) (*CallTree, error)\n\n// Build flat list of callers/callees\nfunc FlattenCallers(tree *CallTree) []CallerInfo\n```\n\n### 3. Snippet Extraction (`internal/snippets`)\n```go\n// Extract source lines around a position\nfunc Extract(filePath string, line int, contextLines int) (string, error)\n\n// Extract the call expression at position\nfunc ExtractCallExpr(filePath string, line, startCol, endCol int) (string, error)\n\n// Parse arguments from call expression\nfunc ParseArgs(callExpr string) ([]string, error)\n\n// Detect if file is a test file\nfunc IsTestFile(filePath string) bool\n```\n\n## Implementation Notes\n\n### Symbol Resolution Flow\n```\nUser: \"config.Load\"\n  → Parse(\"config.Load\") → SymbolQuery{Package: \"config\", Name: \"Load\"}\n  → workspace/symbol(\"Load\")\n  → Filter results where package contains \"config\" and name == \"Load\"\n  → Return position for further LSP calls\n```\n\n### Recursive Call Hierarchy Flow\n```\nUser: \"callers --depth 3\"\n  → PrepareCallHierarchy(symbol position)\n  → IncomingCalls(item) → direct callers\n  → For each caller:\n      → If depth \u003c maxDepth \u0026\u0026 not visited:\n          → PrepareCallHierarchy(caller position)\n          → IncomingCalls(item) → recurse\n  → Return full tree\n```\n\n## Acceptance Criteria\n- [ ] Parse pkg.Func, Type.Method, full/path/pkg.Func formats\n- [ ] Resolve symbol via workspace/symbol with filtering\n- [ ] Generate fuzzy suggestions for typos\n- [ ] Recursive traversal respects depth limit\n- [ ] Cycle detection prevents infinite loops\n- [ ] Snippet extraction preserves indentation\n- [ ] Call expression extraction works\n- [ ] Test file detection works\n- [ ] Unit tests for each component\n\n## Files\n- internal/symbols/parse.go\n- internal/symbols/resolve.go\n- internal/symbols/suggest.go\n- internal/traverse/walk.go\n- internal/traverse/flatten.go\n- internal/snippets/extract.go\n- internal/snippets/callexpr.go\n- internal/snippets/testfile.go\n- internal/*_test.go\n\n## Depends On\n- wc-cb10 (LSP client infrastructure)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T04:57:45.340753104Z","updated_at":"2026-01-10T05:33:24.247366914Z","closed_at":"2026-01-10T05:33:24.247366914Z","dependencies":[{"issue_id":"wc-099e","depends_on_id":"wc-cb10","type":"blocks","created_at":"2026-01-10T04:57:54.413462978Z","created_by":"jason"}]}
{"id":"wc-4d61","content_hash":"cb78b8ade3448c0ddf91765081aeb745df19c1d97a82b6bfca621187328f3d8d","title":"Research optimal CLI output formats for call trees and code graphs - AI-consumable","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:16:43.957523257Z","updated_at":"2026-01-10T03:35:12.719590076Z","closed_at":"2026-01-10T03:35:12.719590076Z"}
{"id":"wc-4fe1","content_hash":"28a4740f866bc7dc350780ff152c2112707ffc2090196f88eba0f5f51969d24c","title":"Replace LSP init sleep with readiness polling","description":"## Problem\nThe 200ms sleep after LSP initialization is a hack. On slower machines or larger projects, this may not be enough. On fast machines, it's wasted time.\n\n## Current Code\n```go\ntime.Sleep(200 * time.Millisecond)\n```\nPresent in: callers.go, callees.go, refs.go, tree.go, impact.go\n\n## Proposed Solution\n1. Poll for LSP readiness instead of sleeping\n2. Options:\n   - Send a lightweight request (like `initialized` notification)\n   - Wait for `window/workDoneProgress` completion\n   - Use exponential backoff with a test query\n3. Add configurable timeout (default 30s)\n\n## Acceptance Criteria\n- [ ] Remove hardcoded 200ms sleep\n- [ ] LSP readiness detected reliably\n- [ ] Works on slow and fast machines\n- [ ] Graceful timeout with clear error message","status":"open","priority":3,"issue_type":"bug","created_at":"2026-01-10T05:58:58.671490419Z","updated_at":"2026-01-10T06:03:46.997131685Z"}
{"id":"wc-62b1","content_hash":"4cb5cc51ed54baef083d62d95fb727f2ad65cbac494e6a5bc453d89401a57326","title":"Support multiple symbol queries","description":"","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-10T08:46:58.529505527Z","updated_at":"2026-01-10T08:46:58.529505527Z"}
{"id":"wc-6c54","content_hash":"1ec11864967fc3f088ec5a7f18328c6fd21eba055b9726a7136202a5f76fece1","title":"Improve symbol resolution with fuzzy matching","description":"## Problem\nSymbol resolution is finicky - `Resolver.Resolve` didn't work but `symbols.Parse` did. The workspace symbol search isn't smart about partial matches.\n\n## Current Behavior\n- Workspace symbol search requires fairly exact matches\n- No fuzzy matching or ranking of results\n- Suggestions on errors don't always appear\n\n## Proposed Solution\n1. Implement fuzzy matching when exact match fails\n2. Try multiple query variations:\n   - Exact: `Resolver.Resolve`\n   - Without package: `Resolve`\n   - With wildcards: `*Resolver*Resolve*`\n3. Rank results by relevance (prefer local packages over stdlib)\n4. Always return top N suggestions on failure using Levenshtein\n\n## Files\n- internal/symbols/resolve.go\n\n## Acceptance Criteria\n- [ ] `Resolver.Resolve` resolves to `symbols.Resolver.Resolve`\n- [ ] Suggestions always appear on symbol not found\n- [ ] Local package symbols ranked higher than stdlib","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-10T05:58:47.309544434Z","updated_at":"2026-01-10T06:03:46.933154233Z"}
{"id":"wc-6c5f","content_hash":"3aabae1b15eaa126dc0fe0404794df679004291201d52c88433dce3c059cb70f","title":"Implement --package filter flags","description":"## Problem\nThe --package filter flags are stubbed out with TODO comments in the code.\n\n## Current Code (callers.go:170-172)\n```go\nif callersPackage != \"\" {\n    // TODO: implement package filtering\n}\n```\n\n## Scope\nImplement package filtering for:\n- `callers --package \u003cpattern\u003e`\n- `refs --package \u003cpattern\u003e`\n\n## Behavior\n- Pattern matching: glob style (`internal/*`, `github.com/user/*`)\n- Filter results to only show matches from specified packages\n- Should work with both full paths and relative patterns\n\n## Files\n- cmd/callers.go\n- cmd/refs.go\n- internal/output/filter.go (new, shared logic)\n\n## Acceptance Criteria\n- [ ] `--package internal/*` filters to internal packages\n- [ ] `--package .` filters to current module only\n- [ ] Pattern supports glob wildcards\n- [ ] Works for both callers and refs commands","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-10T05:59:25.14989845Z","updated_at":"2026-01-10T06:03:47.029864703Z"}
{"id":"wc-6fb8","content_hash":"eb2944a7b8b2708aa99ae74c7f83de45aa192ac159678383d771db118daf3f67","title":"Plugin author documentation","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T08:26:35.369479889Z","updated_at":"2026-01-10T08:26:35.369479889Z"}
{"id":"wc-81dd","content_hash":"8739e0c5456ef1af1c974917d97054aecb60512c5edeeb39c0f6c75faa317eb1","title":"Git History Eval - Wildcat Effectiveness Benchmark","description":"End-to-end eval system that uses real git history (e.g., Kubernetes) to benchmark AI coding effectiveness with and without Wildcat. Uses Claude Code in non-interactive mode as the eval runtime.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-11T06:10:18.910533787Z","updated_at":"2026-01-11T06:10:18.910533787Z"}
{"id":"wc-81dd.1","content_hash":"1d17e72a239e73f3b53c30d006f76db63ea5a4d720c3490362ee0e45bfc12b90","title":"Eval product design document","description":"Document the eval methodology: what we're measuring, how we compare AI output to committed code, scoring rubrics, success criteria. Define the A/B test structure (with/without Wildcat).","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-11T06:10:33.817897456Z","updated_at":"2026-01-11T06:10:33.817897456Z"}
{"id":"wc-81dd.2","content_hash":"fc172fb765cdd396b14f6c3a2bce37649cf0e3ffab99341b965ae9ab7ee532a2","title":"Claude Code configuration for non-interactive eval","description":"Determine optimal Claude Code flags for eval runs: --allowedTools, --system-prompt, --output-format, --max-budget-usd, permission handling. Document the configuration for reproducibility.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-11T06:10:33.910498621Z","updated_at":"2026-01-11T06:10:33.910498621Z"}
{"id":"wc-81dd.3","content_hash":"b78d693671262de90a0652782603dad048bfcefbd301df07cf2bdbf3be6af493","title":"Commit candidate selection from git history","description":"Build tooling to scan git history and identify good eval candidates. Filter criteria: has linked issue, not a merge/version bump, reasonable scope (not too big/small), touches code files. Output a curated list of (commit, issue) pairs.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-11T06:10:33.994198553Z","updated_at":"2026-01-11T06:10:33.994198553Z"}
{"id":"wc-81dd.4","content_hash":"a4ec28481bf7717661472551b115b472ad38d71719f1b095a0766155b32d444b","title":"Eval orchestration harness","description":"Build the orchestration code (Go) that: resets repo to commit^, extracts issue description, invokes Claude Code with task, captures resulting diff, stores results. Handle parallelization and failure recovery.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T06:10:34.075886823Z","updated_at":"2026-01-11T06:10:34.075886823Z","dependencies":[{"issue_id":"wc-81dd.4","depends_on_id":"wc-81dd.1","type":"blocks","created_at":"2026-01-11T06:10:40.933600853Z","created_by":"jason"},{"issue_id":"wc-81dd.4","depends_on_id":"wc-81dd.2","type":"blocks","created_at":"2026-01-11T06:10:40.979386928Z","created_by":"jason"},{"issue_id":"wc-81dd.4","depends_on_id":"wc-81dd.3","type":"blocks","created_at":"2026-01-11T06:10:41.015367764Z","created_by":"jason"}]}
{"id":"wc-81dd.5","content_hash":"0d1acd4f82e7da808e5aa2fda0a278bfe555d90239ae7bbcc585f1541e84fd47","title":"Result evaluation and comparison logic","description":"Build comparison tooling: structural diff analysis (same files touched?), AI-as-judge for solution quality, metrics collection (cost, tokens, turns). Generate reports comparing Wildcat vs baseline runs.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T06:10:34.164908282Z","updated_at":"2026-01-11T06:10:34.164908282Z","dependencies":[{"issue_id":"wc-81dd.5","depends_on_id":"wc-81dd.4","type":"blocks","created_at":"2026-01-11T06:10:41.108028097Z","created_by":"jason"}]}
{"id":"wc-81dd.6","content_hash":"b4c0350c891e3675c2372d3b28b8bd6d0cf35119706706beae70978eb2273d97","title":"Docker container isolation for eval runs","description":"Create Docker setup to isolate each eval run: clean repo state, controlled environment, no cross-contamination between runs. Include necessary tooling (Go, Claude Code, git, Wildcat).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T06:10:34.272756853Z","updated_at":"2026-01-11T06:10:34.272756853Z","dependencies":[{"issue_id":"wc-81dd.6","depends_on_id":"wc-81dd.2","type":"blocks","created_at":"2026-01-11T06:10:41.191439211Z","created_by":"jason"}]}
{"id":"wc-879a","content_hash":"7ab1b5fcba7907ff3a3da6dffe1fab6ccae5a0300c3b36a4e7c6b7449baf4e83","title":"LSP daemon mode for persistent connections","description":"## Problem\nEach command spawns a fresh gopls instance. This is slow (~500ms+ startup) and wasteful. Running multiple commands in sequence pays this cost repeatedly.\n\n## Current Behavior\n- NewClient() starts gopls\n- Command runs\n- Client closes, gopls exits\n- Next command starts fresh\n\n## Proposed Solution\nImplement a daemon mode:\n\n1. **Daemon process**\n   - `wildcat daemon start` - starts background daemon\n   - `wildcat daemon stop` - stops daemon\n   - Daemon manages LSP connections per workspace\n\n2. **Connection pooling**\n   - Keep LSP connections alive between commands\n   - Reuse existing connection if same workspace\n   - Timeout idle connections after N minutes\n\n3. **Transparent fallback**\n   - If daemon not running, fall back to current behavior\n   - Commands work the same either way\n\n## Implementation Options\n- Unix socket for daemon communication\n- HTTP server on localhost\n- Simple PID file + named pipe\n\n## Files\n- cmd/daemon.go (new)\n- internal/daemon/daemon.go (new)\n- internal/daemon/client.go (new)\n\n## Acceptance Criteria\n- [ ] Daemon starts and manages LSP connections\n- [ ] Commands use daemon when available\n- [ ] Fallback works when daemon not running\n- [ ] Idle connection cleanup\n- [ ] `wildcat daemon status` shows state","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-10T05:59:13.535876204Z","updated_at":"2026-01-10T06:03:46.970145657Z"}
{"id":"wc-87e7","content_hash":"d5faef20c146ddd407a4ec9eb0fb588ae82cf006d694a52bfaf20e2f16bf252c","title":"Language server configurations","description":"## Context\nWildcat needs to know how to start and configure different LSP servers for each language.\n\n## Scope\nCreate `internal/servers` package that:\n\n### 1. Server Detection\n- Detect language from file extension or explicit flag\n- Find server binary in PATH\n- Check server availability\n\n### 2. Per-Language Configurations\nSupport these servers initially:\n\n| Language | Server | Command | Notes |\n|----------|--------|---------|-------|\n| Go | gopls | `gopls serve` | Most tested |\n| Python | pyright | `pyright-langserver --stdio` | Fast, Microsoft |\n| TypeScript/JS | typescript-language-server | `typescript-language-server --stdio` | Requires tsserver |\n| Rust | rust-analyzer | `rust-analyzer` | Default stdio |\n| C/C++ | clangd | `clangd` | LLVM project |\n| Java | jdtls | complex setup | Eclipse-based |\n\n### 3. Configuration Options\n```go\ntype ServerSpec struct {\n    Language    string   // e.g., \"go\", \"python\"\n    Command     string   // binary name\n    Args        []string // startup args\n    InitOptions map[string]any // LSP initializationOptions\n    Capabilities []string // required capabilities we need\n}\n\n// Detect which server to use\nfunc DetectServer(filePath string) (*ServerSpec, error)\n\n// Check if server is available\nfunc (s *ServerSpec) Available() bool\n\n// Get server for language\nfunc GetServer(language string) (*ServerSpec, error)\n```\n\n### 4. Capability Verification\n- Check that server supports callHierarchy\n- Check for typeHierarchy support\n- Warn if features unavailable\n\n## Acceptance Criteria\n- [ ] gopls configuration works\n- [ ] At least 2 other language servers configured\n- [ ] Server detection by file extension\n- [ ] Availability check (binary exists)\n- [ ] Capability requirements documented\n- [ ] Easy to add new languages\n\n## Files\n- internal/servers/servers.go\n- internal/servers/detect.go\n- internal/servers/configs.go (per-language)\n- internal/servers/*_test.go\n\n## Depends On\n- wc-cb10 (LSP client infrastructure)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T04:57:14.995746828Z","updated_at":"2026-01-10T05:46:52.972235078Z","closed_at":"2026-01-10T05:46:52.972235078Z","dependencies":[{"issue_id":"wc-87e7","depends_on_id":"wc-cb10","type":"blocks","created_at":"2026-01-10T04:57:19.882078779Z","created_by":"jason"}]}
{"id":"wc-9466","content_hash":"6ad424bce4bba453c1e4f0072b5277dcc6f8143adb5d739d45fdd8d704e08cb0","title":"Audit Go analysis ecosystem - packages and tools available","description":"## Context\nBefore building core infrastructure, we need a clear understanding of what the Go ecosystem provides. We want to leverage existing, battle-tested packages rather than reinventing. However, we will NOT shell out to external tools (gopls CLI, guru, etc.) - only use as libraries.\n\n## Goals\n1. Audit standard library analysis packages\n2. Audit golang.org/x/tools packages\n3. Identify any third-party packages worth considering\n4. Determine what we must build from scratch\n5. Document integration strategies\n\n## Scope\n\n### Standard Library (go/*)\nAudit these packages:\n- `go/ast` - AST representation and traversal\n- `go/parser` - parsing source files\n- `go/types` - type checking and type info\n- `go/token` - positions, file sets\n- `go/build` - build constraints, package discovery\n- `go/doc` - documentation extraction\n- `go/format` - source formatting\n- `go/printer` - AST printing\n- `go/scanner` - lexical scanning\n- `go/constant` - constant values\n\nFor each: What does it provide? How does it fit our needs?\n\n### golang.org/x/tools/go/*\nAudit these packages:\n- `go/packages` - modern package loading (replaces go/build)\n- `go/ssa` - SSA form construction\n- `go/ssa/ssautil` - SSA utilities\n- `go/callgraph` - call graph interface\n- `go/callgraph/cha` - Class Hierarchy Analysis\n- `go/callgraph/rta` - Rapid Type Analysis  \n- `go/callgraph/vta` - Variable Type Analysis\n- `go/callgraph/static` - static call graph\n- `go/types/typeutil` - type utilities\n- `go/ast/astutil` - AST utilities\n- `go/analysis` - analysis framework (used by go vet)\n- `go/pointer` - pointer analysis\n\nFor each: Capabilities, limitations, performance characteristics.\n\n### gopls Internal Packages\nCan we use any gopls internals as libraries?\n- `golang.org/x/tools/gopls/internal/...`\n- Check if any are importable/stable\n- Identify useful patterns even if not directly usable\n\n### Third-Party Options\nQuick survey of:\n- github.com/go-toolsmith/* - AST utilities\n- Any other notable analysis libraries\n\n## Deliverables\n\nCreate `docs/ecosystem-audit.md` with:\n\n1. **Package Matrix**\n   - Package name, what it does, our use case, notes\n\n2. **Build vs Leverage Decision**\n   - What we use directly\n   - What we wrap/extend\n   - What we build from scratch\n\n3. **Integration Strategy**\n   - Recommended package stack\n   - How packages compose together\n   - Example code patterns\n\n4. **Risk Assessment**\n   - API stability concerns\n   - Performance considerations\n   - Maintenance burden\n\n## Acceptance Criteria\n- [ ] All stdlib go/* packages documented\n- [ ] All x/tools/go/* packages documented\n- [ ] gopls internals assessed\n- [ ] Third-party options surveyed\n- [ ] Clear build vs leverage recommendations\n- [ ] Integration strategy documented\n- [ ] docs/ecosystem-audit.md complete\n\n## Why This Matters\nPer CLAUDE.md: \"Composability first\" and \"Simple over clever\". We want to build on solid foundations, not reinvent. This audit ensures we make informed decisions about our dependency stack.\n\n## Blocks\n- wc-af7d.1 (Package loading) - this research informs how we build it","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T04:07:19.863049002Z","updated_at":"2026-01-10T04:13:15.240751666Z","closed_at":"2026-01-10T04:13:15.240751666Z"}
{"id":"wc-964f","content_hash":"445a3873c9fb47b97b50ae8fe9f5f57cc9e04f96a895ba6b0fe02a1330e18a59","title":"Symbol disambiguation when multiple matches exist","description":"## Problem\nWhen a symbol name matches multiple definitions (e.g., `Parse` exists in multiple packages), there's no clear way to disambiguate or see all options.\n\n## Current Behavior\n- Returns first match from workspace/symbol\n- No indication that multiple matches exist\n- User must guess the full qualified name\n\n## Proposed Solution\n1. Detect when multiple matches exist\n2. If ambiguous, return structured error with all options:\n```json\n{\n  \"error\": {\n    \"code\": \"ambiguous_symbol\",\n    \"message\": \"Symbol 'Parse' matches multiple definitions\",\n    \"candidates\": [\n      {\"symbol\": \"symbols.Parse\", \"file\": \"internal/symbols/parse.go\", \"line\": 24},\n      {\"symbol\": \"json.Parse\", \"file\": \"encoding/json/decode.go\", \"line\": 100}\n    ]\n  }\n}\n```\n3. Allow explicit selection via full path\n\n## Acceptance Criteria\n- [ ] Detect ambiguous symbols\n- [ ] Return all candidates in error response\n- [ ] Include file/line for each candidate\n- [ ] Works with `--first` flag to take first match (for scripting)","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-10T05:59:50.593400251Z","updated_at":"2026-01-10T06:03:47.088380561Z"}
{"id":"wc-98ff","content_hash":"50505dca427a8e4064c9d72a1bee6da458fce9b5371e32bc470bbc574753ef0d","title":"Research gopls capabilities and produce full report","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:10:51.924627968Z","updated_at":"2026-01-10T03:20:08.274775099Z","closed_at":"2026-01-10T03:20:08.274775099Z"}
{"id":"wc-9b8c","content_hash":"ce8168f53a9e8aceed3a58e1abf6936849869d025a571ffcac7f4137c071ee67","title":"Document optimal AI-only output format findings","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:41:19.072348731Z","updated_at":"2026-01-10T03:52:06.902239952Z","closed_at":"2026-01-10T03:52:06.902239952Z","dependencies":[{"issue_id":"wc-9b8c","depends_on_id":"wc-4d61","type":"discovered-from","created_at":"2026-01-10T03:41:19.088255179Z","created_by":"jason"}]}
{"id":"wc-aa86","content_hash":"6cc54d17d6fe2931d91a50466ca39704e2711f6b22a5d98bff4804bbba508360","title":"Add command-layer tests","description":"## Problem\nNo tests for the cmd layer. All commands are untested at the integration level.\n\n## Current State\n```\n?   github.com/jasonmoo/wildcat/cmd  [no test files]\n```\n\n## Scope\nAdd integration tests for each command:\n- callers\n- callees  \n- tree\n- refs\n- impact\n- formats\n\n## Approach\n1. Use testdata directory with sample Go files\n2. Start real gopls for integration tests\n3. Test both success and error paths\n4. Verify JSON output structure\n\n## Test Cases per Command\n- Valid symbol resolves correctly\n- Invalid symbol returns error with suggestions\n- Flags work (--compact, --depth, --exclude-tests, etc.)\n- Output format is correct JSON structure\n\n## Files\n- cmd/callers_test.go\n- cmd/callees_test.go\n- cmd/tree_test.go\n- cmd/refs_test.go\n- cmd/impact_test.go\n- testdata/*.go (sample files)\n\n## Acceptance Criteria\n- [ ] Each command has at least 3 test cases\n- [ ] Tests use real LSP (gopls)\n- [ ] Error paths tested\n- [ ] Flag behavior tested","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-10T05:59:38.328699463Z","updated_at":"2026-01-10T06:03:47.060359108Z"}
{"id":"wc-af7d","content_hash":"0b892bebda8181a87c6fa0d1780d23f6be2d3fce07a06752ca09e6ba78e1cc7a","title":"Wildcat MVP Implementation","description":"## Overview\nComplete implementation of Wildcat - **language-agnostic** static analysis CLI for AI agents.\n\n## ARCHITECTURE PIVOT (wc-d974)\nFollowing LSP feasibility research, Wildcat now uses an **LSP-based architecture**:\n- Works with any language that has an LSP server (Go, Python, TypeScript, Rust, C++, Java)\n- Wildcat acts as an **LSP orchestrator** - making multiple calls, handling recursion, extracting snippets\n- Language-agnostic support with consistent JSON output\n\n## Goals\n1. Build LSP client infrastructure for communicating with language servers\n2. Create orchestration layer for symbol lookup, recursive traversal, snippet extraction\n3. Implement MVP commands: callers, callees, tree, refs, impact\n4. Deliver JSON output optimized for AI tool integration\n\n## Success Criteria\n- All MVP commands functional with JSON output\n- Symbol-based queries work (pkg.Func, Type.Method)\n- Error responses include suggestions for self-correction\n- Snippets and absolute paths in all results\n- Works with gopls (Go) and at least one other language server\n\n## Architecture Layers\n1. **LSP Infrastructure**: LSP client, server configs, JSON-RPC over stdio\n2. **Orchestration**: Symbol lookup, recursive traversal, snippet extraction\n3. **Output Formatting**: JSON types, snippets, error handling\n4. **Commands**: callers, callees, tree, refs, impact\n\n## Key Tickets\n- wc-cb10: LSP client infrastructure\n- wc-87e7: Language server configurations\n- wc-099e: Orchestration layer\n- wc-af7d.4: Output formatting\n- wc-af7d.5: Error handling\n- wc-af7d.6-10: MVP commands\n\n## Reference\n- docs/lsp-feasibility.md - LSP architecture decision\n- docs/product-design.md - detailed specs\n- docs/gopls-report.md - gap analysis showing why we're building this","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-10T03:55:31.122462659Z","updated_at":"2026-01-10T06:58:24.780619118Z","closed_at":"2026-01-10T06:58:24.780619118Z"}
{"id":"wc-af7d.1","content_hash":"51b1cd0e9572d22c4ed8c2ce8d9da1c2f08d826ad0500bc4b6d1d67e8627245f","title":"Package loading infrastructure","description":"## Context\nFoundation for all Wildcat analysis. Must load Go packages with full type information.\n\n## Scope\nCreate `internal/loader` package that:\n\n1. **Load packages using golang.org/x/tools/go/packages**\n   - Configure with LoadAllSyntax mode for full type info\n   - Handle module discovery from current directory\n   - Support loading specific packages or patterns (./...)\n\n2. **Scope control**\n   - Module only (default): packages in current go.mod\n   - Direct deps: module + direct dependencies\n   - All deps: full transitive closure\n   - Implement via LoadMode flags\n\n3. **Error handling**\n   - Wrap package load errors with context\n   - Detect and report parse errors in source\n   - Return structured errors for missing packages\n\n## Interface Design\n```go\ntype Loader interface {\n    // Load packages matching patterns\n    Load(patterns ...string) ([]*packages.Package, error)\n    \n    // LoadAll loads all packages in current module\n    LoadAll() ([]*packages.Package, error)\n}\n\ntype Config struct {\n    Dir           string    // Working directory\n    IncludeDeps   bool      // Include direct dependencies\n    IncludeAllDeps bool     // Include transitive dependencies\n    BuildFlags    []string  // Build flags (-tags, etc.)\n}\n```\n\n## Acceptance Criteria\n- [ ] Load single package by path\n- [ ] Load all packages in module with ./...\n- [ ] Scope control works (module/deps/all)\n- [ ] Type information available (pkg.TypesInfo)\n- [ ] Syntax trees available (pkg.Syntax)\n- [ ] Errors include file/line for parse errors\n- [ ] Unit tests with test fixtures\n\n## Files\n- internal/loader/loader.go\n- internal/loader/loader_test.go\n\n## Dependencies\n- golang.org/x/tools/go/packages","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:55:45.60224243Z","updated_at":"2026-01-10T04:58:06.569743063Z","closed_at":"2026-01-10T04:58:06.569743063Z","dependencies":[{"issue_id":"wc-af7d.1","depends_on_id":"wc-9466","type":"blocks","created_at":"2026-01-10T04:07:39.885626658Z","created_by":"jason"},{"issue_id":"wc-af7d.1","depends_on_id":"wc-d974","type":"blocks","created_at":"2026-01-10T04:17:08.191125365Z","created_by":"jason"}]}
{"id":"wc-af7d.10","content_hash":"81b8a1fdd6f58e7b09e63c965e9782f00310da87d4978bb8f4f6e1220b819fb3","title":"Implement impact command","description":"## Context\nComprehensive impact analysis: everything affected by changing a symbol. Combines callers, refs, and package analysis into one query.\n\n## Scope\nCreate `cmd/impact.go` that:\n\n1. **Accept symbol argument**\n   - Parse and resolve symbol\n   - Determine symbol kind (function, type, method, etc.)\n\n2. **Gather all impacts**\n   - Transitive callers (recursive, not just direct)\n   - All references (using refs logic)\n   - Interface implementations (if symbol is interface method)\n   - Dependent packages (packages importing this package)\n\n3. **Categorize by impact type**\n   - callers: code paths that invoke this\n   - references: type/value usages\n   - implementations: types implementing interface\n   - dependents: packages that import this package\n\n4. **Include reason field**\n   - \"parameter type\", \"return type\", \"variable declaration\"\n   - \"method call\", \"function call\", \"interface implementation\"\n\n## CLI Design\n```\nwildcat impact \u003csymbol\u003e [flags]\n\nFlags:\n  --exclude-tests     Exclude test files\n  --depth int         Max depth for transitive callers (default unlimited)\n  --include-deps      Include impact in dependencies\n```\n\n## Output Example\n```json\n{\n  \"query\": {\n    \"command\": \"impact\",\n    \"target\": \"config.Config\",\n    \"resolved\": \"github.com/user/proj/internal/config.Config\"\n  },\n  \"target\": {\n    \"symbol\": \"config.Config\",\n    \"kind\": \"type\",\n    \"file\": \"/path/to/config/config.go\",\n    \"line\": 10\n  },\n  \"impact\": {\n    \"callers\": [...],\n    \"references\": [...],\n    \"implementations\": [...],\n    \"dependents\": [...]\n  },\n  \"summary\": {\n    \"total_locations\": 12,\n    \"callers\": 5,\n    \"references\": 4,\n    \"implementations\": 0,\n    \"dependent_packages\": 3,\n    \"in_tests\": 2\n  }\n}\n```\n\n## Implementation Notes\n- Reuse callers logic for transitive call analysis\n- Reuse refs logic for reference finding\n- Add new logic for interface implementations\n- Add package dependency analysis\n\n## Acceptance Criteria\n- [ ] Find transitive callers\n- [ ] Find all references\n- [ ] Find interface implementations (if applicable)\n- [ ] Find dependent packages\n- [ ] Include reason for each impact\n- [ ] Categorized output structure\n- [ ] Summary with counts by category\n- [ ] --depth limits caller traversal\n- [ ] Integration test with type change scenario\n\n## Files\n- cmd/impact.go\n- cmd/impact_test.go\n- internal/analysis/implementations.go (new)\n- internal/analysis/dependents.go (new)\n\n## Depends On\n- wc-af7d.6 (callers - for transitive caller analysis)\n- wc-af7d.9 (refs - for reference finding)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T04:01:19.097775621Z","updated_at":"2026-01-10T05:43:52.665542565Z","closed_at":"2026-01-10T05:43:52.665542565Z","dependencies":[{"issue_id":"wc-af7d.10","depends_on_id":"wc-af7d.6","type":"blocks","created_at":"2026-01-10T04:01:19.101626429Z","created_by":"jason"},{"issue_id":"wc-af7d.10","depends_on_id":"wc-af7d.9","type":"blocks","created_at":"2026-01-10T04:01:19.105780902Z","created_by":"jason"}]}
{"id":"wc-af7d.11","content_hash":"b8769550ac8d16c85e10320db08e5643d5fd5ea8b2f9ea954a871d5563c38053","title":"Implement implements command","description":"## Context\nFind all types implementing an interface. Useful for understanding polymorphism and finding concrete implementations.\n\n## Scope\nCreate `cmd/implements.go` that:\n\n1. **Accept interface type argument**\n   - Parse as Type (must be interface)\n   - Resolve to types.Interface\n\n2. **Find implementations**\n   - Scan all types in scope\n   - Check method sets for interface satisfaction\n   - Include pointer and non-pointer receivers\n\n3. **Format output**\n   - List of implementing types with locations\n   - Include method coverage info\n\n## CLI Design\n```\nwildcat implements \u003cinterface\u003e [flags]\n\nFlags:\n  --package string   Limit to package pattern\n  --include-deps     Include types in dependencies\n```\n\n## Output Example\n```json\n{\n  \"interface\": \"io.Reader\",\n  \"implementations\": [\n    {\n      \"type\": \"*bytes.Buffer\",\n      \"package\": \"bytes\",\n      \"file\": \"/path/to/file.go\",\n      \"line\": 45\n    }\n  ]\n}\n```\n\n## Acceptance Criteria\n- [ ] Resolve interface type\n- [ ] Find all implementing types in module\n- [ ] Handle pointer vs value receivers\n- [ ] Output with type locations\n- [ ] --include-deps expands scope\n\n## Files\n- cmd/implements.go\n- cmd/implements_test.go\n\n## Priority\nMedium (P2) - Future command, not MVP","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T04:01:32.786601328Z","updated_at":"2026-01-10T06:06:03.411423558Z","closed_at":"2026-01-10T06:06:03.411423558Z","dependencies":[{"issue_id":"wc-af7d.11","depends_on_id":"wc-af7d.2","type":"blocks","created_at":"2026-01-10T04:01:32.79092761Z","created_by":"jason"},{"issue_id":"wc-af7d.11","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T04:01:32.79440973Z","created_by":"jason"}]}
{"id":"wc-af7d.12","content_hash":"7c5d82d0080b12cf98e2e6cb93a101491154571155654ab3eadc0e90fda8b2a5","title":"Implement satisfies command","description":"## Context\nFind all interfaces a type satisfies. Inverse of implements command.\n\n## Scope\nCreate `cmd/satisfies.go` that:\n\n1. **Accept type argument**\n   - Parse as Type (concrete type)\n   - Resolve to types.Named or types.Pointer\n\n2. **Find satisfied interfaces**\n   - Scan all interfaces in scope\n   - Check if type's method set satisfies each interface\n   - Include standard library interfaces\n\n3. **Format output**\n   - List of interfaces with locations\n\n## CLI Design\n```\nwildcat satisfies \u003ctype\u003e [flags]\n\nFlags:\n  --include-stdlib   Include standard library interfaces\n  --package string   Limit interface search to pattern\n```\n\n## Output Example\n```json\n{\n  \"type\": \"*Server\",\n  \"satisfies\": [\n    {\n      \"interface\": \"io.Closer\",\n      \"package\": \"io\",\n      \"methods\": [\"Close\"]\n    },\n    {\n      \"interface\": \"http.Handler\",\n      \"package\": \"net/http\",\n      \"methods\": [\"ServeHTTP\"]\n    }\n  ]\n}\n```\n\n## Acceptance Criteria\n- [ ] Resolve concrete type\n- [ ] Find all satisfied interfaces\n- [ ] Include method list for each interface\n- [ ] --include-stdlib for standard library\n\n## Files\n- cmd/satisfies.go\n- cmd/satisfies_test.go\n\n## Priority\nMedium (P2) - Future command, not MVP","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T04:01:42.359231713Z","updated_at":"2026-01-10T06:07:45.342709635Z","closed_at":"2026-01-10T06:07:45.342709635Z","dependencies":[{"issue_id":"wc-af7d.12","depends_on_id":"wc-af7d.2","type":"blocks","created_at":"2026-01-10T04:01:42.363074538Z","created_by":"jason"},{"issue_id":"wc-af7d.12","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T04:01:42.367227556Z","created_by":"jason"}]}
{"id":"wc-af7d.13","content_hash":"c81cbf89da3068295980424ee5bd7dd57fab9b5c5f4b7acc40c6131c2084eef0","title":"Implement deps command","description":"## Context\nPackage dependency graph. Show what a package imports or what imports it.\n\n## Scope\nCreate `cmd/deps.go` that:\n\n1. **Accept package path argument**\n   - Resolve package path\n   - Handle relative paths (./internal/server)\n\n2. **Two modes**\n   - Forward (default): what does this package import?\n   - Reverse (--reverse): what packages import this?\n\n3. **Format output**\n   - List of packages with import locations\n\n## CLI Design\n```\nwildcat deps \u003cpackage\u003e [flags]\n\nFlags:\n  --reverse        What imports this package (default: what it imports)\n  --depth int      Transitive depth (default 1, direct only)\n  --exclude-stdlib Exclude standard library\n```\n\n## Output Example\n```json\n{\n  \"package\": \"github.com/user/proj/internal/server\",\n  \"direction\": \"imports\",\n  \"dependencies\": [\n    {\n      \"package\": \"github.com/user/proj/internal/config\",\n      \"import_file\": \"/path/to/server/server.go\",\n      \"import_line\": 8\n    },\n    {\n      \"package\": \"net/http\",\n      \"import_file\": \"/path/to/server/server.go\",\n      \"import_line\": 5\n    }\n  ]\n}\n```\n\n## Acceptance Criteria\n- [ ] Show direct imports\n- [ ] Show reverse (importers)\n- [ ] Transitive with --depth\n- [ ] --exclude-stdlib filters\n\n## Files\n- cmd/deps.go\n- cmd/deps_test.go\n\n## Priority\nMedium (P2) - Future command, not MVP","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T04:01:54.678956764Z","updated_at":"2026-01-10T06:14:04.234755198Z","closed_at":"2026-01-10T06:14:04.234755198Z","dependencies":[{"issue_id":"wc-af7d.13","depends_on_id":"wc-af7d.1","type":"blocks","created_at":"2026-01-10T04:01:54.682917158Z","created_by":"jason"},{"issue_id":"wc-af7d.13","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T04:01:54.686291533Z","created_by":"jason"}]}
{"id":"wc-af7d.14","content_hash":"7935d8875e3f2bb79f0f6d3d4098fc853a5696d65fd24684c8b9e6a80f03d47e","title":"Implement readme command","description":"## Context\nOutput AI onboarding instructions. Designed to be included in system prompts, CLAUDE.md, or MCP server context.\n\n## Scope\nCreate `cmd/readme.go` that outputs comprehensive usage guidance for AI agents.\n\n1. **When to use Wildcat**\n   - Symbol queries (callers, callees, tree)\n   - Impact analysis\n   - Reference finding\n\n2. **When to use alternatives**\n   - grep: text patterns, non-Go files\n   - gopls: diagnostics, formatting, rename\n\n3. **Command quick reference**\n   - All commands with examples\n   - Common flags\n\n4. **Workflow patterns**\n   - Refactoring workflow\n   - Understanding new code\n   - Impact assessment before changes\n\n## CLI Design\n```\nwildcat readme [flags]\n\nFlags:\n  --compact    Quick reference only (no workflows)\n```\n\n## Output Format\nPlain text/markdown suitable for:\n- Including in CLAUDE.md\n- System prompts\n- MCP server context\n\n## Acceptance Criteria\n- [ ] Comprehensive tool guidance\n- [ ] When to use vs alternatives\n- [ ] Command quick reference with examples\n- [ ] Workflow patterns\n- [ ] --compact for minimal version\n- [ ] Updates as commands are added\n\n## Files\n- cmd/readme.go\n- cmd/readme_test.go\n\n## Priority\nMedium (P2) - Should be done after MVP commands exist\n\n## Depends On\n- wc-af7d.10 (impact - all MVP commands should exist first)","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-10T04:02:08.298025663Z","updated_at":"2026-01-10T06:15:38.343641665Z","closed_at":"2026-01-10T06:15:38.343641665Z","dependencies":[{"issue_id":"wc-af7d.14","depends_on_id":"wc-af7d.10","type":"blocks","created_at":"2026-01-10T04:02:08.302315001Z","created_by":"jason"}]}
{"id":"wc-af7d.2","content_hash":"de2fe8a44e84726f7cd597cd2bd81ccb026636a7bc507dec2c0c1e89b4de3f88","title":"Symbol resolution and parsing","description":"## Context\nUsers query by symbol name (pkg.Func, Type.Method). We need to parse these inputs and resolve them to actual Go objects.\n\n## Scope\nCreate `internal/symbols` package that:\n\n1. **Parse symbol input formats**\n   - `Function` - function in current/contextual package\n   - `pkg.Function` - function in package named \"pkg\"\n   - `Type.Method` - method on type\n   - `path/to/pkg.Function` - fully qualified\n   - `(*Type).Method` - method on pointer receiver\n\n2. **Resolve to types.Object**\n   - Search loaded packages for matching symbol\n   - Handle package name vs package path ambiguity\n   - Support method resolution on types\n\n3. **Fuzzy matching for suggestions**\n   - When symbol not found, find similar names\n   - Use Levenshtein distance or similar\n   - Return top 3-5 suggestions\n\n4. **Handle ambiguity**\n   - Multiple packages with same name\n   - Return all candidates with full paths\n\n## Interface Design\n```go\ntype Symbol struct {\n    Package  string   // Package path or name\n    Type     string   // Receiver type (if method)\n    Pointer  bool     // Pointer receiver\n    Name     string   // Function/method name\n    Raw      string   // Original input\n}\n\ntype Resolver interface {\n    // Parse parses symbol string into structured form\n    Parse(input string) (*Symbol, error)\n    \n    // Resolve finds the types.Object for a symbol\n    Resolve(sym *Symbol) (types.Object, error)\n    \n    // Suggest returns similar symbols for typo correction\n    Suggest(sym *Symbol, limit int) []string\n}\n\ntype ResolveResult struct {\n    Object   types.Object\n    Package  *packages.Package\n    Position token.Position  // File, line, col\n}\n```\n\n## Acceptance Criteria\n- [ ] Parse pkg.Func format\n- [ ] Parse Type.Method format\n- [ ] Parse (*Type).Method format\n- [ ] Parse path/to/pkg.Func format\n- [ ] Resolve function in package\n- [ ] Resolve method on type\n- [ ] Return position (file:line) for resolved symbol\n- [ ] Suggest similar symbols when not found\n- [ ] Handle ambiguous package names\n- [ ] Unit tests for all parse formats\n\n## Files\n- internal/symbols/parse.go\n- internal/symbols/resolve.go\n- internal/symbols/suggest.go\n- internal/symbols/*_test.go\n\n## Depends On\n- wc-af7d.1 (Package loading infrastructure)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:56:02.890832458Z","updated_at":"2026-01-10T04:58:12.787805907Z","closed_at":"2026-01-10T04:58:12.787805907Z","dependencies":[{"issue_id":"wc-af7d.2","depends_on_id":"wc-af7d.1","type":"blocks","created_at":"2026-01-10T03:56:02.895157496Z","created_by":"jason"}]}
{"id":"wc-af7d.3","content_hash":"92af09031a962f3771bc84949ee421f9ed92e39db2a5c7a11fef97753ebd7598","title":"Call graph construction","description":"## Context\nCall graph is the core data structure for callers, callees, tree, and impact commands. We need to build it from loaded packages using SSA and callgraph algorithms.\n\n## Scope\nCreate `internal/callgraph` package that:\n\n1. **Build SSA representation**\n   - Convert packages to SSA form using golang.org/x/tools/go/ssa\n   - Use ssa.BuilderMode for necessary analysis\n   - Cache SSA program for reuse\n\n2. **Construct call graph**\n   - Support three algorithms:\n     - CHA (Class Hierarchy Analysis) - fast, imprecise\n     - RTA (Rapid Type Analysis) - medium, balanced (default)\n     - VTA (Variable Type Analysis) - slow, precise\n   - Cache graph for reuse across queries\n\n3. **Query interface**\n   - Get callers of a function\n   - Get callees of a function\n   - Traverse up/down to depth N\n   - Filter by package pattern\n   - Exclude stdlib\n\n## Interface Design\n```go\ntype Algorithm string\n\nconst (\n    AlgorithmCHA Algorithm = \"cha\"\n    AlgorithmRTA Algorithm = \"rta\"\n    AlgorithmVTA Algorithm = \"vta\"\n)\n\ntype Graph interface {\n    // Callers returns all callers of the given function\n    Callers(fn *ssa.Function) []*callgraph.Edge\n    \n    // Callees returns all functions called by the given function\n    Callees(fn *ssa.Function) []*callgraph.Edge\n    \n    // Walk traverses the graph from a starting function\n    Walk(fn *ssa.Function, direction Direction, depth int, visitor func(*callgraph.Edge) bool)\n}\n\ntype Builder interface {\n    // Build constructs call graph from loaded packages\n    Build(pkgs []*packages.Package, algo Algorithm) (Graph, error)\n    \n    // SSAFunction returns SSA function for a types.Func\n    SSAFunction(fn *types.Func) *ssa.Function\n}\n\ntype Direction int\n\nconst (\n    DirectionUp   Direction = iota  // callers\n    DirectionDown                   // callees\n)\n```\n\n## Acceptance Criteria\n- [ ] Build SSA from packages\n- [ ] Construct call graph with CHA\n- [ ] Construct call graph with RTA\n- [ ] Construct call graph with VTA\n- [ ] Query callers of function\n- [ ] Query callees of function\n- [ ] Walk graph with depth limit\n- [ ] Filter by package pattern\n- [ ] Exclude stdlib option\n- [ ] Map types.Func to ssa.Function\n- [ ] Unit tests for each algorithm\n\n## Files\n- internal/callgraph/builder.go\n- internal/callgraph/graph.go\n- internal/callgraph/walk.go\n- internal/callgraph/*_test.go\n\n## Dependencies\n- golang.org/x/tools/go/ssa\n- golang.org/x/tools/go/ssa/ssautil\n- golang.org/x/tools/go/callgraph\n- golang.org/x/tools/go/callgraph/cha\n- golang.org/x/tools/go/callgraph/rta\n- golang.org/x/tools/go/callgraph/vta\n\n## Depends On\n- wc-af7d.1 (Package loading infrastructure)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:56:21.999630583Z","updated_at":"2026-01-10T04:58:06.674542647Z","closed_at":"2026-01-10T04:58:06.674542647Z","dependencies":[{"issue_id":"wc-af7d.3","depends_on_id":"wc-af7d.1","type":"blocks","created_at":"2026-01-10T03:56:22.00415759Z","created_by":"jason"}]}
{"id":"wc-af7d.4","content_hash":"8852a73bcca245499dedd6029400c370f62be25bcd4b00ca860ab309910dc499","title":"JSON output formatting and snippets","description":"## Context\nAll commands output structured JSON. We need consistent formatting, snippet extraction, and output types that are ready for AI tool consumption.\n\n## Scope\nCreate `internal/output` package that:\n\n1. **Define output types**\n   - Query block (command, target, resolved)\n   - Target block (symbol, file, line, signature)\n   - Result items (symbol, package, file, line, line_end, snippet, call_expr, args, in_test)\n   - Summary block (count, packages, in_tests, truncated)\n   - Error block (code, message, suggestions, context)\n\n2. **Snippet extraction**\n   - Extract source lines around a position\n   - Configurable context lines (default 3)\n   - Preserve original indentation\n   - Extract just the call expression\n\n3. **Path handling**\n   - Always output absolute paths\n   - Resolve from token.Position\n\n4. **JSON serialization**\n   - Consistent field naming (snake_case)\n   - Pretty print option\n   - Streaming for large results\n\n## Interface Design\n```go\ntype QueryInfo struct {\n    Command  string `json:\"command\"`\n    Target   string `json:\"target\"`\n    Resolved string `json:\"resolved\"`\n}\n\ntype TargetInfo struct {\n    Symbol    string `json:\"symbol\"`\n    File      string `json:\"file\"`\n    Line      int    `json:\"line\"`\n    Signature string `json:\"signature,omitempty\"`\n}\n\ntype Result struct {\n    Symbol   string   `json:\"symbol\"`\n    Package  string   `json:\"package\"`\n    File     string   `json:\"file\"`\n    Line     int      `json:\"line\"`\n    LineEnd  int      `json:\"line_end\"`\n    Snippet  string   `json:\"snippet,omitempty\"`\n    CallExpr string   `json:\"call_expr,omitempty\"`\n    Args     []string `json:\"args,omitempty\"`\n    InTest   bool     `json:\"in_test\"`\n}\n\ntype Summary struct {\n    Count     int      `json:\"count\"`\n    Packages  []string `json:\"packages\"`\n    InTests   int      `json:\"in_tests\"`\n    Truncated bool     `json:\"truncated\"`\n}\n\ntype ErrorResponse struct {\n    Code        string            `json:\"code\"`\n    Message     string            `json:\"message\"`\n    Suggestions []string          `json:\"suggestions,omitempty\"`\n    Context     map[string]any    `json:\"context,omitempty\"`\n}\n\ntype SnippetExtractor interface {\n    // Extract returns source lines around position\n    Extract(pos token.Position, contextLines int) (string, error)\n    \n    // ExtractExpr returns just the expression at position\n    ExtractExpr(pos token.Position) (string, error)\n}\n```\n\n## Acceptance Criteria\n- [ ] Define all output types with JSON tags\n- [ ] Extract snippet with configurable context\n- [ ] Extract call expression only\n- [ ] Output absolute paths\n- [ ] Detect test files (in_test field)\n- [ ] Serialize to JSON with proper formatting\n- [ ] Handle edge cases (start/end of file)\n- [ ] Unit tests for snippet extraction\n\n## Files\n- internal/output/types.go\n- internal/output/snippet.go\n- internal/output/json.go\n- internal/output/*_test.go\n\n## Depends On\n- wc-af7d.1 (Package loading - needs file access)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:56:42.168398223Z","updated_at":"2026-01-10T05:29:28.844419713Z","closed_at":"2026-01-10T05:29:28.844419713Z","dependencies":[{"issue_id":"wc-af7d.4","depends_on_id":"wc-af7d.1","type":"blocks","created_at":"2026-01-10T03:56:42.172872031Z","created_by":"jason"}]}
{"id":"wc-af7d.5","content_hash":"a553d754394c008a5f205e5efb4160005727c45b65c17ae4f8e4fd0bc6bfcec2","title":"Error handling with suggestions","description":"## Context\nAI agents can self-correct if errors include helpful suggestions. We need structured error responses with fuzzy-matched alternatives.\n\n## Scope\nCreate `internal/errors` package that:\n\n1. **Define error types**\n   - SymbolNotFound - symbol doesn't exist\n   - AmbiguousSymbol - multiple matches\n   - PackageNotFound - package path invalid\n   - ParseError - source has syntax errors\n   - LoadError - failed to load packages\n\n2. **Include suggestions**\n   - Use fuzzy matching to find similar symbols\n   - Limit to top 3-5 suggestions\n   - Include context (packages searched, etc.)\n\n3. **Convert to JSON**\n   - Implement error interface\n   - Provide ToJSON() method for output\n   - Include error code for programmatic handling\n\n## Interface Design\n```go\ntype Code string\n\nconst (\n    CodeSymbolNotFound   Code = \"symbol_not_found\"\n    CodeAmbiguousSymbol  Code = \"ambiguous_symbol\"\n    CodePackageNotFound  Code = \"package_not_found\"\n    CodeParseError       Code = \"parse_error\"\n    CodeLoadError        Code = \"load_error\"\n)\n\ntype WildcatError struct {\n    Code        Code\n    Message     string\n    Suggestions []string\n    Context     map[string]any\n}\n\nfunc (e *WildcatError) Error() string\nfunc (e *WildcatError) ToJSON() []byte\n\n// Constructor functions\nfunc NewSymbolNotFound(symbol string, suggestions []string) *WildcatError\nfunc NewAmbiguousSymbol(symbol string, candidates []string) *WildcatError\nfunc NewPackageNotFound(pkg string) *WildcatError\nfunc NewParseError(file string, line int, msg string) *WildcatError\nfunc NewLoadError(patterns []string, err error) *WildcatError\n```\n\n## Acceptance Criteria\n- [ ] Define error types with codes\n- [ ] Include suggestions in SymbolNotFound\n- [ ] Include candidates in AmbiguousSymbol\n- [ ] ToJSON produces valid JSON\n- [ ] Error() returns human-readable message\n- [ ] Context includes useful debugging info\n- [ ] Unit tests for all error types\n\n## Files\n- internal/errors/errors.go\n- internal/errors/errors_test.go\n\n## Depends On\n- wc-af7d.2 (Symbol resolution - for suggestion generation)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:56:57.643255869Z","updated_at":"2026-01-10T05:31:02.047632331Z","closed_at":"2026-01-10T05:31:02.047632331Z","dependencies":[{"issue_id":"wc-af7d.5","depends_on_id":"wc-af7d.2","type":"blocks","created_at":"2026-01-10T03:56:57.646710381Z","created_by":"jason"}]}
{"id":"wc-af7d.6","content_hash":"1cc03f33a52f612884f7b78e9e87d3f617fa83e62175b2964d76c84a5b311857","title":"Implement callers command","description":"## Context\nFirst and most important command. Find all callers of a function or method. This proves out the entire infrastructure.\n\n## Scope\nCreate `cmd/callers.go` that:\n\n1. **Accept symbol argument**\n   - Parse symbol using symbols.Parse()\n   - Resolve using symbols.Resolve()\n   - Handle errors with suggestions\n\n2. **Query call graph**\n   - Build call graph with selected algorithm (default: RTA)\n   - Find all callers using callgraph.Callers()\n\n3. **Format output**\n   - Extract snippets for each caller\n   - Build Result objects with all fields\n   - Generate summary\n\n4. **Support flags**\n   - --exclude-tests: filter out *_test.go\n   - --package: limit to package pattern\n   - --limit: cap results\n   - --context: lines of context in snippet\n   - --compact: omit snippets\n   - --algorithm: cha|rta|vta\n\n## CLI Design\n```\nwildcat callers \u003csymbol\u003e [flags]\n\nArguments:\n  symbol    Function or method (e.g., pkg.Func, Type.Method)\n\nFlags:\n  --exclude-tests    Exclude test files\n  --package string   Limit to package pattern\n  --limit int        Maximum results (0 = unlimited)\n  --context int      Lines of context (default 3)\n  --compact          Omit snippets\n  --algorithm string Algorithm: cha, rta, vta (default \"rta\")\n```\n\n## Output Example\n```json\n{\n  \"query\": {\n    \"command\": \"callers\",\n    \"target\": \"config.Load\",\n    \"resolved\": \"github.com/user/proj/internal/config.Load\"\n  },\n  \"target\": {\n    \"symbol\": \"config.Load\",\n    \"file\": \"/path/to/config/config.go\",\n    \"line\": 15,\n    \"signature\": \"func Load(path string) (*Config, error)\"\n  },\n  \"results\": [...],\n  \"summary\": {\n    \"count\": 5,\n    \"packages\": [\"main\", \"server\"],\n    \"in_tests\": 1,\n    \"truncated\": false\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] Parse symbol argument\n- [ ] Resolve symbol to function\n- [ ] Find callers in call graph\n- [ ] Output JSON with all fields\n- [ ] --exclude-tests works\n- [ ] --package filtering works\n- [ ] --limit caps results\n- [ ] --context controls snippet size\n- [ ] --compact omits snippets\n- [ ] Error output includes suggestions\n- [ ] Integration test with real Go code\n\n## Files\n- cmd/callers.go\n- cmd/callers_test.go\n\n## Depends On\n- wc-af7d.2 (Symbol resolution)\n- wc-af7d.3 (Call graph)\n- wc-af7d.4 (Output formatting)\n- wc-af7d.5 (Error handling)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T04:00:11.861183858Z","updated_at":"2026-01-10T05:38:48.120509161Z","closed_at":"2026-01-10T05:38:48.120509161Z","dependencies":[{"issue_id":"wc-af7d.6","depends_on_id":"wc-af7d.2","type":"blocks","created_at":"2026-01-10T04:00:11.864938473Z","created_by":"jason"},{"issue_id":"wc-af7d.6","depends_on_id":"wc-af7d.3","type":"blocks","created_at":"2026-01-10T04:00:11.867959646Z","created_by":"jason"},{"issue_id":"wc-af7d.6","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T04:00:11.871809909Z","created_by":"jason"},{"issue_id":"wc-af7d.6","depends_on_id":"wc-af7d.5","type":"blocks","created_at":"2026-01-10T04:00:11.874970218Z","created_by":"jason"},{"issue_id":"wc-af7d.6","depends_on_id":"wc-cb10","type":"blocks","created_at":"2026-01-10T04:58:18.407243428Z","created_by":"jason"},{"issue_id":"wc-af7d.6","depends_on_id":"wc-099e","type":"blocks","created_at":"2026-01-10T04:58:18.442294555Z","created_by":"jason"}]}
{"id":"wc-af7d.7","content_hash":"00e0befd83838ad3df6c4d8f8748231b532108edda22803ebc6c2bdd958432e3","title":"Implement callees command","description":"## Context\nMirror of callers command. Find all functions called by a given function. Shares most infrastructure with callers.\n\n## Scope\nCreate `cmd/callees.go` that:\n\n1. **Accept symbol argument**\n   - Same parsing/resolution as callers\n\n2. **Query call graph**\n   - Find all callees using callgraph.Callees()\n   - Same algorithm options\n\n3. **Format output**\n   - Same output structure as callers\n   - Results show what the target calls\n\n4. **Support same flags**\n   - --exclude-tests, --package, --limit, --context, --compact, --algorithm\n\n## CLI Design\n```\nwildcat callees \u003csymbol\u003e [flags]\n```\n\nSame flags as callers command.\n\n## Implementation Notes\n- Extract shared logic from callers into helper function\n- Only difference is graph traversal direction\n- Consider refactoring callers to use shared code\n\n## Acceptance Criteria\n- [ ] Parse symbol argument\n- [ ] Find callees in call graph\n- [ ] Output JSON with all fields\n- [ ] All flags work (same as callers)\n- [ ] Shared code with callers (no duplication)\n\n## Files\n- cmd/callees.go\n- cmd/callees_test.go\n- cmd/shared.go (if extracting common logic)\n\n## Depends On\n- wc-af7d.6 (callers command - shares infrastructure)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T04:00:23.688759041Z","updated_at":"2026-01-10T05:39:15.314930121Z","closed_at":"2026-01-10T05:39:15.314930121Z","dependencies":[{"issue_id":"wc-af7d.7","depends_on_id":"wc-af7d.6","type":"blocks","created_at":"2026-01-10T04:00:23.692622664Z","created_by":"jason"}]}
{"id":"wc-af7d.8","content_hash":"63a53173f0ecf757f691e17e2213680707727961ec956745d7bf78b568590e3b","title":"Implement tree command","description":"## Context\nBuild a call tree from a starting point. Recursive traversal of callers (up) or callees (down) with depth control.\n\n## Scope\nCreate `cmd/tree.go` that:\n\n1. **Accept symbol argument**\n   - Same parsing/resolution as callers/callees\n\n2. **Recursive traversal**\n   - Walk graph up (callers) or down (callees)\n   - Respect depth limit\n   - Track visited nodes to avoid cycles\n   - Collect edges with positions\n\n3. **Build tree structure**\n   - nodes: map of function -\u003e details + connections\n   - edges: list of from/to with positions\n   - Different from flat results list\n\n4. **Support flags**\n   - --depth: max traversal depth (default 3)\n   - --direction: up|down (default down)\n   - --exclude-tests, --exclude-stdlib\n   - --algorithm: cha|rta|vta\n\n## CLI Design\n```\nwildcat tree \u003csymbol\u003e [flags]\n\nFlags:\n  --depth int        Maximum depth (default 3)\n  --direction string up or down (default \"down\")\n  --exclude-tests    Exclude test files\n  --exclude-stdlib   Exclude standard library\n  --algorithm string cha, rta, vta (default \"rta\")\n```\n\n## Output Example\n```json\n{\n  \"query\": {\n    \"command\": \"tree\",\n    \"root\": \"main.main\",\n    \"depth\": 3,\n    \"direction\": \"down\"\n  },\n  \"nodes\": {\n    \"main.main\": {\n      \"file\": \"/path/to/main.go\",\n      \"line\": 10,\n      \"signature\": \"func main()\",\n      \"calls\": [\"cmd.Execute\", \"os.Exit\"]\n    },\n    \"cmd.Execute\": {\n      \"file\": \"/path/to/cmd/root.go\",\n      \"line\": 15,\n      \"calls\": [\"config.Load\"]\n    }\n  },\n  \"edges\": [\n    {\"from\": \"main.main\", \"to\": \"cmd.Execute\", \"file\": \"/path/main.go\", \"line\": 11}\n  ],\n  \"summary\": {\n    \"node_count\": 5,\n    \"edge_count\": 8,\n    \"max_depth_reached\": 3,\n    \"truncated\": false\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] Traverse down (callees) recursively\n- [ ] Traverse up (callers) recursively\n- [ ] Respect depth limit\n- [ ] Handle cycles (don't infinite loop)\n- [ ] Build nodes map with details\n- [ ] Build edges list with positions\n- [ ] --exclude-stdlib filters standard library\n- [ ] Summary shows depth reached\n- [ ] Integration test with recursive calls\n\n## Files\n- cmd/tree.go\n- cmd/tree_test.go\n\n## Depends On\n- wc-af7d.6 (callers)\n- wc-af7d.7 (callees)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T04:00:43.166160313Z","updated_at":"2026-01-10T05:39:15.357461817Z","closed_at":"2026-01-10T05:39:15.357461817Z","dependencies":[{"issue_id":"wc-af7d.8","depends_on_id":"wc-af7d.6","type":"blocks","created_at":"2026-01-10T04:00:43.170703458Z","created_by":"jason"},{"issue_id":"wc-af7d.8","depends_on_id":"wc-af7d.7","type":"blocks","created_at":"2026-01-10T04:00:43.174334873Z","created_by":"jason"}]}
{"id":"wc-af7d.9","content_hash":"db1a28b38078c21fefc74b0d7be94d1bcacd48f47b6f6a1810f7da1d06a96888","title":"Implement refs command","description":"## Context\nFind all references to a symbol, not just calls. Uses type information rather than call graph. Important for type/variable/constant usage tracking.\n\n## Scope\nCreate `cmd/refs.go` that:\n\n1. **Accept symbol argument**\n   - Parse and resolve symbol\n   - Can be function, type, variable, constant\n\n2. **Find references using types.Info**\n   - Walk AST of all files\n   - Check Uses map for references to target object\n   - Include Defs for completeness\n\n3. **Categorize references**\n   - Call sites (function calls)\n   - Type references (variable declarations, parameters)\n   - Value references (assignments, passing as argument)\n\n4. **Format output**\n   - Same structure as callers\n   - Add \"reason\" field for reference type\n\n## CLI Design\n```\nwildcat refs \u003csymbol\u003e [flags]\n\nFlags:\n  --exclude-tests    Exclude test files\n  --package string   Limit to package pattern\n  --limit int        Maximum results\n  --context int      Lines of context (default 3)\n  --compact          Omit snippets\n```\n\n## Implementation Approach\n```go\n// Walk all packages\nfor _, pkg := range packages {\n    for ident, obj := range pkg.TypesInfo.Uses {\n        if obj == targetObject {\n            // Found a reference\n            pos := pkg.Fset.Position(ident.Pos())\n            // Extract snippet, build result\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Find function references (not just calls)\n- [ ] Find type references\n- [ ] Find variable/constant references\n- [ ] Output JSON with same structure as callers\n- [ ] Include reference type/reason\n- [ ] All standard flags work\n- [ ] Integration test with various reference types\n\n## Files\n- cmd/refs.go\n- cmd/refs_test.go\n\n## Depends On\n- wc-af7d.2 (Symbol resolution)\n- wc-af7d.4 (Output formatting)\n- wc-af7d.5 (Error handling)\n\n## Note\nDoes NOT depend on call graph (wc-af7d.3). Uses type checker info directly.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-10T04:00:59.248894512Z","updated_at":"2026-01-10T05:40:08.716605367Z","closed_at":"2026-01-10T05:40:08.716605367Z","dependencies":[{"issue_id":"wc-af7d.9","depends_on_id":"wc-af7d.2","type":"blocks","created_at":"2026-01-10T04:00:59.253045928Z","created_by":"jason"},{"issue_id":"wc-af7d.9","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T04:00:59.256479231Z","created_by":"jason"},{"issue_id":"wc-af7d.9","depends_on_id":"wc-af7d.5","type":"blocks","created_at":"2026-01-10T04:00:59.260561319Z","created_by":"jason"}]}
{"id":"wc-b718","content_hash":"f8f2bc111bdc57e837aa560f030e7e46cf989ab4b555515c2dc52e341bc6e33d","title":"Output plugin system for custom formats","description":"## Context\nThis is the hackathon \"curveball\" feature. Wildcat needs to support user-defined output formats beyond JSON.\n\n## Deferred Decision\nFor MVP, we output JSON only. This ticket captures the plugin design for later implementation.\n\n## Proposed Architecture\n\n### Three-tier approach (simple → complex):\n\n1. **Built-in formatters** - Common formats shipped with Wildcat\n   - json (default)\n   - yaml\n   - dot (graphviz)\n   - markdown (tables)\n\n2. **Go templates** - User customization without code\n   - `--output template:./my.tmpl`\n   - Access to full result structure\n   - Easy to share as text files\n\n3. **External plugins** - Complex transformations\n   - `--output plugin:myplugin`\n   - Discovers `wildcat-format-myplugin` in PATH or plugin dir\n   - Receives JSON on stdin, outputs formatted result\n   - Language-agnostic (any executable)\n\n## Interface Design\n\n```go\n// internal/output/formatter.go\ntype Formatter interface {\n    // Format transforms the result into the desired output format\n    Format(result any) ([]byte, error)\n    \n    // Name returns the formatter name (e.g., \"dot\", \"yaml\")\n    Name() string\n    \n    // Description returns help text for --help\n    Description() string\n}\n\n// Registry for formatters\ntype Registry interface {\n    Register(f Formatter)\n    Get(name string) (Formatter, error)\n    List() []string\n}\n\n// For external plugins\ntype ExternalPlugin struct {\n    Command string   // e.g., \"wildcat-format-dot\"\n    Args    []string\n}\n\nfunc (p *ExternalPlugin) Format(result any) ([]byte, error) {\n    // Marshal to JSON, pipe to command, return stdout\n}\n```\n\n## CLI Design\n\n```bash\n# Built-in\nwildcat callers config.Load                      # JSON (default)\nwildcat callers config.Load --output yaml\nwildcat callers config.Load --output dot\nwildcat callers config.Load --output markdown\n\n# Template\nwildcat callers config.Load --output template:./custom.tmpl\n\n# External plugin  \nwildcat callers config.Load --output plugin:myplugin\n# Looks for: wildcat-format-myplugin\n\n# List available formatters\nwildcat formats\n```\n\n## Plugin Discovery\n\n1. Check `$PATH` for `wildcat-format-\u003cname\u003e`\n2. Check `~/.config/wildcat/plugins/`\n3. Check `./plugins/` in current directory\n\n## Built-in Formatters to Implement\n\n### dot (graphviz)\nFor tree command - visualize call graphs:\n```dot\ndigraph callgraph {\n  \"main.main\" -\u003e \"cmd.Execute\"\n  \"cmd.Execute\" -\u003e \"config.Load\"\n}\n```\n\n### yaml\nDirect YAML serialization of JSON output.\n\n### markdown\nTables for callers/refs, indented lists for trees:\n```markdown\n## Callers of config.Load\n\n| Caller | File | Line |\n|--------|------|------|\n| main.main | main.go | 23 |\n```\n\n## Acceptance Criteria\n- [ ] Formatter interface defined\n- [ ] Registry for formatter lookup\n- [ ] Built-in: yaml formatter\n- [ ] Built-in: dot formatter (for tree)\n- [ ] Built-in: markdown formatter\n- [ ] Go template support\n- [ ] External plugin discovery\n- [ ] External plugin execution (stdin/stdout)\n- [ ] `wildcat formats` command to list available\n- [ ] Plugin error handling (not found, execution failure)\n- [ ] Documentation for writing plugins\n\n## Files\n- internal/output/formatter.go (interface)\n- internal/output/registry.go\n- internal/output/yaml.go\n- internal/output/dot.go\n- internal/output/markdown.go\n- internal/output/template.go\n- internal/output/plugin.go (external)\n- cmd/formats.go\n\n## Design Principles (from CLAUDE.md)\n- **Composability first**: Formatter interface allows easy extension\n- **Simple over clever**: Start with built-ins, templates before external plugins\n\n## Priority\nP3 (Backlog) - Implement after MVP commands work with JSON output.\n\n## Depends On\n- wc-af7d.4 (JSON output formatting - need base types first)","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-10T05:14:19.768564456Z","updated_at":"2026-01-10T05:51:13.948844689Z","closed_at":"2026-01-10T05:51:13.948844689Z","dependencies":[{"issue_id":"wc-b718","depends_on_id":"wc-af7d.4","type":"blocks","created_at":"2026-01-10T05:14:23.909419837Z","created_by":"jason"}]}
{"id":"wc-b79d","content_hash":"6f82166965b506246eaec4e5fb223b1722a04790dadfc1f69156afb1e70130f9","title":"Hackathon demo preparation","description":"## Context\nPrepare and execute a compelling demo of Wildcat for the hackathon judges.\n\n## Demo Script\n\n### 1. The Problem (30 sec)\n- AI agents need to understand code semantically, not just grep\n- \"What calls this function?\" \"What breaks if I change this?\"\n- Existing tools: gopls is IDE-focused, grep is text-only\n\n### 2. The Solution (30 sec)\n- Wildcat: LSP-based static analysis for AI agents\n- Language-agnostic (Go, Python, TypeScript, Rust, C++)\n- JSON output optimized for tool integration\n\n### 3. Live Demo (2-3 min)\n\n```bash\n# Find all callers of a function\n./bin/wildcat callers lsp.NewClient\n\n# What would break if we changed this type?\n./bin/wildcat impact lsp.Client\n\n# Find all types implementing an interface\n./bin/wildcat implements output.Formatter\n\n# Visualize call graph\n./bin/wildcat callers output.NewWriter -o dot\n\n# Package dependencies\n./bin/wildcat deps ./internal/lsp --reverse\n\n# AI onboarding\n./bin/wildcat readme --compact\n```\n\n### 4. Output Formats (30 sec)\n- JSON (default) - for AI consumption\n- YAML, Markdown - human readable\n- DOT - Graphviz visualization\n- Extensible plugin system\n\n### 5. Curveball Feature (30 sec)\n- Output plugin system\n- Built-in: json, yaml, markdown, dot\n- Custom: Go templates, external plugins\n- `wildcat formats` to list available\n\n## Key Talking Points\n- Uses LSP for language-agnostic support\n- Answers semantic questions grep can't\n- Designed for AI agents, not humans\n- Extensible output system (curveball)\n- Self-documenting (readme command)\n\n## Demo Environment\n- [ ] Clean terminal with large font\n- [ ] Pre-built binary ready\n- [ ] Test commands work on wildcat codebase\n- [ ] Have backup screenshots if LSP is slow\n\n## Acceptance Criteria\n- [ ] Demo script rehearsed\n- [ ] All commands tested\n- [ ] Timing under 5 minutes\n- [ ] Backup plan if something fails","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-10T06:18:09.779572934Z","updated_at":"2026-01-10T06:25:33.576243537Z","closed_at":"2026-01-10T06:25:33.576243537Z"}
{"id":"wc-cb10","content_hash":"3530ccc4c877c7fb870cdb32cbfd1b7456eaf38a2cad1bed23fd70c43bfba3d0","title":"LSP client infrastructure","description":"## Context\nFollowing the LSP feasibility research (wc-d974), we're pivoting to an LSP-based architecture. This makes Wildcat language-agnostic, supporting any language with an LSP server.\n\n## Architecture Decision\n**Wildcat as LSP Orchestrator**: We use LSP servers (gopls, rust-analyzer, pyright, etc.) as backends, orchestrating multiple calls, handling recursion, extracting snippets, and formatting output for AI consumption.\n\n## Scope\nCreate `internal/lsp` package that:\n\n### 1. LSP Client Core\n- JSON-RPC 2.0 client over stdio\n- Request/response with ID tracking\n- Notification handling\n- Timeouts and error handling\n\n### 2. Server Lifecycle Management\n- Start LSP server process\n- Initialize/shutdown handshake\n- Keep-alive for multiple queries\n- Graceful cleanup\n\n### 3. Core LSP Methods\nImplement wrappers for:\n- `initialize` / `shutdown`\n- `textDocument/didOpen` (for symbol lookup context)\n- `workspace/symbol` - find symbols by name\n- `textDocument/prepareCallHierarchy`\n- `callHierarchy/incomingCalls`\n- `callHierarchy/outgoingCalls`\n- `textDocument/references`\n- `textDocument/implementation`\n- `textDocument/typeDefinition`\n\n### 4. Protocol Types\nDefine Go types for:\n- Position, Range, Location\n- TextDocumentIdentifier\n- SymbolInformation\n- CallHierarchyItem, CallHierarchyIncomingCall, CallHierarchyOutgoingCall\n- ReferenceParams, ImplementationParams\n\n## Interface Design\n```go\ntype Client interface {\n    // Lifecycle\n    Initialize(ctx context.Context, rootURI string) error\n    Shutdown(ctx context.Context) error\n\n    // Symbol lookup\n    WorkspaceSymbol(ctx context.Context, query string) ([]SymbolInformation, error)\n\n    // Call hierarchy\n    PrepareCallHierarchy(ctx context.Context, uri string, pos Position) ([]CallHierarchyItem, error)\n    IncomingCalls(ctx context.Context, item CallHierarchyItem) ([]CallHierarchyIncomingCall, error)\n    OutgoingCalls(ctx context.Context, item CallHierarchyItem) ([]CallHierarchyOutgoingCall, error)\n\n    // References\n    References(ctx context.Context, uri string, pos Position) ([]Location, error)\n    Implementation(ctx context.Context, uri string, pos Position) ([]Location, error)\n}\n\ntype ServerConfig struct {\n    Command  string   // e.g. \"gopls\", \"rust-analyzer\"\n    Args     []string // e.g. [\"-mode=stdio\"]\n    RootURI  string   // workspace root\n}\n```\n\n## Acceptance Criteria\n- [ ] JSON-RPC client over stdio works\n- [ ] Can start/stop LSP server\n- [ ] Initialize handshake succeeds\n- [ ] workspace/symbol returns results\n- [ ] Call hierarchy methods work\n- [ ] References method works\n- [ ] Proper timeout handling\n- [ ] Unit tests with mock server\n- [ ] Integration test with gopls\n\n## Files\n- internal/lsp/client.go\n- internal/lsp/protocol.go (types)\n- internal/lsp/jsonrpc.go\n- internal/lsp/server.go (lifecycle)\n- internal/lsp/*_test.go\n\n## Why This Matters\nThis is the foundation for language-agnostic support. Every Wildcat command will use this client to communicate with language servers.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-10T04:56:59.354691328Z","updated_at":"2026-01-10T05:26:40.66299368Z","closed_at":"2026-01-10T05:26:40.66299368Z"}
{"id":"wc-d974","content_hash":"ccfb717b986bbba299f71e4d24ae05b07c70a6eb649c93abdfdc3e0763d0bca6","title":"Research LSP protocol for language-agnostic approach","description":"## Context\nBefore committing to Go-specific implementation, explore whether LSP (Language Server Protocol) can provide the features we need. If yes, Wildcat could be language-agnostic, working with any language that has an LSP server.\n\nThis is a potential PIVOT that would change our architecture significantly.\n\n## Key Questions\n\n### 1. Feature Coverage\nDoes LSP provide what we need for each Wildcat command?\n\n| Command | LSP Method | Sufficient? |\n|---------|------------|-------------|\n| callers | callHierarchy/incomingCalls | ? |\n| callees | callHierarchy/outgoingCalls | ? |\n| tree | recursive call hierarchy? | ? |\n| refs | textDocument/references | ? |\n| impact | combination of above? | ? |\n| implements | textDocument/implementation | ? |\n\n### 2. Call Hierarchy Depth\n- Does LSP support transitive/recursive call hierarchy?\n- Or only direct callers/callees (depth 1)?\n- Would we need to make recursive calls ourselves?\n\n### 3. Output Richness\n- Do responses include snippets/context?\n- File paths, line numbers, columns?\n- Enough for AI tool consumption?\n\n### 4. Performance\n- LSP is designed for interactive IDE use\n- How does it perform for batch queries?\n- Startup time for LSP servers?\n- Can we keep server running for multiple queries?\n\n### 5. Cross-Language Consistency\nSurvey LSP support across key languages:\n- Go (gopls)\n- Python (pyright, pylsp)\n- TypeScript/JavaScript (typescript-language-server)\n- Rust (rust-analyzer)\n- Java (eclipse.jdt.ls)\n- C/C++ (clangd)\n\nWhich features are consistently available?\n\n### 6. Symbol Specification\n- How do we specify symbols in LSP? (need file:line:col?)\n- Can we query by name like \"pkg.Func\"?\n- This was a key gopls limitation - does LSP protocol solve it?\n\n## Research Tasks\n\n1. **Read LSP 3.17 spec** for call hierarchy, references, implementation\n2. **Test gopls LSP mode** - make actual LSP calls, examine responses\n3. **Compare responses** to our desired output format\n4. **Test other LSP servers** - at least one other language\n5. **Evaluate recursive queries** - can we build trees?\n6. **Assess performance** - time queries, measure overhead\n\n## Deliverables\n\nCreate `docs/lsp-feasibility.md` with:\n1. Feature-by-feature LSP capability assessment\n2. Sample LSP request/response for each feature\n3. Gap analysis: what LSP provides vs what we need\n4. Cross-language support matrix\n5. Performance observations\n6. Recommendation: Go-specific vs LSP-based vs hybrid\n\n## Decision Criteria\n\n**Go with LSP if:**\n- Call hierarchy provides depth/recursive queries OR easy to implement client-side\n- Output is rich enough (file, line, context)\n- Performance is acceptable for batch use\n- Good support across 3+ major languages\n\n**Stay Go-specific if:**\n- LSP call hierarchy is too limited (depth 1 only, no recursion)\n- Output lacks necessary context\n- Performance is problematic\n- Cross-language support is inconsistent\n\n## Why This Matters\nLanguage-agnostic tool = much larger impact. But only if LSP can deliver the depth of analysis we need. This research determines our path.\n\n## Priority\nP0 - This decision affects all subsequent work. Must resolve before continuing with wc-af7d.1.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-10T04:16:58.761377704Z","updated_at":"2026-01-10T04:54:55.767044668Z","closed_at":"2026-01-10T04:54:55.767044668Z"}
{"id":"wc-deda","content_hash":"7032e37b375b7f190a685c7161047e190fbead76d75b2ae923ae20fd6c8efb8e","title":"Write README.md and product design doc","description":"## Context\nWe've completed research on gopls (see docs/gopls-report.md) and designed \nWildcat's approach through conversation. Need to capture this in formal docs.\n\n## Scope\n1. README.md - Public-facing, explains premise and value proposition\n   - Problem: gopls is IDE-focused, not AI-optimized\n   - Solution: Wildcat - Go static analysis for AI agents\n   - Key features: symbol-based queries, JSON output, actionable results\n   - Examples showing the difference\n\n2. docs/product-design.md - Detailed feature specs\n   - Target user: AI agents (Claude, etc.)\n   - Command specifications (callers, tree, refs, etc.)\n   - Output format specs (JSON structure)\n   - Filtering/limiting options\n   - Error handling approach\n\n## Acceptance Criteria\n- [ ] README.md captures value prop clearly\n- [ ] Product design doc has detailed specs for MVP commands\n- [ ] Both reference research in docs/gopls-report.md\n\n## Relevant Files\n- docs/gopls-report.md - Gap analysis\n- docs/research.md - Initial design notes","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T03:40:40.229778888Z","updated_at":"2026-01-10T03:43:57.002420885Z","closed_at":"2026-01-10T03:43:57.002420885Z"}
{"id":"wc-f45a","content_hash":"e9e7731548769bb93a5415a91225dd5b3e05a641b67699a5a56d92b3fd2de0a6","title":"Eval: SWE-bench Lite with Wildcat","description":"","status":"in_progress","priority":1,"issue_type":"task","created_at":"2026-01-11T02:36:36.842030212Z","updated_at":"2026-01-11T05:09:29.234597002Z"}
